{"version":3,"file":"kinto-http.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/errors.ts","../node_modules/uuid/dist/esm-browser/rng.js","../src/http.ts","../src/endpoints.ts","../src/requests.ts","../src/batch.ts","../node_modules/uuid/dist/esm-browser/regex.js","../node_modules/uuid/dist/esm-browser/validate.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/collection.ts","../src/bucket.ts","../src/index.ts","../src/base.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","/**\n * Chunks an array into n pieces.\n *\n * @private\n * @param  {Array}  array\n * @param  {Number} n\n * @return {Array}\n */\nexport function partition<T>(array: T[], n: number): T[][] {\n  if (n <= 0) {\n    return [array];\n  }\n  return array.reduce<T[][]>((acc, x, i) => {\n    if (i === 0 || i % n === 0) {\n      acc.push([x]);\n    } else {\n      acc[acc.length - 1].push(x);\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * Returns a Promise always resolving after the specified amount in milliseconds.\n *\n * @return Promise<void>\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ninterface Entity {\n  id: string;\n}\n\n/**\n * Always returns a resource data object from the provided argument.\n *\n * @private\n * @param  {Object|String} resource\n * @return {Object}\n */\nexport function toDataBody<T extends Entity>(resource: T | string): Entity {\n  if (isObject(resource)) {\n    return resource as T;\n  }\n  if (typeof resource === \"string\") {\n    return { id: resource };\n  }\n  throw new Error(\"Invalid argument.\");\n}\n\n/**\n * Transforms an object into an URL query string, stripping out any undefined\n * values.\n *\n * @param  {Object} obj\n * @return {String}\n */\nexport function qsify(obj: { [key: string]: any }): string {\n  const encode = (v: any): string =>\n    encodeURIComponent(typeof v === \"boolean\" ? String(v) : v);\n  const stripped = cleanUndefinedProperties(obj);\n  return Object.keys(stripped)\n    .map((k) => {\n      const ks = encode(k) + \"=\";\n      if (Array.isArray(stripped[k])) {\n        return ks + stripped[k].map((v: any) => encode(v)).join(\",\");\n      } else {\n        return ks + encode(stripped[k]);\n      }\n    })\n    .join(\"&\");\n}\n\n/**\n * Checks if a version is within the provided range.\n *\n * @param  {String} version    The version to check.\n * @param  {String} minVersion The minimum supported version (inclusive).\n * @param  {String} maxVersion The minimum supported version (exclusive).\n * @throws {Error} If the version is outside of the provided range.\n */\nexport function checkVersion(\n  version: string,\n  minVersion: string,\n  maxVersion: string\n): void {\n  const extract = (str: string): number[] =>\n    str.split(\".\").map((x) => parseInt(x, 10));\n  const [verMajor, verMinor] = extract(version);\n  const [minMajor, minMinor] = extract(minVersion);\n  const [maxMajor, maxMinor] = extract(maxVersion);\n  const checks = [\n    verMajor < minMajor,\n    verMajor === minMajor && verMinor < minMinor,\n    verMajor > maxMajor,\n    verMajor === maxMajor && verMinor >= maxMinor,\n  ];\n  if (checks.some((x) => x)) {\n    throw new Error(\n      `Version ${version} doesn't satisfy ${minVersion} <= x < ${maxVersion}`\n    );\n  }\n}\n\ntype DecoratorReturn = (\n  target: any,\n  key: string,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n) => {\n  configurable: boolean;\n  get(): (...args: any) => Promise<any>;\n};\n\n/**\n * Generates a decorator function ensuring a version check is performed against\n * the provided requirements before executing it.\n *\n * @param  {String} min The required min version (inclusive).\n * @param  {String} max The required max version (inclusive).\n * @return {Function}\n */\nexport function support(min: string, max: string): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): Promise<any> => {\n          // \"this\" is the current instance which its method is decorated.\n          const client = (this as any).client ? (this as any).client : this;\n          return client\n            .fetchHTTPApiVersion()\n            .then((version: string) => checkVersion(version, min, max))\n            .then(() => fn!.apply(this, args));\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Generates a decorator function ensuring that the specified capabilities are\n * available on the server before executing it.\n *\n * @param  {Array<String>} capabilities The required capabilities.\n * @return {Function}\n */\nexport function capable(capabilities: string[]): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): Promise<any> => {\n          // \"this\" is the current instance which its method is decorated.\n          const client = (this as any).client ? (this as any).client : this;\n          return client\n            .fetchServerCapabilities()\n            .then((available: string[]) => {\n              const missing = capabilities.filter((c) => !(c in available));\n              if (missing.length > 0) {\n                const missingStr = missing.join(\", \");\n                throw new Error(\n                  `Required capabilities ${missingStr} not present on server`\n                );\n              }\n            })\n            .then(() => fn!.apply(this, args));\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Generates a decorator function ensuring an operation is not performed from\n * within a batch request.\n *\n * @param  {String} message The error message to throw.\n * @return {Function}\n */\nexport function nobatch(message: string): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): any => {\n          // \"this\" is the current instance which its method is decorated.\n          if ((this as any)._isBatch) {\n            throw new Error(message);\n          }\n          return fn!.apply(this, args);\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Returns true if the specified value is an object (i.e. not an array nor null).\n * @param  {Object} thing The value to inspect.\n * @return {bool}\n */\nexport function isObject(thing: unknown): boolean {\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n\ninterface TypedDataURL {\n  type: string;\n  base64: string;\n  [key: string]: string;\n}\n\n/**\n * Parses a data url.\n * @param  {String} dataURL The data url.\n * @return {Object}\n */\nexport function parseDataURL(dataURL: string): TypedDataURL {\n  const regex = /^data:(.*);base64,(.*)/;\n  const match = dataURL.match(regex);\n  if (!match) {\n    throw new Error(`Invalid data-url: ${String(dataURL).substr(0, 32)}...`);\n  }\n  const props = match[1];\n  const base64 = match[2];\n  const [type, ...rawParams] = props.split(\";\");\n  const params = rawParams.reduce<{ [key: string]: string }>((acc, param) => {\n    const [key, value] = param.split(\"=\");\n    return { ...acc, [key]: value };\n  }, {});\n  return { ...params, type, base64 };\n}\n\n/**\n * Extracts file information from a data url.\n * @param  {String} dataURL The data url.\n * @return {Object}\n */\nexport function extractFileInfo(dataURL: string): {\n  blob: Blob;\n  name: string;\n} {\n  const { name, type, base64 } = parseDataURL(dataURL);\n  const binary = atob(base64);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  const blob = new Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n\n/**\n * Creates a FormData instance from a data url and an existing JSON response\n * body.\n * @param  {String} dataURL            The data url.\n * @param  {Object} body               The response body.\n * @param  {Object} [options={}]       The options object.\n * @param  {Object} [options.filename] Force attachment file name.\n * @return {FormData}\n */\nexport function createFormData(\n  dataURL: string,\n  body: { [key: string]: any },\n  options: { filename?: string } = {}\n): FormData {\n  const { filename = \"untitled\" } = options;\n  const { blob, name } = extractFileInfo(dataURL);\n  const formData = new FormData();\n  formData.append(\"attachment\", blob, name || filename);\n  for (const property in body) {\n    if (typeof body[property] !== \"undefined\") {\n      formData.append(property, JSON.stringify(body[property]));\n    }\n  }\n  return formData;\n}\n\n/**\n * Clones an object with all its undefined keys removed.\n * @private\n */\nexport function cleanUndefinedProperties(obj: { [key: string]: any }): {\n  [key: string]: any;\n} {\n  const result: { [key: string]: any } = {};\n  for (const key in obj) {\n    if (typeof obj[key] !== \"undefined\") {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Handle common query parameters for Kinto requests.\n *\n * @param  {String}  [path]  The endpoint base path.\n * @param  {Array}   [options.fields]    Fields to limit the\n *   request to.\n * @param  {Object}  [options.query={}]  Additional query arguments.\n */\nexport function addEndpointOptions(\n  path: string,\n  options: { fields?: string[]; query?: { [key: string]: string } } = {}\n): string {\n  const query: { [key: string]: any } = { ...options.query };\n  if (options.fields) {\n    query._fields = options.fields;\n  }\n  const queryString = qsify(query);\n  if (queryString) {\n    return path + \"?\" + queryString;\n  }\n  return path;\n}\n\n/**\n * Replace authorization header with an obscured version\n */\nexport function obscureAuthorizationHeader(headers: HeadersInit): {\n  [key: string]: string;\n} {\n  const h = new Headers(headers);\n  if (h.has(\"authorization\")) {\n    h.set(\"authorization\", \"**** (suppressed)\");\n  }\n\n  const obscuredHeaders: { [key: string]: string } = {};\n  for (const [header, value] of h.entries()) {\n    obscuredHeaders[header] = value;\n  }\n\n  return obscuredHeaders;\n}\n","import { FetchResponse } from \"./types\";\n\n/**\n * Kinto server error code descriptors.\n */\nconst ERROR_CODES = {\n  104: \"Missing Authorization Token\",\n  105: \"Invalid Authorization Token\",\n  106: \"Request body was not valid JSON\",\n  107: \"Invalid request parameter\",\n  108: \"Missing request parameter\",\n  109: \"Invalid posted data\",\n  110: \"Invalid Token / id\",\n  111: \"Missing Token / id\",\n  112: \"Content-Length header was not provided\",\n  113: \"Request body too large\",\n  114: \"Resource was created, updated or deleted meanwhile\",\n  115: \"Method not allowed on this end point (hint: server may be readonly)\",\n  116: \"Requested version not available on this server\",\n  117: \"Client has sent too many requests\",\n  121: \"Resource access is forbidden for this user\",\n  122: \"Another resource violates constraint\",\n  201: \"Service Temporary unavailable due to high load\",\n  202: \"Service deprecated\",\n  999: \"Internal Server Error\",\n};\n\nexport default ERROR_CODES;\n\nclass NetworkTimeoutError extends Error {\n  public url: string;\n  public options: Object;\n\n  constructor(url: string, options: Object) {\n    super(\n      `Timeout while trying to access ${url} with ${JSON.stringify(options)}`\n    );\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkTimeoutError);\n    }\n\n    this.url = url;\n    this.options = options;\n  }\n}\n\nclass UnparseableResponseError extends Error {\n  public status: number;\n  public response: FetchResponse;\n  public stack?: string;\n  public error: Error;\n\n  constructor(response: FetchResponse, body: string, error: Error) {\n    const { status } = response;\n\n    super(\n      `Response from server unparseable (HTTP ${\n        status || 0\n      }; ${error}): ${body}`\n    );\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnparseableResponseError);\n    }\n\n    this.status = status;\n    this.response = response;\n    this.stack = error.stack;\n    this.error = error;\n  }\n}\n\nexport interface ServerResponseObject {\n  code: number;\n  errno: keyof typeof ERROR_CODES;\n  error: string;\n  message: string;\n  info: string;\n  details: unknown;\n}\n\n/**\n * \"Error\" subclass representing a >=400 response from the server.\n *\n * Whether or not this is an error depends on your application.\n *\n * The `json` field can be undefined if the server responded with an\n * empty response body. This shouldn't generally happen. Most \"bad\"\n * responses come with a JSON error description, or (if they're\n * fronted by a CDN or nginx or something) occasionally non-JSON\n * responses (which become UnparseableResponseErrors, above).\n */\nclass ServerResponse extends Error {\n  public response: FetchResponse;\n  public data?: ServerResponseObject;\n\n  constructor(response: FetchResponse, json?: ServerResponseObject) {\n    const { status } = response;\n    let { statusText } = response;\n    let errnoMsg;\n\n    if (json) {\n      // Try to fill in information from the JSON error.\n      statusText = json.error || statusText;\n\n      // Take errnoMsg from either ERROR_CODES or json.message.\n      if (json.errno && json.errno in ERROR_CODES) {\n        errnoMsg = ERROR_CODES[json.errno];\n      } else if (json.message) {\n        errnoMsg = json.message;\n      }\n\n      // If we had both ERROR_CODES and json.message, and they differ,\n      // combine them.\n      if (errnoMsg && json.message && json.message !== errnoMsg) {\n        errnoMsg += ` (${json.message})`;\n      }\n    }\n\n    let message = `HTTP ${status} ${statusText}`;\n    if (errnoMsg) {\n      message += `: ${errnoMsg}`;\n    }\n\n    super(message.trim());\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServerResponse);\n    }\n\n    this.response = response;\n    this.data = json;\n  }\n}\n\nexport { NetworkTimeoutError, ServerResponse, UnparseableResponseError };\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import { delay, obscureAuthorizationHeader } from \"./utils\";\nimport {\n  NetworkTimeoutError,\n  ServerResponse,\n  UnparseableResponseError,\n  ServerResponseObject,\n} from \"./errors\";\nimport { Emitter, FetchFunction, FetchHeaders, FetchResponse } from \"./types\";\n\ninterface HttpOptions {\n  timeout?: number | null;\n  requestMode?: RequestMode;\n  fetchFunc?: FetchFunction;\n}\n\ninterface RequestOptions {\n  retry: number;\n}\n\nexport interface HttpResponse<T> {\n  status: number;\n  json: T;\n  headers: FetchHeaders;\n}\n\n/**\n * Enhanced HTTP client for the Kinto protocol.\n * @private\n */\nexport default class HTTP {\n  /**\n   * Default HTTP request headers applied to each outgoing request.\n   *\n   * @type {Object}\n   */\n  static get DEFAULT_REQUEST_HEADERS(): Record<string, string> {\n    return {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    };\n  }\n\n  /**\n   * Default options.\n   *\n   * @type {Object}\n   */\n  static get defaultOptions(): HttpOptions {\n    return { timeout: null, requestMode: \"cors\" };\n  }\n\n  public events?: Emitter;\n  public requestMode: RequestMode;\n  public timeout: number;\n  public fetchFunc: FetchFunction;\n\n  /**\n   * Constructor.\n   *\n   * @param {EventEmitter} events                       The event handler.\n   * @param {Object}       [options={}}                 The options object.\n   * @param {Number}       [options.timeout=null]       The request timeout in ms, if any (default: `null`).\n   * @param {String}       [options.requestMode=\"cors\"] The HTTP request mode (default: `\"cors\"`).\n   */\n  constructor(events?: Emitter, options: HttpOptions = {}) {\n    // public properties\n    /**\n     * The event emitter instance.\n     * @type {EventEmitter}\n     */\n    this.events = events;\n\n    /**\n     * The request mode.\n     * @see  https://fetch.spec.whatwg.org/#requestmode\n     * @type {String}\n     */\n    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode!;\n\n    /**\n     * The request timeout.\n     * @type {Number}\n     */\n    this.timeout = options.timeout || HTTP.defaultOptions.timeout!;\n\n    /**\n     * The fetch() function.\n     * @type {Function}\n     */\n    this.fetchFunc = options.fetchFunc || globalThis.fetch.bind(globalThis);\n  }\n\n  /**\n   * @private\n   */\n  timedFetch(url: string, options: RequestInit): Promise<FetchResponse> {\n    let hasTimedout = false;\n    return new Promise((resolve, reject) => {\n      // Detect if a request has timed out.\n      let _timeoutId: ReturnType<typeof setTimeout>;\n      if (this.timeout) {\n        _timeoutId = setTimeout(() => {\n          hasTimedout = true;\n          if (options && options.headers) {\n            options = {\n              ...options,\n              headers: obscureAuthorizationHeader(options.headers),\n            };\n          }\n          reject(new NetworkTimeoutError(url, options));\n        }, this.timeout);\n      }\n      function proceedWithHandler(fn: (arg: any) => void): (arg: any) => void {\n        return (arg: any) => {\n          if (!hasTimedout) {\n            if (_timeoutId) {\n              clearTimeout(_timeoutId);\n            }\n            fn(arg);\n          }\n        };\n      }\n      this.fetchFunc(url, options)\n        .then(proceedWithHandler(resolve))\n        .catch(proceedWithHandler(reject));\n    });\n  }\n\n  /**\n   * @private\n   */\n  async processResponse<T>(response: FetchResponse): Promise<HttpResponse<T>> {\n    const { status, headers } = response;\n    const text = await response.text();\n    // Check if we have a body; if so parse it as JSON.\n    let json: unknown;\n    if (text.length !== 0) {\n      try {\n        json = JSON.parse(text);\n      } catch (err) {\n        throw new UnparseableResponseError(response, text, err);\n      }\n    }\n    if (status >= 400) {\n      throw new ServerResponse(response, json as ServerResponseObject);\n    }\n    return { status, json: json as T, headers };\n  }\n\n  /**\n   * @private\n   */\n  async retry<T>(\n    url: string,\n    retryAfter: number,\n    request: RequestInit,\n    options: RequestOptions\n  ): Promise<HttpResponse<T>> {\n    await delay(retryAfter);\n    return this.request<T>(url, request, {\n      ...options,\n      retry: options.retry - 1,\n    });\n  }\n\n  /**\n   * Performs an HTTP request to the Kinto server.\n   *\n   * Resolves with an objet containing the following HTTP response properties:\n   * - `{Number}  status`  The HTTP status code.\n   * - `{Object}  json`    The JSON response body.\n   * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.\n   *\n   * @param  {String} url               The URL.\n   * @param  {Object} [request={}]      The request object, passed to\n   *     fetch() as its options object.\n   * @param  {Object} [request.headers] The request headers object (default: {})\n   * @param  {Object} [options={}]      Options for making the\n   *     request\n   * @param  {Number} [options.retry]   Number of retries (default: 0)\n   * @return {Promise}\n   */\n  async request<T>(\n    url: string,\n    request: RequestInit = { headers: {} },\n    options: RequestOptions = { retry: 0 }\n  ): Promise<HttpResponse<T>> {\n    // Ensure default request headers are always set\n    request.headers = { ...HTTP.DEFAULT_REQUEST_HEADERS, ...request.headers };\n    // If a multipart body is provided, remove any custom Content-Type header as\n    // the fetch() implementation will add the correct one for us.\n    if (request.body && request.body instanceof FormData) {\n      if (request.headers instanceof Headers) {\n        request.headers.delete(\"Content-Type\");\n      } else if (!Array.isArray(request.headers)) {\n        delete request.headers[\"Content-Type\"];\n      }\n    }\n    request.mode = this.requestMode;\n\n    const response = await this.timedFetch(url, request);\n    const { headers } = response;\n\n    this._checkForDeprecationHeader(headers);\n    this._checkForBackoffHeader(headers);\n\n    // Check if the server summons the client to retry after a while.\n    const retryAfter = this._checkForRetryAfterHeader(headers);\n    // If number of allowed of retries is not exhausted, retry the same request.\n    if (retryAfter && options.retry > 0) {\n      return this.retry<T>(url, retryAfter, request, options);\n    } else {\n      return this.processResponse<T>(response);\n    }\n  }\n\n  _checkForDeprecationHeader(headers: FetchHeaders): void {\n    const alertHeader = headers.get(\"Alert\");\n    if (!alertHeader) {\n      return;\n    }\n    let alert;\n    try {\n      alert = JSON.parse(alertHeader);\n    } catch (err) {\n      console.warn(\"Unable to parse Alert header message\", alertHeader);\n      return;\n    }\n    console.warn(alert.message, alert.url);\n    if (this.events) {\n      this.events.emit(\"deprecated\", alert);\n    }\n  }\n\n  _checkForBackoffHeader(headers: FetchHeaders): void {\n    let backoffMs;\n    const backoffHeader = headers.get(\"Backoff\");\n    const backoffSeconds = backoffHeader ? parseInt(backoffHeader, 10) : 0;\n    if (backoffSeconds > 0) {\n      backoffMs = new Date().getTime() + backoffSeconds * 1000;\n    } else {\n      backoffMs = 0;\n    }\n    if (this.events) {\n      this.events.emit(\"backoff\", backoffMs);\n    }\n  }\n\n  _checkForRetryAfterHeader(headers: FetchHeaders): number | undefined {\n    const retryAfter = headers.get(\"Retry-After\");\n    if (!retryAfter) {\n      return;\n    }\n    const delay = parseInt(retryAfter, 10) * 1000;\n    const tryAgainAfter = new Date().getTime() + delay;\n    if (this.events) {\n      this.events.emit(\"retry-after\", tryAgainAfter);\n    }\n    return delay;\n  }\n}\n","/**\n * Endpoints templates.\n * @type {Object}\n */\nconst ENDPOINTS = {\n  root: () => \"/\",\n  batch: () => \"/batch\",\n  permissions: () => \"/permissions\",\n  bucket: (bucket?: string) => \"/buckets\" + (bucket ? `/${bucket}` : \"\"),\n  history: (bucket: string) => `${ENDPOINTS.bucket(bucket)}/history`,\n  collection: (bucket: string, coll?: string) =>\n    `${ENDPOINTS.bucket(bucket)}/collections` + (coll ? `/${coll}` : \"\"),\n  group: (bucket: string, group?: string) =>\n    `${ENDPOINTS.bucket(bucket)}/groups` + (group ? `/${group}` : \"\"),\n  record: (bucket: string, coll: string, id?: string) =>\n    `${ENDPOINTS.collection(bucket, coll)}/records` + (id ? `/${id}` : \"\"),\n  attachment: (bucket: string, coll: string, id: string) =>\n    `${ENDPOINTS.record(bucket, coll, id)}/attachment`,\n};\n\nexport default ENDPOINTS;\n","import { KintoRequest, HttpMethod, Permission } from \"./types\";\nimport { createFormData } from \"./utils\";\n\ninterface RequestOptions {\n  safe?: boolean;\n  headers?: Headers | Record<string, string> | string[][];\n  method?: HttpMethod;\n  gzipped?: boolean | null;\n  last_modified?: number;\n  patch?: boolean;\n}\ntype AddAttachmentRequestOptions = RequestOptions & {\n  last_modified?: number;\n  filename?: string;\n};\n\ntype RequestBody = {\n  data?: any;\n  permissions?: Partial<Record<Permission, string[]>>;\n};\ninterface RecordRequestBody extends RequestBody {\n  data?: { id?: string; last_modified?: number; [key: string]: any };\n}\n\nconst requestDefaults: RequestOptions = {\n  safe: false,\n  // check if we should set default content type here\n  headers: {},\n  patch: false,\n};\n\n/**\n * @private\n */\nfunction safeHeader(\n  safe?: boolean,\n  last_modified?: number\n): Record<string, string> {\n  if (!safe) {\n    return {};\n  }\n  if (last_modified) {\n    return { \"If-Match\": `\"${last_modified}\"` };\n  }\n  return { \"If-None-Match\": \"*\" };\n}\n\n/**\n * @private\n */\nexport function createRequest(\n  path: string,\n  { data, permissions }: RequestBody,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe } = {\n    ...requestDefaults,\n    ...options,\n  };\n  const method = options.method || (data && data.id) ? \"PUT\" : \"POST\";\n  return {\n    method,\n    path,\n    headers: { ...headers, ...safeHeader(safe) },\n    body: { data, permissions },\n  };\n}\n\n/**\n * @private\n */\nexport function updateRequest(\n  path: string,\n  { data, permissions }: RecordRequestBody,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, patch } = { ...requestDefaults, ...options };\n  const { last_modified } = { ...data, ...options };\n\n  const hasNoData =\n    data &&\n    Object.keys(data).filter((k) => k !== \"id\" && k !== \"last_modified\")\n      .length === 0;\n  if (hasNoData) {\n    data = undefined;\n  }\n\n  return {\n    method: patch ? \"PATCH\" : \"PUT\",\n    path,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n    body: { data, permissions },\n  };\n}\n\n/**\n * @private\n */\nexport function jsonPatchPermissionsRequest(\n  path: string,\n  permissions: { [key in Permission]?: string[] },\n  opType: string,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, last_modified } = { ...requestDefaults, ...options };\n\n  const ops = [];\n\n  for (const [type, principals] of Object.entries(permissions)) {\n    if (principals) {\n      for (const principal of principals) {\n        ops.push({\n          op: opType,\n          path: `/permissions/${type}/${principal}`,\n        });\n      }\n    }\n  }\n\n  return {\n    method: \"PATCH\",\n    path,\n    headers: {\n      ...headers,\n      ...safeHeader(safe, last_modified),\n      \"Content-Type\": \"application/json-patch+json\",\n    },\n    body: ops,\n  };\n}\n\n/**\n * @private\n */\nexport function deleteRequest(\n  path: string,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, last_modified } = {\n    ...requestDefaults,\n    ...options,\n  };\n  if (safe && !last_modified) {\n    throw new Error(\"Safe concurrency check requires a last_modified value.\");\n  }\n  return {\n    method: \"DELETE\",\n    path,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n  };\n}\n\n/**\n * @private\n */\nexport function addAttachmentRequest(\n  path: string,\n  dataURI: string,\n  { data, permissions }: RecordRequestBody = {},\n  options: AddAttachmentRequestOptions = {}\n): KintoRequest {\n  const { headers, safe, gzipped } = { ...requestDefaults, ...options };\n  const { last_modified } = { ...data, ...options };\n\n  const body = { data, permissions };\n  const formData = createFormData(dataURI, body, options);\n\n  const customPath = `${path}${\n    gzipped !== null ? \"?gzipped=\" + (gzipped ? \"true\" : \"false\") : \"\"\n  }`;\n\n  return {\n    method: \"POST\",\n    path: customPath,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n    body: formData,\n  };\n}\n","import { KintoRequest } from \"./types\";\n\ninterface ConflictRecord {\n  last_modified: number;\n  id: string;\n}\n\ninterface ConflictResponse {\n  existing: ConflictRecord;\n}\n\ninterface ResponseBody {\n  data?: unknown;\n  details?: ConflictResponse;\n  code?: number;\n  errno?: number;\n  error?: string;\n  message?: string;\n  info?: string;\n}\n\ninterface ErrorResponse {\n  path: string;\n  sent: KintoRequest;\n  error: ResponseBody;\n}\n\nexport interface AggregateResponse {\n  errors: ErrorResponse[];\n  published: ResponseBody[];\n  conflicts: any[];\n  skipped: any[];\n}\n\nexport interface KintoBatchResponse {\n  status: number;\n  path: string;\n  body: ResponseBody;\n  headers: { [key: string]: string };\n}\n\n/**\n * Exports batch responses as a result object.\n *\n * @private\n * @param  {Array} responses The batch subrequest responses.\n * @param  {Array} requests  The initial issued requests.\n * @return {Object}\n */\nexport function aggregate(\n  responses: KintoBatchResponse[] = [],\n  requests: KintoRequest[] = []\n): AggregateResponse {\n  if (responses.length !== requests.length) {\n    throw new Error(\"Responses length should match requests one.\");\n  }\n  const results: AggregateResponse = {\n    errors: [],\n    published: [],\n    conflicts: [],\n    skipped: [],\n  };\n  return responses.reduce((acc, response, index) => {\n    const { status } = response;\n    const request = requests[index];\n    if (status >= 200 && status < 400) {\n      acc.published.push(response.body);\n    } else if (status === 404) {\n      // Extract the id manually from request path while waiting for Kinto/kinto#818\n      const regex = /(buckets|groups|collections|records)\\/([^/]+)$/;\n      const extracts = request.path.match(regex);\n      const id = extracts && extracts.length === 3 ? extracts[2] : undefined;\n      acc.skipped.push({\n        id,\n        path: request.path,\n        error: response.body,\n      });\n    } else if (status === 412) {\n      acc.conflicts.push({\n        // XXX: specifying the type is probably superfluous\n        type: \"outgoing\",\n        local: request.body,\n        remote:\n          (response.body.details && response.body.details.existing) || null,\n      });\n    } else {\n      acc.errors.push({\n        path: request.path,\n        sent: request,\n        error: response.body,\n      });\n    }\n    return acc;\n  }, results);\n}\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import { v4 as uuid } from \"uuid\";\n\nimport { capable, toDataBody, isObject } from \"./utils\";\nimport * as requests from \"./requests\";\nimport KintoClientBase, { PaginatedParams, PaginationResult } from \"./base\";\nimport Bucket from \"./bucket\";\nimport {\n  KintoRequest,\n  Permission,\n  KintoResponse,\n  KintoIdObject,\n  KintoObject,\n  Attachment,\n  OperationResponse,\n  MappableObject,\n} from \"./types\";\nimport { HttpResponse } from \"./http\";\nimport { AggregateResponse } from \"./batch\";\n\nexport interface CollectionOptions {\n  headers?: Record<string, string>;\n  safe?: boolean;\n  retry?: number;\n}\n\n/**\n * Abstract representation of a selected collection.\n *\n */\nexport default class Collection {\n  public client: KintoClientBase;\n  private bucket: Bucket;\n  public name: string;\n  private _endpoints: KintoClientBase[\"endpoints\"];\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n\n  /**\n   * Constructor.\n   *\n   * @param  {KintoClient}  client            The client instance.\n   * @param  {Bucket}       bucket            The bucket instance.\n   * @param  {String}       name              The collection name.\n   * @param  {Object}       [options={}]      The options object.\n   * @param  {Object}       [options.headers] The headers object option.\n   * @param  {Boolean}      [options.safe]    The safe option.\n   * @param  {Number}       [options.retry]   The retry option.\n   * @param  {Boolean}      [options.batch]   (Private) Whether this\n   *     Collection is operating as part of a batch.\n   */\n  constructor(\n    client: KintoClientBase,\n    bucket: Bucket,\n    name: string,\n    options: CollectionOptions = {}\n  ) {\n    /**\n     * @ignore\n     */\n    this.client = client;\n    /**\n     * @ignore\n     */\n    this.bucket = bucket;\n    /**\n     * The collection name.\n     * @type {String}\n     */\n    this.name = name;\n\n    this._endpoints = client.endpoints;\n\n    /**\n     * @ignore\n     */\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n    // FIXME: This is kind of ugly; shouldn't the bucket be responsible\n    // for doing the merge?\n    this._headers = {\n      ...this.bucket.headers,\n      ...options.headers,\n    };\n  }\n\n  get execute(): KintoClientBase[\"execute\"] {\n    return this.client.execute.bind(this.client);\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * @private\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Retrieves the total number of records in this collection.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Number, Error>}\n   */\n  async getTotalRecords(\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<number> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    });\n    return parseInt(headers.get(\"Total-Records\"), 10);\n  }\n\n  /**\n   * Retrieves the ETag of the records list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getRecordsTimestamp(\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = (await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves collection data.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getData<T>(\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<T> {\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = { headers: this._getHeaders(options), path };\n    const { data } = (await this.client.execute(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    })) as { data: T };\n    return data;\n  }\n\n  /**\n   * Set collection data.\n   * @param  {Object}   data                    The collection data object.\n   * @param  {Object}   [options={}]            The options object.\n   * @param  {Object}   [options.headers]       The headers object option.\n   * @param  {Number}   [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}  [options.safe]          The safe option.\n   * @param  {Boolean}  [options.patch]         The patch option.\n   * @param  {Number}   [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setData<T extends MappableObject>(\n    data: T & { last_modified?: number },\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      patch?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(data)) {\n      throw new Error(\"A collection object is required.\");\n    }\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Retrieves the list of permissions for this collection.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getPermissions(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<{ [key in Permission]?: string[] }> {\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = { headers: this._getHeaders(options), path };\n    const { permissions } = (await this.client.execute<KintoResponse>(request, {\n      retry: this._getRetry(options),\n    })) as KintoResponse;\n    return permissions;\n  }\n\n  /**\n   * Replaces all existing collection permissions with the ones provided.\n   *\n   * @param  {Object}   permissions             The permissions object.\n   * @param  {Object}   [options={}]            The options object\n   * @param  {Object}   [options.headers]       The headers object option.\n   * @param  {Number}   [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}  [options.safe]          The safe option.\n   * @param  {Number}   [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const data = { last_modified: options.last_modified };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Append principals to the collection permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async addPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"add\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Remove principals from the collection permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async removePermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"remove\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Creates a record in current collection.\n   *\n   * @param  {Object}  record                The record to create.\n   * @param  {Object}  [options={}]          The options object.\n   * @param  {Object}  [options.headers]     The headers object option.\n   * @param  {Number}  [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]        The safe option.\n   * @param  {Object}  [options.permissions] The permissions option.\n   * @return {Promise<Object, Error>}\n   */\n  async createRecord<T extends MappableObject>(\n    record: T & { id?: string },\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const { permissions } = options;\n    const path = this._endpoints.record(this.bucket.name, this.name, record.id);\n    const request = requests.createRequest(\n      path,\n      { data: record, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Adds an attachment to a record, creating the record when it doesn't exist.\n   *\n   * @param  {String}  dataURL                 The data url.\n   * @param  {Object}  [record={}]             The record data.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @param  {Object}  [options.permissions]   The permissions option.\n   * @param  {String}  [options.filename]      Force the attachment filename.\n   * @param  {String}  [options.gzipped]       Force the attachment to be gzipped or not.\n   * @return {Promise<Object, Error>}\n   */\n  @capable([\"attachments\"])\n  async addAttachment(\n    dataURI: string,\n    record: { [key: string]: string } = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n      filename?: string;\n      gzipped?: boolean;\n    } = {}\n  ): Promise<\n    KintoResponse<{\n      attachment: Attachment;\n    }>\n  > {\n    const { permissions } = options;\n    const id = record.id || uuid();\n    const path = this._endpoints.attachment(this.bucket.name, this.name, id);\n    const { last_modified } = { ...record, ...options };\n    const addAttachmentRequest = requests.addAttachmentRequest(\n      path,\n      dataURI,\n      { data: record, permissions },\n      {\n        last_modified,\n        filename: options.filename,\n        gzipped: options.gzipped,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    await this.client.execute(addAttachmentRequest, {\n      stringify: false,\n      retry: this._getRetry(options),\n    });\n    return this.getRecord<{ attachment: Attachment }>(id);\n  }\n\n  /**\n   * Removes an attachment from a given record.\n   *\n   * @param  {Object}  recordId                The record id.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   */\n  @capable([\"attachments\"])\n  async removeAttachment(\n    recordId: string,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<{}> {\n    const { last_modified } = options;\n    const path = this._endpoints.attachment(\n      this.bucket.name,\n      this.name,\n      recordId\n    );\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<{}>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<{}>;\n  }\n\n  /**\n   * Updates a record in current collection.\n   *\n   * @param  {Object}  record                  The record to update.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @param  {Object}  [options.permissions]   The permissions option.\n   * @return {Promise<Object, Error>}\n   */\n  async updateRecord<T>(\n    record: T & { id: string },\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n      patch?: boolean;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(record)) {\n      throw new Error(\"A record object is required.\");\n    }\n    if (!record.id) {\n      throw new Error(\"A record id is required.\");\n    }\n    const { permissions } = options;\n    const { last_modified } = { ...record, ...options };\n    const path = this._endpoints.record(this.bucket.name, this.name, record.id);\n    const request = requests.updateRequest(\n      path,\n      { data: record, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n        last_modified,\n        patch: !!options.patch,\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Deletes a record from the current collection.\n   *\n   * @param  {Object|String} record                  The record to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteRecord(\n    record: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const recordObj = toDataBody(record);\n    if (!recordObj.id) {\n      throw new Error(\"A record id is required.\");\n    }\n    const { id } = recordObj;\n    const { last_modified } = { ...recordObj, ...options };\n    const path = this._endpoints.record(this.bucket.name, this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes records from the current collection.\n   *\n   * Sorting is done by passing a `sort` string option:\n   *\n   * - The field to order the results by, prefixed with `-` for descending.\n   * Default: `-last_modified`.\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/sorting.html\n   *\n   * Filtering is done by passing a `filters` option object:\n   *\n   * - `{fieldname: \"value\"}`\n   * - `{min_fieldname: 4000}`\n   * - `{in_fieldname: \"1,2,3\"}`\n   * - `{not_fieldname: 0}`\n   * - `{exclude_fieldname: \"0,1\"}`\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/filtering.html\n   *\n   * @param  {Object}   [options={}]                    The options object.\n   * @param  {Object}   [options.headers]               The headers object option.\n   * @param  {Number}   [options.retry=0]               Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}   [options.filters={}]            The filters object.\n   * @param  {String}   [options.sort=\"-last_modified\"] The sort field.\n   * @param  {String}   [options.at]                    The timestamp to get a snapshot at.\n   * @param  {String}   [options.limit=null]            The limit field.\n   * @param  {String}   [options.pages=1]               The number of result pages to aggregate.\n   * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.\n   * @param  {Array}    [options.fields]                Limit response to just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteRecords<T extends KintoObject>(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    return this.client.paginatedDelete<T>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves a record from the current collection.\n   *\n   * @param  {String} id                The record id to retrieve.\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getRecord<T>(\n    id: string,\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name, id);\n    const request = { headers: this._getHeaders(options), path };\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Lists records from the current collection.\n   *\n   * Sorting is done by passing a `sort` string option:\n   *\n   * - The field to order the results by, prefixed with `-` for descending.\n   * Default: `-last_modified`.\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/sorting.html\n   *\n   * Filtering is done by passing a `filters` option object:\n   *\n   * - `{fieldname: \"value\"}`\n   * - `{min_fieldname: 4000}`\n   * - `{in_fieldname: \"1,2,3\"}`\n   * - `{not_fieldname: 0}`\n   * - `{exclude_fieldname: \"0,1\"}`\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/filtering.html\n   *\n   * Paginating is done by passing a `limit` option, then calling the `next()`\n   * method from the resolved result object to fetch the next page, if any.\n   *\n   * @param  {Object}   [options={}]                    The options object.\n   * @param  {Object}   [options.headers]               The headers object option.\n   * @param  {Number}   [options.retry=0]               Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}   [options.filters={}]            The filters object.\n   * @param  {String}   [options.sort=\"-last_modified\"] The sort field.\n   * @param  {String}   [options.at]                    The timestamp to get a snapshot at.\n   * @param  {String}   [options.limit=null]            The limit field.\n   * @param  {String}   [options.pages=1]               The number of result pages to aggregate.\n   * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.\n   * @param  {Array}    [options.fields]                Limit response to just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async listRecords<T extends KintoObject>(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n      at?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    if (options.at) {\n      return this.getSnapshot<T>(options.at);\n    } else {\n      return this.client.paginatedList<T>(path, options, {\n        headers: this._getHeaders(options),\n        retry: this._getRetry(options),\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  async isHistoryComplete(): Promise<boolean> {\n    // We consider that if we have the collection creation event part of the\n    // history, then all records change events have been tracked.\n    const {\n      data: [oldestHistoryEntry],\n    } = await this.bucket.listHistory({\n      limit: 1,\n      filters: {\n        action: \"create\",\n        resource_name: \"collection\",\n        collection_id: this.name,\n      },\n    });\n    return !!oldestHistoryEntry;\n  }\n\n  /**\n   * @private\n   */\n  @capable([\"history\"])\n  async getSnapshot<T extends KintoObject>(\n    at: number\n  ): Promise<PaginationResult<T>> {\n    if (!at || !Number.isInteger(at) || at <= 0) {\n      throw new Error(\"Invalid argument, expected a positive integer.\");\n    }\n    // Retrieve history and check it covers the required time range.\n    // Ensure we have enough history data to retrieve the complete list of\n    // changes.\n    if (!(await this.isHistoryComplete())) {\n      throw new Error(\n        \"Computing a snapshot is only possible when the full history for a \" +\n          \"collection is available. Here, the history plugin seems to have \" +\n          \"been enabled after the creation of the collection.\"\n      );\n    }\n\n    // Because of https://github.com/Kinto/kinto-http.js/issues/963\n    // we cannot simply rely on the history endpoint.\n    // Our strategy here is to clean-up the history entries from the\n    // records that were deleted via the plural endpoint.\n    // We will detect them by comparing the current state of the collection\n    // and the full history of the collection since its genesis.\n\n    // List full history of collection.\n    const { data: fullHistory } = await this.bucket.listHistory<T>({\n      pages: Infinity, // all pages up to target timestamp are required\n      sort: \"last_modified\", // chronological order\n      filters: {\n        resource_name: \"record\",\n        collection_id: this.name,\n      },\n    });\n\n    // Keep latest entry ever, and latest within snapshot window.\n    // (history is sorted chronologically)\n    const latestEver = new Map();\n    const latestInSnapshot = new Map();\n    for (const entry of fullHistory) {\n      if (entry.target.data.last_modified <= at) {\n        // Snapshot includes changes right on timestamp.\n        latestInSnapshot.set(entry.record_id, entry);\n      }\n      latestEver.set(entry.record_id, entry);\n    }\n\n    // Current records ids in the collection.\n    const { data: current } = await this.listRecords({\n      pages: Infinity,\n      fields: [\"id\"], // we don't need attributes.\n    });\n    const currentIds = new Set(current.map((record) => record.id));\n\n    // If a record is not in the current collection, and its\n    // latest history entry isn't a delete then this means that\n    // it was deleted via the plural endpoint (and that we lost track\n    // of this deletion because of bug #963)\n    const deletedViaPlural = new Set();\n    for (const entry of latestEver.values()) {\n      if (entry.action != \"delete\" && !currentIds.has(entry.record_id)) {\n        deletedViaPlural.add(entry.record_id);\n      }\n    }\n\n    // Now reconstruct the collection based on latest version in snapshot\n    // filtering all deleted records.\n    const reconstructed = [];\n    for (const entry of latestInSnapshot.values()) {\n      if (entry.action != \"delete\" && !deletedViaPlural.has(entry.record_id)) {\n        reconstructed.push(entry.target.data);\n      }\n    }\n\n    return {\n      last_modified: String(at),\n      data: Array.from(reconstructed).sort(\n        (a, b) => b.last_modified - a.last_modified\n      ),\n      next: () => {\n        throw new Error(\"Snapshots don't support pagination\");\n      },\n      hasNextPage: false,\n      totalRecords: reconstructed.length,\n    } as PaginationResult<T>;\n  }\n\n  /**\n   * Performs batch operations at the current collection level.\n   *\n   * @param  {Function} fn                   The batch operation function.\n   * @param  {Object}   [options={}]         The options object.\n   * @param  {Object}   [options.headers]    The headers object option.\n   * @param  {Boolean}  [options.safe]       The safe option.\n   * @param  {Number}   [options.retry]      The retry option.\n   * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.\n   * @return {Promise<Object, Error>}\n   */\n  async batch(\n    fn: (client: Collection) => void,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    return this.client.batch(fn, {\n      bucket: this.bucket.name,\n      collection: this.name,\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n      aggregate: !!options.aggregate,\n    });\n  }\n}\n","import { toDataBody, isObject, capable } from \"./utils\";\nimport Collection from \"./collection\";\nimport * as requests from \"./requests\";\nimport KintoClientBase, { PaginatedParams, PaginationResult } from \"./base\";\nimport {\n  KintoRequest,\n  KintoIdObject,\n  Permission,\n  KintoResponse,\n  HistoryEntry,\n  KintoObject,\n  Group,\n  OperationResponse,\n  MappableObject,\n} from \"./types\";\nimport { HttpResponse } from \"./http\";\nimport { AggregateResponse } from \"./batch\";\n\nexport interface BucketOptions {\n  safe?: boolean;\n  headers?: Record<string, string>;\n  retry?: number;\n}\n/**\n * Abstract representation of a selected bucket.\n *\n */\nexport default class Bucket {\n  private client: KintoClientBase;\n  public name: string;\n  private _endpoints: KintoClientBase[\"endpoints\"];\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n\n  /**\n   * Constructor.\n   *\n   * @param  {KintoClient} client            The client instance.\n   * @param  {String}      name              The bucket name.\n   * @param  {Object}      [options={}]      The headers object option.\n   * @param  {Object}      [options.headers] The headers object option.\n   * @param  {Boolean}     [options.safe]    The safe option.\n   * @param  {Number}      [options.retry]   The retry option.\n   */\n  constructor(\n    client: KintoClientBase,\n    name: string,\n    options: BucketOptions = {}\n  ) {\n    /**\n     * @ignore\n     */\n    this.client = client;\n    /**\n     * The bucket name.\n     * @type {String}\n     */\n    this.name = name;\n\n    this._endpoints = client.endpoints;\n\n    /**\n     * @ignore\n     */\n    this._headers = options.headers || {};\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n  }\n\n  get execute(): KintoClientBase[\"execute\"] {\n    return this.client.execute.bind(this.client);\n  }\n\n  get headers(): Record<string, string> {\n    return this._headers;\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * @private\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Selects a collection.\n   *\n   * @param  {String}  name              The collection name.\n   * @param  {Object}  [options={}]      The options object.\n   * @param  {Object}  [options.headers] The headers object option.\n   * @param  {Boolean} [options.safe]    The safe option.\n   * @return {Collection}\n   */\n  collection(\n    name: string,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n    } = {}\n  ): Collection {\n    return new Collection(this.client, this, name, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n    });\n  }\n\n  /**\n   * Retrieves the ETag of the collection list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getCollectionsTimestamp(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.collection(this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = (await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves the ETag of the group list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getGroupsTimestamp(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.group(this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = (await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves bucket data.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getData<T>(\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<T> {\n    const path = this._endpoints.bucket(this.name);\n    const request = {\n      headers: this._getHeaders(options),\n      path,\n    };\n    const { data } = (await this.client.execute(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    })) as { data: T };\n    return data;\n  }\n\n  /**\n   * Set bucket data.\n   * @param  {Object}  data                    The bucket data object.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers={}]    The headers object option.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.patch]         The patch option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setData<T extends MappableObject>(\n    data: T & { last_modified?: number },\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      patch?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(data)) {\n      throw new Error(\"A bucket object is required.\");\n    }\n\n    const bucket: T & { last_modified?: number; id?: string } = {\n      ...data,\n      id: this.name,\n    };\n\n    // For default bucket, we need to drop the id from the data object.\n    // Bug in Kinto < 3.1.1\n    const bucketId = bucket.id;\n    if (bucket.id === \"default\") {\n      delete bucket.id;\n    }\n\n    const path = this._endpoints.bucket(bucketId);\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n    const request = requests.updateRequest(\n      path,\n      { data: bucket, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Retrieves the list of history entries in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  @capable([\"history\"])\n  async listHistory<T>(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<HistoryEntry<T>>> {\n    const path = this._endpoints.history(this.name);\n    return this.client.paginatedList<HistoryEntry<T>>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of collections in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async listCollections(\n    options: PaginatedParams & {\n      filters?: Record<string, string | number>;\n      headers?: Record<string, string>;\n      retry?: number;\n      fields?: string[];\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.collection(this.name);\n    return this.client.paginatedList<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Creates a new collection in current bucket.\n   *\n   * @param  {String|undefined}  id          The collection id.\n   * @param  {Object}  [options={}]          The options object.\n   * @param  {Boolean} [options.safe]        The safe option.\n   * @param  {Object}  [options.headers]     The headers object option.\n   * @param  {Number}  [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.permissions] The permissions object.\n   * @param  {Object}  [options.data]        The data object.\n   * @return {Promise<Object, Error>}\n   */\n  async createCollection(\n    id?: string,\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      permissions?: { [key in Permission]?: string[] };\n      data?: any;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    const { permissions, data = {} } = options;\n    data.id = id;\n    const path = this._endpoints.collection(this.name, id);\n    const request = requests.createRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Deletes a collection from the current bucket.\n   *\n   * @param  {Object|String} collection              The collection to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteCollection(\n    collection: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const collectionObj = toDataBody(collection);\n    if (!collectionObj.id) {\n      throw new Error(\"A collection id is required.\");\n    }\n    const { id } = collectionObj;\n    const { last_modified } = { ...collectionObj, ...options };\n    const path = this._endpoints.collection(this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes collections from the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async deleteCollections(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.collection(this.name);\n    return this.client.paginatedDelete<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of groups in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async listGroups(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<Group>> {\n    const path = this._endpoints.group(this.name);\n    return this.client.paginatedList<Group>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Fetches a group in current bucket.\n   *\n   * @param  {String} id                The group id.\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async getGroup(\n    id: string,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      query?: { [key: string]: string };\n      fields?: string[];\n    } = {}\n  ): Promise<KintoResponse<Group>> {\n    const path = this._endpoints.group(this.name, id);\n    const request = {\n      headers: this._getHeaders(options),\n      path,\n    };\n    return this.client.execute<KintoResponse<Group>>(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    }) as Promise<KintoResponse<Group>>;\n  }\n\n  /**\n   * Creates a new group in current bucket.\n   *\n   * @param  {String|undefined}  id                    The group id.\n   * @param  {Array<String>}     [members=[]]          The list of principals.\n   * @param  {Object}            [options={}]          The options object.\n   * @param  {Object}            [options.data]        The data object.\n   * @param  {Object}            [options.permissions] The permissions object.\n   * @param  {Boolean}           [options.safe]        The safe option.\n   * @param  {Object}            [options.headers]     The headers object option.\n   * @param  {Number}            [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async createGroup(\n    id?: string,\n    members: string[] = [],\n    options: {\n      data?: any;\n      permissions?: { [key in Permission]?: string[] };\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<Group>> {\n    const data = {\n      ...options.data,\n      id,\n      members,\n    };\n    const path = this._endpoints.group(this.name, id);\n    const { permissions } = options;\n    const request = requests.createRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<Group>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<Group>>;\n  }\n\n  /**\n   * Updates an existing group in current bucket.\n   *\n   * @param  {Object}  group                   The group object.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.data]          The data object.\n   * @param  {Object}  [options.permissions]   The permissions object.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async updateGroup<T extends MappableObject>(\n    group: KintoIdObject,\n    options: {\n      data?: T & { members?: string[] };\n      permissions?: { [key in Permission]?: string[] };\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n      patch?: boolean;\n    } = {}\n  ): Promise<KintoResponse<T & { members: string[] }>> {\n    if (!isObject(group)) {\n      throw new Error(\"A group object is required.\");\n    }\n    if (!group.id) {\n      throw new Error(\"A group id is required.\");\n    }\n    const data = {\n      ...options.data,\n      ...group,\n    };\n    const path = this._endpoints.group(this.name, group.id);\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T & { members: string[] }>>(\n      request,\n      {\n        retry: this._getRetry(options),\n      }\n    ) as Promise<KintoResponse<T & { members: string[] }>>;\n  }\n\n  /**\n   * Deletes a group from the current bucket.\n   *\n   * @param  {Object|String} group                   The group to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteGroup(\n    group: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const groupObj = toDataBody(group);\n    const { id } = groupObj;\n    const { last_modified } = { ...groupObj, ...options };\n    const path = this._endpoints.group(this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes groups from the current bucket.\n   *\n   * @param  {Object} [options={}]          The options object.\n   * @param  {Object} [options.filters={}]  The filters object.\n   * @param  {Object} [options.headers]     The headers object option.\n   * @param  {Number} [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]      Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async deleteGroups(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.group(this.name);\n    return this.client.paginatedDelete<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of permissions for this bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getPermissions(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<{ [key in Permission]?: string[] }> {\n    const request = {\n      headers: this._getHeaders(options),\n      path: this._endpoints.bucket(this.name),\n    };\n    const { permissions } = (await this.client.execute<KintoResponse>(request, {\n      retry: this._getRetry(options),\n    })) as KintoResponse;\n    return permissions;\n  }\n\n  /**\n   * Replaces all existing bucket permissions with the ones provided.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers={}]    The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const data = { last_modified };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Append principals to the bucket permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async addPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"add\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Remove principals from the bucket permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async removePermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"remove\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Performs batch operations at the current bucket level.\n   *\n   * @param  {Function} fn                   The batch operation function.\n   * @param  {Object}   [options={}]         The options object.\n   * @param  {Object}   [options.headers]    The headers object option.\n   * @param  {Boolean}  [options.safe]       The safe option.\n   * @param  {Number}   [options.retry=0]    The retry option.\n   * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.\n   * @return {Promise<Object, Error>}\n   */\n  async batch(\n    fn: (client: Bucket) => void,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    return this.client.batch(fn, {\n      bucket: this.name,\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n      aggregate: !!options.aggregate,\n    });\n  }\n}\n","import KintoClientBase, { KintoClientOptions, SUPPORTED_PROTOCOL_VERSION } from \"./base\";\nimport { AggregateResponse } from \"./batch\";\nimport Collection from \"./collection\";\nimport { KintoObject, KintoIdObject, KintoResponse, Permission, PermissionData } from \"./types\";\n\nexport default class KintoClient extends KintoClientBase {\n  constructor(remote: string, options: Partial<KintoClientOptions> = {}) {\n    const events = options.events;\n\n    super(remote, Object.assign({ events }, options));\n  }\n}\n\nexport {\n  KintoObject,\n  KintoIdObject,\n  Collection,\n  AggregateResponse,\n  KintoResponse,\n  Permission,\n  PermissionData,\n  SUPPORTED_PROTOCOL_VERSION\n};\n","import {\n  partition,\n  qsify,\n  support,\n  nobatch,\n  toDataBody,\n  cleanUndefinedProperties,\n} from \"./utils\";\nimport HTTP, { HttpResponse } from \"./http\";\nimport endpoints from \"./endpoints\";\nimport * as requests from \"./requests\";\nimport { aggregate, AggregateResponse } from \"./batch\";\nimport Bucket from \"./bucket\";\nimport { addEndpointOptions, capable } from \"./utils\";\nimport {\n  HelloResponse,\n  KintoRequest,\n  BatchResponse,\n  OperationResponse,\n  DataResponse,\n  Permission,\n  KintoIdObject,\n  MappableObject,\n  KintoObject,\n  PermissionData,\n  KintoResponse,\n  ServerSettings,\n  ServerCapability,\n  User,\n  Emitter,\n  HttpMethod,\n  FetchFunction,\n} from \"./types\";\nimport Collection from \"./collection\";\n\n/**\n * Currently supported protocol version.\n * @type {String}\n */\nexport const SUPPORTED_PROTOCOL_VERSION = \"v1\";\n\nexport interface KintoClientOptions {\n  safe?: boolean;\n  events?: Emitter;\n  headers?: Record<string, string>;\n  retry?: number;\n  bucket?: string;\n  requestMode?: RequestMode;\n  timeout?: number;\n  batch?: boolean;\n  fetchFunc?: FetchFunction;\n}\n\nexport interface PaginatedParams {\n  sort?: string;\n  filters?: Record<string, string | number>;\n  limit?: number;\n  pages?: number;\n  since?: string;\n  fields?: string[];\n}\n\nexport interface PaginationResult<T> {\n  last_modified: string | null;\n  data: T[];\n  next: (nextPage?: string | null) => Promise<PaginationResult<T>>;\n  hasNextPage: boolean;\n  totalRecords: number;\n}\n\ntype BaseBatch = (client: KintoClientBase) => void;\ntype BucketBatch = (client: Bucket) => void;\ntype CollectionBatch = (client: Collection) => void;\n\n/**\n * High level HTTP client for the Kinto API.\n *\n * @example\n * const client = new KintoClient(\"https://kinto.dev.mozaws.net/v1\");\n * client.bucket(\"default\")\n *    .collection(\"my-blog\")\n *    .createRecord({title: \"First article\"})\n *   .then(console.log.bind(console))\n *   .catch(console.error.bind(console));\n */\nexport default class KintoClientBase {\n  private _backoffReleaseTime: number | null;\n  private _requests: KintoRequest[];\n  private _isBatch: boolean;\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n  public serverInfo: HelloResponse | null;\n  public events?: Emitter;\n  public http: HTTP;\n  public endpoints: typeof endpoints;\n  private _remote!: string;\n  private _version!: string;\n\n  /**\n   * Constructor.\n   *\n   * @param  {String}       remote  The remote URL.\n   * @param  {Object}       [options={}]                  The options object.\n   * @param  {Boolean}      [options.safe=true]           Adds concurrency headers to every requests.\n   * @param  {EventEmitter} [options.events=EventEmitter] The events handler instance.\n   * @param  {Object}       [options.headers={}]          The key-value headers to pass to each request.\n   * @param  {Object}       [options.retry=0]             Number of retries when request fails (default: 0)\n   * @param  {String}       [options.bucket=\"default\"]    The default bucket to use.\n   * @param  {String}       [options.requestMode=\"cors\"]  The HTTP request mode (from ES6 fetch spec).\n   * @param  {Number}       [options.timeout=null]        The request timeout in ms, if any.\n   * @param  {Function}     [options.fetchFunc=fetch]     The function to be used to execute HTTP requests.\n   */\n  constructor(remote: string, options: KintoClientOptions) {\n    if (typeof remote !== \"string\" || !remote.length) {\n      throw new Error(\"Invalid remote URL: \" + remote);\n    }\n    if (remote[remote.length - 1] === \"/\") {\n      remote = remote.slice(0, -1);\n    }\n    this._backoffReleaseTime = null;\n\n    this._requests = [];\n    this._isBatch = !!options.batch;\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n    this._headers = options.headers || {};\n\n    // public properties\n    /**\n     * The remote server base URL.\n     * @type {String}\n     */\n    this.remote = remote;\n    /**\n     * Current server information.\n     * @ignore\n     * @type {Object|null}\n     */\n    this.serverInfo = null;\n    /**\n     * The event emitter instance. Should comply with the `EventEmitter`\n     * interface.\n     * @ignore\n     * @type {Class}\n     */\n    this.events = options.events;\n\n    this.endpoints = endpoints;\n\n    const { fetchFunc, requestMode, timeout } = options;\n    /**\n     * The HTTP instance.\n     * @ignore\n     * @type {HTTP}\n     */\n    this.http = new HTTP(this.events, { fetchFunc, requestMode, timeout });\n    this._registerHTTPEvents();\n  }\n\n  /**\n   * The remote endpoint base URL. Setting the value will also extract and\n   * validate the version.\n   * @type {String}\n   */\n  get remote(): string {\n    return this._remote;\n  }\n\n  /**\n   * @ignore\n   */\n  set remote(url: string) {\n    let version;\n    try {\n      version = url.match(/\\/(v\\d+)\\/?$/)![1];\n    } catch (err) {\n      throw new Error(\"The remote URL must contain the version: \" + url);\n    }\n    if (version !== SUPPORTED_PROTOCOL_VERSION) {\n      throw new Error(`Unsupported protocol version: ${version}`);\n    }\n    this._remote = url;\n    this._version = version;\n  }\n\n  /**\n   * The current server protocol version, eg. `v1`.\n   * @type {String}\n   */\n  get version(): string {\n    return this._version;\n  }\n\n  /**\n   * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is\n   * ongoing.\n   *\n   * @type {Number}\n   */\n  get backoff(): number {\n    const currentTime = new Date().getTime();\n    if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {\n      return this._backoffReleaseTime - currentTime;\n    }\n    return 0;\n  }\n\n  /**\n   * Registers HTTP events.\n   * @private\n   */\n  private _registerHTTPEvents(): void {\n    // Prevent registering event from a batch client instance\n    if (!this._isBatch && this.events) {\n      this.events.on(\"backoff\", (backoffMs) => {\n        this._backoffReleaseTime = backoffMs;\n      });\n    }\n  }\n\n  /**\n   * Retrieve a bucket object to perform operations on it.\n   *\n   * @param  {String}  name              The bucket name.\n   * @param  {Object}  [options={}]      The request options.\n   * @param  {Boolean} [options.safe]    The resulting safe option.\n   * @param  {Number}  [options.retry]   The resulting retry option.\n   * @param  {Object}  [options.headers] The extended headers object option.\n   * @return {Bucket}\n   */\n  bucket(\n    name: string,\n    options: {\n      safe?: boolean;\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Bucket {\n    return new Bucket(this, name, {\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Set client \"headers\" for every request, updating previous headers (if any).\n   *\n   * @param {Object} headers The headers to merge with existing ones.\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this._headers = {\n      ...this._headers,\n      ...headers,\n    };\n    this.serverInfo = null;\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * Note that unlike other options, headers aren't overridden, but\n   * merged instead.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Object}\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Retrieves the server's \"hello\" endpoint. This endpoint reveals\n   * server capabilities and settings as well as telling the client\n   * \"who they are\" according to their given authorization headers.\n   *\n   * @private\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Object}  [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  private async _getHello(\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<HelloResponse> {\n    const path = this.remote + endpoints.root();\n    const { json } = await this.http.request<HelloResponse>(\n      path,\n      { headers: this._getHeaders(options) },\n      { retry: this._getRetry(options) }\n    );\n    return json;\n  }\n\n  /**\n   * Retrieves server information and persist them locally. This operation is\n   * usually performed a single time during the instance lifecycle.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async fetchServerInfo(\n    options: { retry?: number } = {}\n  ): Promise<HelloResponse> {\n    if (this.serverInfo) {\n      return this.serverInfo;\n    }\n    this.serverInfo = await this._getHello({ retry: this._getRetry(options) });\n    return this.serverInfo;\n  }\n\n  /**\n   * Retrieves Kinto server settings.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchServerSettings(\n    options: { retry?: number } = {}\n  ): Promise<ServerSettings> {\n    const { settings } = await this.fetchServerInfo(options);\n    return settings;\n  }\n\n  /**\n   * Retrieve server capabilities information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchServerCapabilities(\n    options: {\n      retry?: number;\n    } = {}\n  ): Promise<{ [key: string]: ServerCapability }> {\n    const { capabilities } = await this.fetchServerInfo(options);\n    return capabilities;\n  }\n\n  /**\n   * Retrieve authenticated user information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Object}  [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchUser(\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<User | undefined> {\n    const { user } = await this._getHello(options);\n    return user;\n  }\n\n  /**\n   * Retrieve authenticated user information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchHTTPApiVersion(\n    options: {\n      retry?: number;\n    } = {}\n  ): Promise<string> {\n    const { http_api_version } = await this.fetchServerInfo(options);\n    return http_api_version;\n  }\n\n  /**\n   * Process batch requests, chunking them according to the batch_max_requests\n   * server setting when needed.\n   *\n   * @param  {Array}  requests     The list of batch subrequests to perform.\n   * @param  {Object} [options={}] The options object.\n   * @return {Promise<Object, Error>}\n   */\n  private async _batchRequests(\n    requests: KintoRequest[],\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<OperationResponse[]> {\n    const headers = this._getHeaders(options);\n    if (!requests.length) {\n      return [];\n    }\n    const serverSettings = await this.fetchServerSettings({\n      retry: this._getRetry(options),\n    });\n    const maxRequests = serverSettings[\"batch_max_requests\"];\n    if (maxRequests && requests.length > maxRequests) {\n      const chunks = partition(requests, maxRequests);\n      const results = [];\n      for (const chunk of chunks) {\n        const result = await this._batchRequests(chunk, options);\n        results.push(...result);\n      }\n      return results;\n    }\n    const { responses } = (await this.execute<BatchResponse>(\n      {\n        // FIXME: is this really necessary, since it's also present in\n        // the \"defaults\"?\n        headers,\n        path: endpoints.batch(),\n        method: \"POST\",\n        body: {\n          defaults: { headers },\n          requests,\n        },\n      },\n      { retry: this._getRetry(options) }\n    )) as BatchResponse;\n    return responses;\n  }\n\n  /**\n   * Sends batch requests to the remote server.\n   *\n   * Note: Reserved for internal use only.\n   *\n   * @ignore\n   * @param  {Function} fn                        The function to use for describing batch ops.\n   * @param  {Object}   [options={}]              The options object.\n   * @param  {Boolean}  [options.safe]            The safe option.\n   * @param  {Number}   [options.retry]           The retry option.\n   * @param  {String}   [options.bucket]          The bucket name option.\n   * @param  {String}   [options.collection]      The collection name option.\n   * @param  {Object}   [options.headers]         The headers object option.\n   * @param  {Boolean}  [options.aggregate=false] Produces an aggregated result object.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"Can't use batch within a batch!\")\n  async batch(\n    fn: BaseBatch | BucketBatch | CollectionBatch,\n    options: {\n      safe?: boolean;\n      retry?: number;\n      bucket?: string;\n      collection?: string;\n      headers?: Record<string, string>;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    const rootBatch = new KintoClientBase(this.remote, {\n      events: this.events,\n      batch: true,\n      safe: this._getSafe(options),\n      retry: this._getRetry(options),\n    });\n    if (options.bucket && options.collection) {\n      (fn as CollectionBatch)(\n        rootBatch.bucket(options.bucket).collection(options.collection)\n      );\n    } else if (options.bucket) {\n      (fn as BucketBatch)(rootBatch.bucket(options.bucket));\n    } else {\n      (fn as BaseBatch)(rootBatch);\n    }\n    const responses = await this._batchRequests(rootBatch._requests, options);\n    if (options.aggregate) {\n      return aggregate(responses, rootBatch._requests);\n    } else {\n      return responses;\n    }\n  }\n\n  /**\n   * Executes an atomic HTTP request.\n   *\n   * @param  {Object}  request             The request object.\n   * @param  {String}  request.path        The path to fetch, relative\n   *     to the Kinto server root.\n   * @param  {String}  [request.method=\"GET\"] The method to use in the\n   *     request.\n   * @param  {Body}    [request.body]      The request body.\n   * @param  {Object}  [request.headers={}] The request headers.\n   * @param  {Object}  [options={}]        The options object.\n   * @param  {Boolean} [options.raw=false] If true, resolve with full response\n   * @param  {Boolean} [options.stringify=true] If true, serialize body data to\n   * @param  {Number}  [options.retry=0]   The number of times to\n   *     retry a request if the server responds with Retry-After.\n   * JSON.\n   * @return {Promise<Object, Error>}\n   */\n  async execute<T>(\n    request: KintoRequest,\n    options: {\n      raw?: boolean;\n      stringify?: boolean;\n      retry?: number;\n      query?: { [key: string]: string };\n      fields?: string[];\n    } = {}\n  ): Promise<T | HttpResponse<T>> {\n    const { raw = false, stringify = true } = options;\n    // If we're within a batch, add the request to the stack to send at once.\n    if (this._isBatch) {\n      this._requests.push(request);\n      // Resolve with a message in case people attempt at consuming the result\n      // from within a batch operation.\n      const msg = (\"This result is generated from within a batch \" +\n        \"operation and should not be consumed.\") as unknown as T;\n      return raw\n        ? ({ status: 0, json: msg, headers: new Headers() } as HttpResponse<T>)\n        : msg;\n    }\n    const uri = this.remote + addEndpointOptions(request.path, options);\n    const result = await this.http.request<T>(\n      uri,\n      cleanUndefinedProperties({\n        // Limit requests to only those parts that would be allowed in\n        // a batch request -- don't pass through other fancy fetch()\n        // options like integrity, redirect, mode because they will\n        // break on a batch request.  A batch request only allows\n        // headers, method, path (above), and body.\n        method: request.method,\n        headers: request.headers,\n        body: stringify ? JSON.stringify(request.body) : request.body,\n      }),\n      { retry: this._getRetry(options) }\n    );\n    return raw ? result : result.json;\n  }\n\n  /**\n   * Perform an operation with a given HTTP method on some pages from\n   * a paginated list, following the `next-page` header automatically\n   * until we have processed the requested number of pages. Return a\n   * response with a `.next()` method that can be called to perform\n   * the requested HTTP method on more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when doing operation on pages.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to operate on. Undefined means one page. Pass\n   *     Infinity to operate on everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start doing operation on pages.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   * @param  {String}  [options.method=\"GET\"]\n   *     The method to use in the request.\n   */\n  async paginatedOperation<T>(\n    path: string,\n    params: PaginatedParams = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      method?: HttpMethod;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    // FIXME: this is called even in batch requests, which doesn't\n    // make any sense (since all batch requests get a \"dummy\"\n    // response; see execute() above).\n    const { sort, filters, limit, pages, since, fields } = {\n      sort: \"-last_modified\",\n      ...params,\n    };\n    // Safety/Consistency check on ETag value.\n    if (since && typeof since !== \"string\") {\n      throw new Error(\n        `Invalid value for since (${since}), should be ETag value.`\n      );\n    }\n\n    const query: { [key: string]: any } = {\n      ...filters,\n      _sort: sort,\n      _limit: limit,\n      _since: since,\n    };\n    if (fields) {\n      query._fields = fields;\n    }\n    const querystring = qsify(query);\n    let results: T[] = [],\n      current = 0;\n\n    const next = async function (\n      nextPage: string | null\n    ): Promise<PaginationResult<T>> {\n      if (!nextPage) {\n        throw new Error(\"Pagination exhausted.\");\n      }\n\n      return processNextPage(nextPage);\n    };\n\n    const processNextPage = async (\n      nextPage: string\n    ): Promise<PaginationResult<T>> => {\n      const { headers } = options;\n      return handleResponse(await this.http.request(nextPage, { headers }));\n    };\n\n    const pageResults = (\n      results: T[],\n      nextPage: string | null,\n      etag: string | null\n    ): PaginationResult<T> => {\n      // ETag string is supposed to be opaque and stored «as-is».\n      // ETag header values are quoted (because of * and W/\"foo\").\n      return {\n        last_modified: etag ? etag.replace(/\"/g, \"\") : etag,\n        data: results,\n        next: next.bind(null, nextPage),\n        hasNextPage: !!nextPage,\n        totalRecords: -1,\n      };\n    };\n\n    const handleResponse = async function ({\n      headers = new Headers(),\n      json = {} as DataResponse<T[]>,\n    }: HttpResponse<DataResponse<T[]>>): Promise<PaginationResult<T>> {\n      const nextPage = headers.get(\"Next-Page\");\n      const etag = headers.get(\"ETag\");\n\n      if (!pages) {\n        return pageResults(json.data, nextPage, etag);\n      }\n      // Aggregate new results with previous ones\n      results = results.concat(json.data);\n      current += 1;\n      if (current >= pages || !nextPage) {\n        // Pagination exhausted\n        return pageResults(results, nextPage, etag);\n      }\n      // Follow next page\n      return processNextPage(nextPage);\n    };\n\n    return handleResponse(\n      (await this.execute(\n        // N.B.: This doesn't use _getHeaders, because all calls to\n        // `paginatedList` are assumed to come from calls that already\n        // have headers merged at e.g. the bucket or collection level.\n        {\n          headers: options.headers ? options.headers : {},\n          path: path + \"?\" + querystring,\n          method: options.method,\n        },\n        // N.B. This doesn't use _getRetry, because all calls to\n        // `paginatedList` are assumed to come from calls that already\n        // used `_getRetry` at e.g. the bucket or collection level.\n        { raw: true, retry: options.retry || 0 }\n      )) as HttpResponse<DataResponse<T[]>>\n    );\n  }\n\n  /**\n   * Fetch some pages from a paginated list, following the `next-page`\n   * header automatically until we have fetched the requested number\n   * of pages. Return a response with a `.next()` method that can be\n   * called to fetch more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when fetching.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to fetch. Undefined means one page. Pass\n   *     Infinity to fetch everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start fetching.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   */\n  async paginatedList<T>(\n    path: string,\n    params: PaginatedParams = {},\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<PaginationResult<T>> {\n    return this.paginatedOperation<T>(path, params, options);\n  }\n\n  /**\n   * Delete multiple objects, following the pagination if the number of\n   * objects exceeds the page limit until we have deleted the requested\n   * number of pages. Return a response with a `.next()` method that can\n   * be called to delete more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when deleting.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to delete. Undefined means one page. Pass\n   *     Infinity to delete everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start deleting.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   */\n  paginatedDelete<T>(\n    path: string,\n    params: PaginatedParams = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const { headers, safe, last_modified } = options;\n    const deleteRequest = requests.deleteRequest(path, {\n      headers,\n      safe: safe ? safe : false,\n      last_modified,\n    });\n    return this.paginatedOperation<T>(path, params, {\n      ...options,\n      headers: deleteRequest.headers as Record<string, string>,\n      method: \"DELETE\",\n    });\n  }\n\n  /**\n   * Lists all permissions.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object[], Error>}\n   */\n  @capable([\"permissions_endpoint\"])\n  async listPermissions(\n    options: PaginatedParams & {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<PaginationResult<PermissionData>> {\n    const path = endpoints.permissions();\n    // Ensure the default sort parameter is something that exists in permissions\n    // entries, as `last_modified` doesn't; here, we pick \"id\".\n    const paginationOptions = { sort: \"id\", ...options };\n    return this.paginatedList<PermissionData>(path, paginationOptions, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of buckets.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Array}  [options.fields]     Limit response to\n   *     just some fields.\n   * @return {Promise<Object[], Error>}\n   */\n  async listBuckets(\n    options: PaginatedParams & {\n      retry?: number;\n      headers?: Record<string, string>;\n      filters?: Record<string, string | number>;\n      fields?: string[];\n      since?: string;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = endpoints.bucket();\n    return this.paginatedList<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Creates a new bucket on the server.\n   *\n   * @param  {String|null}  id                The bucket name (optional).\n   * @param  {Object}       [options={}]      The options object.\n   * @param  {Boolean}      [options.data]    The bucket data option.\n   * @param  {Boolean}      [options.safe]    The safe option.\n   * @param  {Object}       [options.headers] The headers object option.\n   * @param  {Number}       [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async createBucket<T extends MappableObject>(\n    id: string | null,\n    options: {\n      data?: T & { id?: string };\n      permissions?: Partial<Record<Permission, string[]>>;\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const { data, permissions } = options;\n    const _data = { ...data, id: id ? id : undefined };\n    const path = _data.id ? endpoints.bucket(_data.id) : endpoints.bucket();\n    return this.execute<KintoResponse<T>>(\n      requests.createRequest(\n        path,\n        { data: _data, permissions },\n        {\n          headers: this._getHeaders(options),\n          safe: this._getSafe(options),\n        }\n      ),\n      { retry: this._getRetry(options) }\n    ) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Deletes a bucket from the server.\n   *\n   * @ignore\n   * @param  {Object|String} bucket                  The bucket to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteBucket(\n    bucket: string | KintoIdObject,\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const bucketObj = toDataBody(bucket);\n    if (!bucketObj.id) {\n      throw new Error(\"A bucket id is required.\");\n    }\n    const path = endpoints.bucket(bucketObj.id);\n    const { last_modified } = { ...bucketObj, ...options };\n    return this.execute<KintoResponse<{ deleted: boolean }>>(\n      requests.deleteRequest(path, {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }),\n      { retry: this._getRetry(options) }\n    ) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes buckets.\n   *\n   * @param  {Object} [options={}]             The options object.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object} [options.headers={}]     Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]        Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.filters={}]     The filters object.\n   * @param  {Array}  [options.fields]         Limit response to\n   *     just some fields.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object[], Error>}\n   */\n  @support(\"1.4\", \"2.0\")\n  async deleteBuckets(\n    options: PaginatedParams & {\n      safe?: boolean;\n      retry?: number;\n      headers?: Record<string, string>;\n      last_modified?: number;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = endpoints.bucket();\n    return this.paginatedDelete<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: options.safe,\n      last_modified: options.last_modified,\n    });\n  }\n\n  @capable([\"accounts\"])\n  async createAccount(\n    username: string,\n    password: string\n  ): Promise<KintoResponse<{ password: string }>> {\n    return this.execute<KintoResponse<{ password: string }>>(\n      requests.createRequest(\n        `/accounts/${username}`,\n        { data: { password } },\n        { method: \"PUT\" }\n      )\n    ) as Promise<KintoResponse<{ password: string }>>;\n  }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","pop","push","__values","o","m","__read","ar","error","toDataBody","resource","isObject","id","Error","qsify","obj","encode","encodeURIComponent","stripped","cleanUndefinedProperties","keys","map","k","ks","isArray","join","checkVersion","version","minVersion","maxVersion","extract","str","split","x","parseInt","_a","verMajor","verMinor","_b","minMajor","minMinor","_c","maxMajor","maxMinor","some","capable","capabilities","descriptor","fn","configurable","get","wrappedMethod","_i","args","client","_this","fetchServerCapabilities","available","missing","filter","missingStr","writable","nobatch","message","_isBatch","thing","extractFileInfo","dataURL","match","substr","props","base64","type","params","reduce","acc","param","parseDataURL","name","binary","atob","array","charCodeAt","blob","Blob","Uint8Array","obscureAuthorizationHeader","headers","h","Headers","has","set","obscuredHeaders","entries","_d","header","getRandomValues","ERROR_CODES","104","105","106","107","108","109","110","111","112","113","114","115","116","117","121","122","201","202","999","url","options","_super","JSON","stringify","captureStackTrace","NetworkTimeoutError","response","status","UnparseableResponseError","stack","json","errnoMsg","statusText","errno","trim","ServerResponse","data","events","requestMode","HTTP","defaultOptions","timeout","fetchFunc","globalThis","fetch","bind","Accept","Content-Type","hasTimedout","_timeoutId","proceedWithHandler","arg","clearTimeout","setTimeout","catch","text","parse","err","retryAfter","request","ms","retry","DEFAULT_REQUEST_HEADERS","FormData","delete","mode","timedFetch","_checkForDeprecationHeader","_checkForBackoffHeader","_checkForRetryAfterHeader","processResponse","alertHeader","alert","console","warn","emit","backoffMs","backoffHeader","backoffSeconds","Date","getTime","delay","tryAgainAfter","ENDPOINTS","root","batch","permissions","bucket","history","collection","coll","group","record","attachment","requestDefaults","safe","patch","safeHeader","last_modified","If-Match","If-None-Match","createRequest","path","method","updateRequest","undefined","jsonPatchPermissionsRequest","opType","_f","principals","principals_1","principal","deleteRequest","addAttachmentRequest","dataURI","gzipped","formData","filename","property","append","createFormData","aggregate","responses","requests","index","published","extracts","skipped","conflicts","local","remote","details","existing","errors","rnds8","rng","crypto","msCrypto","validate","uuid","REGEX","test","byteToHex","toString","v4","buf","offset","rnds","random","arr","toLowerCase","_endpoints","endpoints","_retry","_safe","_headers","Collection","execute","_getHeaders","raw","_getRetry","query","fields","requests.updateRequest","_getSafe","requests.jsonPatchPermissionsRequest","requests.createRequest","requests.addAttachmentRequest","getRecord","recordId","requests.deleteRequest","recordObj","paginatedDelete","at","getSnapshot","paginatedList","listHistory","limit","filters","action","resource_name","collection_id","Number","isInteger","isHistoryComplete","_h","pages","Infinity","sort","fullHistory","latestEver","Map","latestInSnapshot","fullHistory_1","entry","record_id","listRecords","current","currentIds","Set","deletedViaPlural","values","add","reconstructed","from","a","hasNextPage","totalRecords","Bucket","bucketId","collectionObj","members","groupObj","slice","_backoffReleaseTime","_requests","serverInfo","http","_registerHTTPEvents","min","max","KintoClientBase","_remote","_version","currentTime","on","_getHello","fetchServerInfo","fetchServerSettings","serverSettings","maxRequests","chunks","results","chunks_1","chunk","_batchRequests","to","pack","l","concat","defaults","rootBatch","msg","uri","_fields","queryString","addEndpointOptions","since","_sort","_limit","_since","querystring","nextPage","processNextPage","handleResponse","pageResults","etag","replace","paginatedOperation","paginationOptions","_data","bucketObj","username","password","fetchHTTPApiVersion"],"mappings":"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"}