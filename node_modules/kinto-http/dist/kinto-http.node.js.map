{"version":3,"file":"kinto-http.node.js","sources":["../blob.js","../src/utils.ts","../src/errors.ts","../src/http.ts","../src/endpoints.ts","../src/requests.ts","../src/batch.ts","../src/collection.ts","../src/bucket.ts","../src/base.ts","../src/index.ts"],"sourcesContent":["export default function Blob(dataArray) {\n  return Buffer.from(dataArray[0]);\n}\n","/**\n * Chunks an array into n pieces.\n *\n * @private\n * @param  {Array}  array\n * @param  {Number} n\n * @return {Array}\n */\nexport function partition<T>(array: T[], n: number): T[][] {\n  if (n <= 0) {\n    return [array];\n  }\n  return array.reduce<T[][]>((acc, x, i) => {\n    if (i === 0 || i % n === 0) {\n      acc.push([x]);\n    } else {\n      acc[acc.length - 1].push(x);\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * Returns a Promise always resolving after the specified amount in milliseconds.\n *\n * @return Promise<void>\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ninterface Entity {\n  id: string;\n}\n\n/**\n * Always returns a resource data object from the provided argument.\n *\n * @private\n * @param  {Object|String} resource\n * @return {Object}\n */\nexport function toDataBody<T extends Entity>(resource: T | string): Entity {\n  if (isObject(resource)) {\n    return resource as T;\n  }\n  if (typeof resource === \"string\") {\n    return { id: resource };\n  }\n  throw new Error(\"Invalid argument.\");\n}\n\n/**\n * Transforms an object into an URL query string, stripping out any undefined\n * values.\n *\n * @param  {Object} obj\n * @return {String}\n */\nexport function qsify(obj: { [key: string]: any }): string {\n  const encode = (v: any): string =>\n    encodeURIComponent(typeof v === \"boolean\" ? String(v) : v);\n  const stripped = cleanUndefinedProperties(obj);\n  return Object.keys(stripped)\n    .map((k) => {\n      const ks = encode(k) + \"=\";\n      if (Array.isArray(stripped[k])) {\n        return ks + stripped[k].map((v: any) => encode(v)).join(\",\");\n      } else {\n        return ks + encode(stripped[k]);\n      }\n    })\n    .join(\"&\");\n}\n\n/**\n * Checks if a version is within the provided range.\n *\n * @param  {String} version    The version to check.\n * @param  {String} minVersion The minimum supported version (inclusive).\n * @param  {String} maxVersion The minimum supported version (exclusive).\n * @throws {Error} If the version is outside of the provided range.\n */\nexport function checkVersion(\n  version: string,\n  minVersion: string,\n  maxVersion: string\n): void {\n  const extract = (str: string): number[] =>\n    str.split(\".\").map((x) => parseInt(x, 10));\n  const [verMajor, verMinor] = extract(version);\n  const [minMajor, minMinor] = extract(minVersion);\n  const [maxMajor, maxMinor] = extract(maxVersion);\n  const checks = [\n    verMajor < minMajor,\n    verMajor === minMajor && verMinor < minMinor,\n    verMajor > maxMajor,\n    verMajor === maxMajor && verMinor >= maxMinor,\n  ];\n  if (checks.some((x) => x)) {\n    throw new Error(\n      `Version ${version} doesn't satisfy ${minVersion} <= x < ${maxVersion}`\n    );\n  }\n}\n\ntype DecoratorReturn = (\n  target: any,\n  key: string,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n) => {\n  configurable: boolean;\n  get(): (...args: any) => Promise<any>;\n};\n\n/**\n * Generates a decorator function ensuring a version check is performed against\n * the provided requirements before executing it.\n *\n * @param  {String} min The required min version (inclusive).\n * @param  {String} max The required max version (inclusive).\n * @return {Function}\n */\nexport function support(min: string, max: string): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): Promise<any> => {\n          // \"this\" is the current instance which its method is decorated.\n          const client = (this as any).client ? (this as any).client : this;\n          return client\n            .fetchHTTPApiVersion()\n            .then((version: string) => checkVersion(version, min, max))\n            .then(() => fn!.apply(this, args));\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Generates a decorator function ensuring that the specified capabilities are\n * available on the server before executing it.\n *\n * @param  {Array<String>} capabilities The required capabilities.\n * @return {Function}\n */\nexport function capable(capabilities: string[]): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): Promise<any> => {\n          // \"this\" is the current instance which its method is decorated.\n          const client = (this as any).client ? (this as any).client : this;\n          return client\n            .fetchServerCapabilities()\n            .then((available: string[]) => {\n              const missing = capabilities.filter((c) => !(c in available));\n              if (missing.length > 0) {\n                const missingStr = missing.join(\", \");\n                throw new Error(\n                  `Required capabilities ${missingStr} not present on server`\n                );\n              }\n            })\n            .then(() => fn!.apply(this, args));\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Generates a decorator function ensuring an operation is not performed from\n * within a batch request.\n *\n * @param  {String} message The error message to throw.\n * @return {Function}\n */\nexport function nobatch(message: string): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): any => {\n          // \"this\" is the current instance which its method is decorated.\n          if ((this as any)._isBatch) {\n            throw new Error(message);\n          }\n          return fn!.apply(this, args);\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Returns true if the specified value is an object (i.e. not an array nor null).\n * @param  {Object} thing The value to inspect.\n * @return {bool}\n */\nexport function isObject(thing: unknown): boolean {\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n\ninterface TypedDataURL {\n  type: string;\n  base64: string;\n  [key: string]: string;\n}\n\n/**\n * Parses a data url.\n * @param  {String} dataURL The data url.\n * @return {Object}\n */\nexport function parseDataURL(dataURL: string): TypedDataURL {\n  const regex = /^data:(.*);base64,(.*)/;\n  const match = dataURL.match(regex);\n  if (!match) {\n    throw new Error(`Invalid data-url: ${String(dataURL).substr(0, 32)}...`);\n  }\n  const props = match[1];\n  const base64 = match[2];\n  const [type, ...rawParams] = props.split(\";\");\n  const params = rawParams.reduce<{ [key: string]: string }>((acc, param) => {\n    const [key, value] = param.split(\"=\");\n    return { ...acc, [key]: value };\n  }, {});\n  return { ...params, type, base64 };\n}\n\n/**\n * Extracts file information from a data url.\n * @param  {String} dataURL The data url.\n * @return {Object}\n */\nexport function extractFileInfo(dataURL: string): {\n  blob: Blob;\n  name: string;\n} {\n  const { name, type, base64 } = parseDataURL(dataURL);\n  const binary = atob(base64);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  const blob = new Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n\n/**\n * Creates a FormData instance from a data url and an existing JSON response\n * body.\n * @param  {String} dataURL            The data url.\n * @param  {Object} body               The response body.\n * @param  {Object} [options={}]       The options object.\n * @param  {Object} [options.filename] Force attachment file name.\n * @return {FormData}\n */\nexport function createFormData(\n  dataURL: string,\n  body: { [key: string]: any },\n  options: { filename?: string } = {}\n): FormData {\n  const { filename = \"untitled\" } = options;\n  const { blob, name } = extractFileInfo(dataURL);\n  const formData = new FormData();\n  formData.append(\"attachment\", blob, name || filename);\n  for (const property in body) {\n    if (typeof body[property] !== \"undefined\") {\n      formData.append(property, JSON.stringify(body[property]));\n    }\n  }\n  return formData;\n}\n\n/**\n * Clones an object with all its undefined keys removed.\n * @private\n */\nexport function cleanUndefinedProperties(obj: { [key: string]: any }): {\n  [key: string]: any;\n} {\n  const result: { [key: string]: any } = {};\n  for (const key in obj) {\n    if (typeof obj[key] !== \"undefined\") {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Handle common query parameters for Kinto requests.\n *\n * @param  {String}  [path]  The endpoint base path.\n * @param  {Array}   [options.fields]    Fields to limit the\n *   request to.\n * @param  {Object}  [options.query={}]  Additional query arguments.\n */\nexport function addEndpointOptions(\n  path: string,\n  options: { fields?: string[]; query?: { [key: string]: string } } = {}\n): string {\n  const query: { [key: string]: any } = { ...options.query };\n  if (options.fields) {\n    query._fields = options.fields;\n  }\n  const queryString = qsify(query);\n  if (queryString) {\n    return path + \"?\" + queryString;\n  }\n  return path;\n}\n\n/**\n * Replace authorization header with an obscured version\n */\nexport function obscureAuthorizationHeader(headers: HeadersInit): {\n  [key: string]: string;\n} {\n  const h = new Headers(headers);\n  if (h.has(\"authorization\")) {\n    h.set(\"authorization\", \"**** (suppressed)\");\n  }\n\n  const obscuredHeaders: { [key: string]: string } = {};\n  for (const [header, value] of h.entries()) {\n    obscuredHeaders[header] = value;\n  }\n\n  return obscuredHeaders;\n}\n","import { FetchResponse } from \"./types\";\n\n/**\n * Kinto server error code descriptors.\n */\nconst ERROR_CODES = {\n  104: \"Missing Authorization Token\",\n  105: \"Invalid Authorization Token\",\n  106: \"Request body was not valid JSON\",\n  107: \"Invalid request parameter\",\n  108: \"Missing request parameter\",\n  109: \"Invalid posted data\",\n  110: \"Invalid Token / id\",\n  111: \"Missing Token / id\",\n  112: \"Content-Length header was not provided\",\n  113: \"Request body too large\",\n  114: \"Resource was created, updated or deleted meanwhile\",\n  115: \"Method not allowed on this end point (hint: server may be readonly)\",\n  116: \"Requested version not available on this server\",\n  117: \"Client has sent too many requests\",\n  121: \"Resource access is forbidden for this user\",\n  122: \"Another resource violates constraint\",\n  201: \"Service Temporary unavailable due to high load\",\n  202: \"Service deprecated\",\n  999: \"Internal Server Error\",\n};\n\nexport default ERROR_CODES;\n\nclass NetworkTimeoutError extends Error {\n  public url: string;\n  public options: Object;\n\n  constructor(url: string, options: Object) {\n    super(\n      `Timeout while trying to access ${url} with ${JSON.stringify(options)}`\n    );\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkTimeoutError);\n    }\n\n    this.url = url;\n    this.options = options;\n  }\n}\n\nclass UnparseableResponseError extends Error {\n  public status: number;\n  public response: FetchResponse;\n  public stack?: string;\n  public error: Error;\n\n  constructor(response: FetchResponse, body: string, error: Error) {\n    const { status } = response;\n\n    super(\n      `Response from server unparseable (HTTP ${\n        status || 0\n      }; ${error}): ${body}`\n    );\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnparseableResponseError);\n    }\n\n    this.status = status;\n    this.response = response;\n    this.stack = error.stack;\n    this.error = error;\n  }\n}\n\nexport interface ServerResponseObject {\n  code: number;\n  errno: keyof typeof ERROR_CODES;\n  error: string;\n  message: string;\n  info: string;\n  details: unknown;\n}\n\n/**\n * \"Error\" subclass representing a >=400 response from the server.\n *\n * Whether or not this is an error depends on your application.\n *\n * The `json` field can be undefined if the server responded with an\n * empty response body. This shouldn't generally happen. Most \"bad\"\n * responses come with a JSON error description, or (if they're\n * fronted by a CDN or nginx or something) occasionally non-JSON\n * responses (which become UnparseableResponseErrors, above).\n */\nclass ServerResponse extends Error {\n  public response: FetchResponse;\n  public data?: ServerResponseObject;\n\n  constructor(response: FetchResponse, json?: ServerResponseObject) {\n    const { status } = response;\n    let { statusText } = response;\n    let errnoMsg;\n\n    if (json) {\n      // Try to fill in information from the JSON error.\n      statusText = json.error || statusText;\n\n      // Take errnoMsg from either ERROR_CODES or json.message.\n      if (json.errno && json.errno in ERROR_CODES) {\n        errnoMsg = ERROR_CODES[json.errno];\n      } else if (json.message) {\n        errnoMsg = json.message;\n      }\n\n      // If we had both ERROR_CODES and json.message, and they differ,\n      // combine them.\n      if (errnoMsg && json.message && json.message !== errnoMsg) {\n        errnoMsg += ` (${json.message})`;\n      }\n    }\n\n    let message = `HTTP ${status} ${statusText}`;\n    if (errnoMsg) {\n      message += `: ${errnoMsg}`;\n    }\n\n    super(message.trim());\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServerResponse);\n    }\n\n    this.response = response;\n    this.data = json;\n  }\n}\n\nexport { NetworkTimeoutError, ServerResponse, UnparseableResponseError };\n","import { delay, obscureAuthorizationHeader } from \"./utils\";\nimport {\n  NetworkTimeoutError,\n  ServerResponse,\n  UnparseableResponseError,\n  ServerResponseObject,\n} from \"./errors\";\nimport { Emitter, FetchFunction, FetchHeaders, FetchResponse } from \"./types\";\n\ninterface HttpOptions {\n  timeout?: number | null;\n  requestMode?: RequestMode;\n  fetchFunc?: FetchFunction;\n}\n\ninterface RequestOptions {\n  retry: number;\n}\n\nexport interface HttpResponse<T> {\n  status: number;\n  json: T;\n  headers: FetchHeaders;\n}\n\n/**\n * Enhanced HTTP client for the Kinto protocol.\n * @private\n */\nexport default class HTTP {\n  /**\n   * Default HTTP request headers applied to each outgoing request.\n   *\n   * @type {Object}\n   */\n  static get DEFAULT_REQUEST_HEADERS(): Record<string, string> {\n    return {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    };\n  }\n\n  /**\n   * Default options.\n   *\n   * @type {Object}\n   */\n  static get defaultOptions(): HttpOptions {\n    return { timeout: null, requestMode: \"cors\" };\n  }\n\n  public events?: Emitter;\n  public requestMode: RequestMode;\n  public timeout: number;\n  public fetchFunc: FetchFunction;\n\n  /**\n   * Constructor.\n   *\n   * @param {EventEmitter} events                       The event handler.\n   * @param {Object}       [options={}}                 The options object.\n   * @param {Number}       [options.timeout=null]       The request timeout in ms, if any (default: `null`).\n   * @param {String}       [options.requestMode=\"cors\"] The HTTP request mode (default: `\"cors\"`).\n   */\n  constructor(events?: Emitter, options: HttpOptions = {}) {\n    // public properties\n    /**\n     * The event emitter instance.\n     * @type {EventEmitter}\n     */\n    this.events = events;\n\n    /**\n     * The request mode.\n     * @see  https://fetch.spec.whatwg.org/#requestmode\n     * @type {String}\n     */\n    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode!;\n\n    /**\n     * The request timeout.\n     * @type {Number}\n     */\n    this.timeout = options.timeout || HTTP.defaultOptions.timeout!;\n\n    /**\n     * The fetch() function.\n     * @type {Function}\n     */\n    this.fetchFunc = options.fetchFunc || globalThis.fetch.bind(globalThis);\n  }\n\n  /**\n   * @private\n   */\n  timedFetch(url: string, options: RequestInit): Promise<FetchResponse> {\n    let hasTimedout = false;\n    return new Promise((resolve, reject) => {\n      // Detect if a request has timed out.\n      let _timeoutId: ReturnType<typeof setTimeout>;\n      if (this.timeout) {\n        _timeoutId = setTimeout(() => {\n          hasTimedout = true;\n          if (options && options.headers) {\n            options = {\n              ...options,\n              headers: obscureAuthorizationHeader(options.headers),\n            };\n          }\n          reject(new NetworkTimeoutError(url, options));\n        }, this.timeout);\n      }\n      function proceedWithHandler(fn: (arg: any) => void): (arg: any) => void {\n        return (arg: any) => {\n          if (!hasTimedout) {\n            if (_timeoutId) {\n              clearTimeout(_timeoutId);\n            }\n            fn(arg);\n          }\n        };\n      }\n      this.fetchFunc(url, options)\n        .then(proceedWithHandler(resolve))\n        .catch(proceedWithHandler(reject));\n    });\n  }\n\n  /**\n   * @private\n   */\n  async processResponse<T>(response: FetchResponse): Promise<HttpResponse<T>> {\n    const { status, headers } = response;\n    const text = await response.text();\n    // Check if we have a body; if so parse it as JSON.\n    let json: unknown;\n    if (text.length !== 0) {\n      try {\n        json = JSON.parse(text);\n      } catch (err) {\n        throw new UnparseableResponseError(response, text, err);\n      }\n    }\n    if (status >= 400) {\n      throw new ServerResponse(response, json as ServerResponseObject);\n    }\n    return { status, json: json as T, headers };\n  }\n\n  /**\n   * @private\n   */\n  async retry<T>(\n    url: string,\n    retryAfter: number,\n    request: RequestInit,\n    options: RequestOptions\n  ): Promise<HttpResponse<T>> {\n    await delay(retryAfter);\n    return this.request<T>(url, request, {\n      ...options,\n      retry: options.retry - 1,\n    });\n  }\n\n  /**\n   * Performs an HTTP request to the Kinto server.\n   *\n   * Resolves with an objet containing the following HTTP response properties:\n   * - `{Number}  status`  The HTTP status code.\n   * - `{Object}  json`    The JSON response body.\n   * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.\n   *\n   * @param  {String} url               The URL.\n   * @param  {Object} [request={}]      The request object, passed to\n   *     fetch() as its options object.\n   * @param  {Object} [request.headers] The request headers object (default: {})\n   * @param  {Object} [options={}]      Options for making the\n   *     request\n   * @param  {Number} [options.retry]   Number of retries (default: 0)\n   * @return {Promise}\n   */\n  async request<T>(\n    url: string,\n    request: RequestInit = { headers: {} },\n    options: RequestOptions = { retry: 0 }\n  ): Promise<HttpResponse<T>> {\n    // Ensure default request headers are always set\n    request.headers = { ...HTTP.DEFAULT_REQUEST_HEADERS, ...request.headers };\n    // If a multipart body is provided, remove any custom Content-Type header as\n    // the fetch() implementation will add the correct one for us.\n    if (request.body && request.body instanceof FormData) {\n      if (request.headers instanceof Headers) {\n        request.headers.delete(\"Content-Type\");\n      } else if (!Array.isArray(request.headers)) {\n        delete request.headers[\"Content-Type\"];\n      }\n    }\n    request.mode = this.requestMode;\n\n    const response = await this.timedFetch(url, request);\n    const { headers } = response;\n\n    this._checkForDeprecationHeader(headers);\n    this._checkForBackoffHeader(headers);\n\n    // Check if the server summons the client to retry after a while.\n    const retryAfter = this._checkForRetryAfterHeader(headers);\n    // If number of allowed of retries is not exhausted, retry the same request.\n    if (retryAfter && options.retry > 0) {\n      return this.retry<T>(url, retryAfter, request, options);\n    } else {\n      return this.processResponse<T>(response);\n    }\n  }\n\n  _checkForDeprecationHeader(headers: FetchHeaders): void {\n    const alertHeader = headers.get(\"Alert\");\n    if (!alertHeader) {\n      return;\n    }\n    let alert;\n    try {\n      alert = JSON.parse(alertHeader);\n    } catch (err) {\n      console.warn(\"Unable to parse Alert header message\", alertHeader);\n      return;\n    }\n    console.warn(alert.message, alert.url);\n    if (this.events) {\n      this.events.emit(\"deprecated\", alert);\n    }\n  }\n\n  _checkForBackoffHeader(headers: FetchHeaders): void {\n    let backoffMs;\n    const backoffHeader = headers.get(\"Backoff\");\n    const backoffSeconds = backoffHeader ? parseInt(backoffHeader, 10) : 0;\n    if (backoffSeconds > 0) {\n      backoffMs = new Date().getTime() + backoffSeconds * 1000;\n    } else {\n      backoffMs = 0;\n    }\n    if (this.events) {\n      this.events.emit(\"backoff\", backoffMs);\n    }\n  }\n\n  _checkForRetryAfterHeader(headers: FetchHeaders): number | undefined {\n    const retryAfter = headers.get(\"Retry-After\");\n    if (!retryAfter) {\n      return;\n    }\n    const delay = parseInt(retryAfter, 10) * 1000;\n    const tryAgainAfter = new Date().getTime() + delay;\n    if (this.events) {\n      this.events.emit(\"retry-after\", tryAgainAfter);\n    }\n    return delay;\n  }\n}\n","/**\n * Endpoints templates.\n * @type {Object}\n */\nconst ENDPOINTS = {\n  root: () => \"/\",\n  batch: () => \"/batch\",\n  permissions: () => \"/permissions\",\n  bucket: (bucket?: string) => \"/buckets\" + (bucket ? `/${bucket}` : \"\"),\n  history: (bucket: string) => `${ENDPOINTS.bucket(bucket)}/history`,\n  collection: (bucket: string, coll?: string) =>\n    `${ENDPOINTS.bucket(bucket)}/collections` + (coll ? `/${coll}` : \"\"),\n  group: (bucket: string, group?: string) =>\n    `${ENDPOINTS.bucket(bucket)}/groups` + (group ? `/${group}` : \"\"),\n  record: (bucket: string, coll: string, id?: string) =>\n    `${ENDPOINTS.collection(bucket, coll)}/records` + (id ? `/${id}` : \"\"),\n  attachment: (bucket: string, coll: string, id: string) =>\n    `${ENDPOINTS.record(bucket, coll, id)}/attachment`,\n};\n\nexport default ENDPOINTS;\n","import { KintoRequest, HttpMethod, Permission } from \"./types\";\nimport { createFormData } from \"./utils\";\n\ninterface RequestOptions {\n  safe?: boolean;\n  headers?: Headers | Record<string, string> | string[][];\n  method?: HttpMethod;\n  gzipped?: boolean | null;\n  last_modified?: number;\n  patch?: boolean;\n}\ntype AddAttachmentRequestOptions = RequestOptions & {\n  last_modified?: number;\n  filename?: string;\n};\n\ntype RequestBody = {\n  data?: any;\n  permissions?: Partial<Record<Permission, string[]>>;\n};\ninterface RecordRequestBody extends RequestBody {\n  data?: { id?: string; last_modified?: number; [key: string]: any };\n}\n\nconst requestDefaults: RequestOptions = {\n  safe: false,\n  // check if we should set default content type here\n  headers: {},\n  patch: false,\n};\n\n/**\n * @private\n */\nfunction safeHeader(\n  safe?: boolean,\n  last_modified?: number\n): Record<string, string> {\n  if (!safe) {\n    return {};\n  }\n  if (last_modified) {\n    return { \"If-Match\": `\"${last_modified}\"` };\n  }\n  return { \"If-None-Match\": \"*\" };\n}\n\n/**\n * @private\n */\nexport function createRequest(\n  path: string,\n  { data, permissions }: RequestBody,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe } = {\n    ...requestDefaults,\n    ...options,\n  };\n  const method = options.method || (data && data.id) ? \"PUT\" : \"POST\";\n  return {\n    method,\n    path,\n    headers: { ...headers, ...safeHeader(safe) },\n    body: { data, permissions },\n  };\n}\n\n/**\n * @private\n */\nexport function updateRequest(\n  path: string,\n  { data, permissions }: RecordRequestBody,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, patch } = { ...requestDefaults, ...options };\n  const { last_modified } = { ...data, ...options };\n\n  const hasNoData =\n    data &&\n    Object.keys(data).filter((k) => k !== \"id\" && k !== \"last_modified\")\n      .length === 0;\n  if (hasNoData) {\n    data = undefined;\n  }\n\n  return {\n    method: patch ? \"PATCH\" : \"PUT\",\n    path,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n    body: { data, permissions },\n  };\n}\n\n/**\n * @private\n */\nexport function jsonPatchPermissionsRequest(\n  path: string,\n  permissions: { [key in Permission]?: string[] },\n  opType: string,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, last_modified } = { ...requestDefaults, ...options };\n\n  const ops = [];\n\n  for (const [type, principals] of Object.entries(permissions)) {\n    if (principals) {\n      for (const principal of principals) {\n        ops.push({\n          op: opType,\n          path: `/permissions/${type}/${principal}`,\n        });\n      }\n    }\n  }\n\n  return {\n    method: \"PATCH\",\n    path,\n    headers: {\n      ...headers,\n      ...safeHeader(safe, last_modified),\n      \"Content-Type\": \"application/json-patch+json\",\n    },\n    body: ops,\n  };\n}\n\n/**\n * @private\n */\nexport function deleteRequest(\n  path: string,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, last_modified } = {\n    ...requestDefaults,\n    ...options,\n  };\n  if (safe && !last_modified) {\n    throw new Error(\"Safe concurrency check requires a last_modified value.\");\n  }\n  return {\n    method: \"DELETE\",\n    path,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n  };\n}\n\n/**\n * @private\n */\nexport function addAttachmentRequest(\n  path: string,\n  dataURI: string,\n  { data, permissions }: RecordRequestBody = {},\n  options: AddAttachmentRequestOptions = {}\n): KintoRequest {\n  const { headers, safe, gzipped } = { ...requestDefaults, ...options };\n  const { last_modified } = { ...data, ...options };\n\n  const body = { data, permissions };\n  const formData = createFormData(dataURI, body, options);\n\n  const customPath = `${path}${\n    gzipped !== null ? \"?gzipped=\" + (gzipped ? \"true\" : \"false\") : \"\"\n  }`;\n\n  return {\n    method: \"POST\",\n    path: customPath,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n    body: formData,\n  };\n}\n","import { KintoRequest } from \"./types\";\n\ninterface ConflictRecord {\n  last_modified: number;\n  id: string;\n}\n\ninterface ConflictResponse {\n  existing: ConflictRecord;\n}\n\ninterface ResponseBody {\n  data?: unknown;\n  details?: ConflictResponse;\n  code?: number;\n  errno?: number;\n  error?: string;\n  message?: string;\n  info?: string;\n}\n\ninterface ErrorResponse {\n  path: string;\n  sent: KintoRequest;\n  error: ResponseBody;\n}\n\nexport interface AggregateResponse {\n  errors: ErrorResponse[];\n  published: ResponseBody[];\n  conflicts: any[];\n  skipped: any[];\n}\n\nexport interface KintoBatchResponse {\n  status: number;\n  path: string;\n  body: ResponseBody;\n  headers: { [key: string]: string };\n}\n\n/**\n * Exports batch responses as a result object.\n *\n * @private\n * @param  {Array} responses The batch subrequest responses.\n * @param  {Array} requests  The initial issued requests.\n * @return {Object}\n */\nexport function aggregate(\n  responses: KintoBatchResponse[] = [],\n  requests: KintoRequest[] = []\n): AggregateResponse {\n  if (responses.length !== requests.length) {\n    throw new Error(\"Responses length should match requests one.\");\n  }\n  const results: AggregateResponse = {\n    errors: [],\n    published: [],\n    conflicts: [],\n    skipped: [],\n  };\n  return responses.reduce((acc, response, index) => {\n    const { status } = response;\n    const request = requests[index];\n    if (status >= 200 && status < 400) {\n      acc.published.push(response.body);\n    } else if (status === 404) {\n      // Extract the id manually from request path while waiting for Kinto/kinto#818\n      const regex = /(buckets|groups|collections|records)\\/([^/]+)$/;\n      const extracts = request.path.match(regex);\n      const id = extracts && extracts.length === 3 ? extracts[2] : undefined;\n      acc.skipped.push({\n        id,\n        path: request.path,\n        error: response.body,\n      });\n    } else if (status === 412) {\n      acc.conflicts.push({\n        // XXX: specifying the type is probably superfluous\n        type: \"outgoing\",\n        local: request.body,\n        remote:\n          (response.body.details && response.body.details.existing) || null,\n      });\n    } else {\n      acc.errors.push({\n        path: request.path,\n        sent: request,\n        error: response.body,\n      });\n    }\n    return acc;\n  }, results);\n}\n","import { v4 as uuid } from \"uuid\";\n\nimport { capable, toDataBody, isObject } from \"./utils\";\nimport * as requests from \"./requests\";\nimport KintoClientBase, { PaginatedParams, PaginationResult } from \"./base\";\nimport Bucket from \"./bucket\";\nimport {\n  KintoRequest,\n  Permission,\n  KintoResponse,\n  KintoIdObject,\n  KintoObject,\n  Attachment,\n  OperationResponse,\n  MappableObject,\n} from \"./types\";\nimport { HttpResponse } from \"./http\";\nimport { AggregateResponse } from \"./batch\";\n\nexport interface CollectionOptions {\n  headers?: Record<string, string>;\n  safe?: boolean;\n  retry?: number;\n}\n\n/**\n * Abstract representation of a selected collection.\n *\n */\nexport default class Collection {\n  public client: KintoClientBase;\n  private bucket: Bucket;\n  public name: string;\n  private _endpoints: KintoClientBase[\"endpoints\"];\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n\n  /**\n   * Constructor.\n   *\n   * @param  {KintoClient}  client            The client instance.\n   * @param  {Bucket}       bucket            The bucket instance.\n   * @param  {String}       name              The collection name.\n   * @param  {Object}       [options={}]      The options object.\n   * @param  {Object}       [options.headers] The headers object option.\n   * @param  {Boolean}      [options.safe]    The safe option.\n   * @param  {Number}       [options.retry]   The retry option.\n   * @param  {Boolean}      [options.batch]   (Private) Whether this\n   *     Collection is operating as part of a batch.\n   */\n  constructor(\n    client: KintoClientBase,\n    bucket: Bucket,\n    name: string,\n    options: CollectionOptions = {}\n  ) {\n    /**\n     * @ignore\n     */\n    this.client = client;\n    /**\n     * @ignore\n     */\n    this.bucket = bucket;\n    /**\n     * The collection name.\n     * @type {String}\n     */\n    this.name = name;\n\n    this._endpoints = client.endpoints;\n\n    /**\n     * @ignore\n     */\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n    // FIXME: This is kind of ugly; shouldn't the bucket be responsible\n    // for doing the merge?\n    this._headers = {\n      ...this.bucket.headers,\n      ...options.headers,\n    };\n  }\n\n  get execute(): KintoClientBase[\"execute\"] {\n    return this.client.execute.bind(this.client);\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * @private\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Retrieves the total number of records in this collection.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Number, Error>}\n   */\n  async getTotalRecords(\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<number> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    });\n    return parseInt(headers.get(\"Total-Records\"), 10);\n  }\n\n  /**\n   * Retrieves the ETag of the records list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getRecordsTimestamp(\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = (await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves collection data.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getData<T>(\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<T> {\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = { headers: this._getHeaders(options), path };\n    const { data } = (await this.client.execute(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    })) as { data: T };\n    return data;\n  }\n\n  /**\n   * Set collection data.\n   * @param  {Object}   data                    The collection data object.\n   * @param  {Object}   [options={}]            The options object.\n   * @param  {Object}   [options.headers]       The headers object option.\n   * @param  {Number}   [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}  [options.safe]          The safe option.\n   * @param  {Boolean}  [options.patch]         The patch option.\n   * @param  {Number}   [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setData<T extends MappableObject>(\n    data: T & { last_modified?: number },\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      patch?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(data)) {\n      throw new Error(\"A collection object is required.\");\n    }\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Retrieves the list of permissions for this collection.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getPermissions(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<{ [key in Permission]?: string[] }> {\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = { headers: this._getHeaders(options), path };\n    const { permissions } = (await this.client.execute<KintoResponse>(request, {\n      retry: this._getRetry(options),\n    })) as KintoResponse;\n    return permissions;\n  }\n\n  /**\n   * Replaces all existing collection permissions with the ones provided.\n   *\n   * @param  {Object}   permissions             The permissions object.\n   * @param  {Object}   [options={}]            The options object\n   * @param  {Object}   [options.headers]       The headers object option.\n   * @param  {Number}   [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}  [options.safe]          The safe option.\n   * @param  {Number}   [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const data = { last_modified: options.last_modified };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Append principals to the collection permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async addPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"add\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Remove principals from the collection permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async removePermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"remove\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Creates a record in current collection.\n   *\n   * @param  {Object}  record                The record to create.\n   * @param  {Object}  [options={}]          The options object.\n   * @param  {Object}  [options.headers]     The headers object option.\n   * @param  {Number}  [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]        The safe option.\n   * @param  {Object}  [options.permissions] The permissions option.\n   * @return {Promise<Object, Error>}\n   */\n  async createRecord<T extends MappableObject>(\n    record: T & { id?: string },\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const { permissions } = options;\n    const path = this._endpoints.record(this.bucket.name, this.name, record.id);\n    const request = requests.createRequest(\n      path,\n      { data: record, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Adds an attachment to a record, creating the record when it doesn't exist.\n   *\n   * @param  {String}  dataURL                 The data url.\n   * @param  {Object}  [record={}]             The record data.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @param  {Object}  [options.permissions]   The permissions option.\n   * @param  {String}  [options.filename]      Force the attachment filename.\n   * @param  {String}  [options.gzipped]       Force the attachment to be gzipped or not.\n   * @return {Promise<Object, Error>}\n   */\n  @capable([\"attachments\"])\n  async addAttachment(\n    dataURI: string,\n    record: { [key: string]: string } = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n      filename?: string;\n      gzipped?: boolean;\n    } = {}\n  ): Promise<\n    KintoResponse<{\n      attachment: Attachment;\n    }>\n  > {\n    const { permissions } = options;\n    const id = record.id || uuid();\n    const path = this._endpoints.attachment(this.bucket.name, this.name, id);\n    const { last_modified } = { ...record, ...options };\n    const addAttachmentRequest = requests.addAttachmentRequest(\n      path,\n      dataURI,\n      { data: record, permissions },\n      {\n        last_modified,\n        filename: options.filename,\n        gzipped: options.gzipped,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    await this.client.execute(addAttachmentRequest, {\n      stringify: false,\n      retry: this._getRetry(options),\n    });\n    return this.getRecord<{ attachment: Attachment }>(id);\n  }\n\n  /**\n   * Removes an attachment from a given record.\n   *\n   * @param  {Object}  recordId                The record id.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   */\n  @capable([\"attachments\"])\n  async removeAttachment(\n    recordId: string,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<{}> {\n    const { last_modified } = options;\n    const path = this._endpoints.attachment(\n      this.bucket.name,\n      this.name,\n      recordId\n    );\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<{}>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<{}>;\n  }\n\n  /**\n   * Updates a record in current collection.\n   *\n   * @param  {Object}  record                  The record to update.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @param  {Object}  [options.permissions]   The permissions option.\n   * @return {Promise<Object, Error>}\n   */\n  async updateRecord<T>(\n    record: T & { id: string },\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n      patch?: boolean;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(record)) {\n      throw new Error(\"A record object is required.\");\n    }\n    if (!record.id) {\n      throw new Error(\"A record id is required.\");\n    }\n    const { permissions } = options;\n    const { last_modified } = { ...record, ...options };\n    const path = this._endpoints.record(this.bucket.name, this.name, record.id);\n    const request = requests.updateRequest(\n      path,\n      { data: record, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n        last_modified,\n        patch: !!options.patch,\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Deletes a record from the current collection.\n   *\n   * @param  {Object|String} record                  The record to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteRecord(\n    record: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const recordObj = toDataBody(record);\n    if (!recordObj.id) {\n      throw new Error(\"A record id is required.\");\n    }\n    const { id } = recordObj;\n    const { last_modified } = { ...recordObj, ...options };\n    const path = this._endpoints.record(this.bucket.name, this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes records from the current collection.\n   *\n   * Sorting is done by passing a `sort` string option:\n   *\n   * - The field to order the results by, prefixed with `-` for descending.\n   * Default: `-last_modified`.\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/sorting.html\n   *\n   * Filtering is done by passing a `filters` option object:\n   *\n   * - `{fieldname: \"value\"}`\n   * - `{min_fieldname: 4000}`\n   * - `{in_fieldname: \"1,2,3\"}`\n   * - `{not_fieldname: 0}`\n   * - `{exclude_fieldname: \"0,1\"}`\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/filtering.html\n   *\n   * @param  {Object}   [options={}]                    The options object.\n   * @param  {Object}   [options.headers]               The headers object option.\n   * @param  {Number}   [options.retry=0]               Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}   [options.filters={}]            The filters object.\n   * @param  {String}   [options.sort=\"-last_modified\"] The sort field.\n   * @param  {String}   [options.at]                    The timestamp to get a snapshot at.\n   * @param  {String}   [options.limit=null]            The limit field.\n   * @param  {String}   [options.pages=1]               The number of result pages to aggregate.\n   * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.\n   * @param  {Array}    [options.fields]                Limit response to just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteRecords<T extends KintoObject>(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    return this.client.paginatedDelete<T>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves a record from the current collection.\n   *\n   * @param  {String} id                The record id to retrieve.\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getRecord<T>(\n    id: string,\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name, id);\n    const request = { headers: this._getHeaders(options), path };\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Lists records from the current collection.\n   *\n   * Sorting is done by passing a `sort` string option:\n   *\n   * - The field to order the results by, prefixed with `-` for descending.\n   * Default: `-last_modified`.\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/sorting.html\n   *\n   * Filtering is done by passing a `filters` option object:\n   *\n   * - `{fieldname: \"value\"}`\n   * - `{min_fieldname: 4000}`\n   * - `{in_fieldname: \"1,2,3\"}`\n   * - `{not_fieldname: 0}`\n   * - `{exclude_fieldname: \"0,1\"}`\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/filtering.html\n   *\n   * Paginating is done by passing a `limit` option, then calling the `next()`\n   * method from the resolved result object to fetch the next page, if any.\n   *\n   * @param  {Object}   [options={}]                    The options object.\n   * @param  {Object}   [options.headers]               The headers object option.\n   * @param  {Number}   [options.retry=0]               Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}   [options.filters={}]            The filters object.\n   * @param  {String}   [options.sort=\"-last_modified\"] The sort field.\n   * @param  {String}   [options.at]                    The timestamp to get a snapshot at.\n   * @param  {String}   [options.limit=null]            The limit field.\n   * @param  {String}   [options.pages=1]               The number of result pages to aggregate.\n   * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.\n   * @param  {Array}    [options.fields]                Limit response to just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async listRecords<T extends KintoObject>(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n      at?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    if (options.at) {\n      return this.getSnapshot<T>(options.at);\n    } else {\n      return this.client.paginatedList<T>(path, options, {\n        headers: this._getHeaders(options),\n        retry: this._getRetry(options),\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  async isHistoryComplete(): Promise<boolean> {\n    // We consider that if we have the collection creation event part of the\n    // history, then all records change events have been tracked.\n    const {\n      data: [oldestHistoryEntry],\n    } = await this.bucket.listHistory({\n      limit: 1,\n      filters: {\n        action: \"create\",\n        resource_name: \"collection\",\n        collection_id: this.name,\n      },\n    });\n    return !!oldestHistoryEntry;\n  }\n\n  /**\n   * @private\n   */\n  @capable([\"history\"])\n  async getSnapshot<T extends KintoObject>(\n    at: number\n  ): Promise<PaginationResult<T>> {\n    if (!at || !Number.isInteger(at) || at <= 0) {\n      throw new Error(\"Invalid argument, expected a positive integer.\");\n    }\n    // Retrieve history and check it covers the required time range.\n    // Ensure we have enough history data to retrieve the complete list of\n    // changes.\n    if (!(await this.isHistoryComplete())) {\n      throw new Error(\n        \"Computing a snapshot is only possible when the full history for a \" +\n          \"collection is available. Here, the history plugin seems to have \" +\n          \"been enabled after the creation of the collection.\"\n      );\n    }\n\n    // Because of https://github.com/Kinto/kinto-http.js/issues/963\n    // we cannot simply rely on the history endpoint.\n    // Our strategy here is to clean-up the history entries from the\n    // records that were deleted via the plural endpoint.\n    // We will detect them by comparing the current state of the collection\n    // and the full history of the collection since its genesis.\n\n    // List full history of collection.\n    const { data: fullHistory } = await this.bucket.listHistory<T>({\n      pages: Infinity, // all pages up to target timestamp are required\n      sort: \"last_modified\", // chronological order\n      filters: {\n        resource_name: \"record\",\n        collection_id: this.name,\n      },\n    });\n\n    // Keep latest entry ever, and latest within snapshot window.\n    // (history is sorted chronologically)\n    const latestEver = new Map();\n    const latestInSnapshot = new Map();\n    for (const entry of fullHistory) {\n      if (entry.target.data.last_modified <= at) {\n        // Snapshot includes changes right on timestamp.\n        latestInSnapshot.set(entry.record_id, entry);\n      }\n      latestEver.set(entry.record_id, entry);\n    }\n\n    // Current records ids in the collection.\n    const { data: current } = await this.listRecords({\n      pages: Infinity,\n      fields: [\"id\"], // we don't need attributes.\n    });\n    const currentIds = new Set(current.map((record) => record.id));\n\n    // If a record is not in the current collection, and its\n    // latest history entry isn't a delete then this means that\n    // it was deleted via the plural endpoint (and that we lost track\n    // of this deletion because of bug #963)\n    const deletedViaPlural = new Set();\n    for (const entry of latestEver.values()) {\n      if (entry.action != \"delete\" && !currentIds.has(entry.record_id)) {\n        deletedViaPlural.add(entry.record_id);\n      }\n    }\n\n    // Now reconstruct the collection based on latest version in snapshot\n    // filtering all deleted records.\n    const reconstructed = [];\n    for (const entry of latestInSnapshot.values()) {\n      if (entry.action != \"delete\" && !deletedViaPlural.has(entry.record_id)) {\n        reconstructed.push(entry.target.data);\n      }\n    }\n\n    return {\n      last_modified: String(at),\n      data: Array.from(reconstructed).sort(\n        (a, b) => b.last_modified - a.last_modified\n      ),\n      next: () => {\n        throw new Error(\"Snapshots don't support pagination\");\n      },\n      hasNextPage: false,\n      totalRecords: reconstructed.length,\n    } as PaginationResult<T>;\n  }\n\n  /**\n   * Performs batch operations at the current collection level.\n   *\n   * @param  {Function} fn                   The batch operation function.\n   * @param  {Object}   [options={}]         The options object.\n   * @param  {Object}   [options.headers]    The headers object option.\n   * @param  {Boolean}  [options.safe]       The safe option.\n   * @param  {Number}   [options.retry]      The retry option.\n   * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.\n   * @return {Promise<Object, Error>}\n   */\n  async batch(\n    fn: (client: Collection) => void,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    return this.client.batch(fn, {\n      bucket: this.bucket.name,\n      collection: this.name,\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n      aggregate: !!options.aggregate,\n    });\n  }\n}\n","import { toDataBody, isObject, capable } from \"./utils\";\nimport Collection from \"./collection\";\nimport * as requests from \"./requests\";\nimport KintoClientBase, { PaginatedParams, PaginationResult } from \"./base\";\nimport {\n  KintoRequest,\n  KintoIdObject,\n  Permission,\n  KintoResponse,\n  HistoryEntry,\n  KintoObject,\n  Group,\n  OperationResponse,\n  MappableObject,\n} from \"./types\";\nimport { HttpResponse } from \"./http\";\nimport { AggregateResponse } from \"./batch\";\n\nexport interface BucketOptions {\n  safe?: boolean;\n  headers?: Record<string, string>;\n  retry?: number;\n}\n/**\n * Abstract representation of a selected bucket.\n *\n */\nexport default class Bucket {\n  private client: KintoClientBase;\n  public name: string;\n  private _endpoints: KintoClientBase[\"endpoints\"];\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n\n  /**\n   * Constructor.\n   *\n   * @param  {KintoClient} client            The client instance.\n   * @param  {String}      name              The bucket name.\n   * @param  {Object}      [options={}]      The headers object option.\n   * @param  {Object}      [options.headers] The headers object option.\n   * @param  {Boolean}     [options.safe]    The safe option.\n   * @param  {Number}      [options.retry]   The retry option.\n   */\n  constructor(\n    client: KintoClientBase,\n    name: string,\n    options: BucketOptions = {}\n  ) {\n    /**\n     * @ignore\n     */\n    this.client = client;\n    /**\n     * The bucket name.\n     * @type {String}\n     */\n    this.name = name;\n\n    this._endpoints = client.endpoints;\n\n    /**\n     * @ignore\n     */\n    this._headers = options.headers || {};\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n  }\n\n  get execute(): KintoClientBase[\"execute\"] {\n    return this.client.execute.bind(this.client);\n  }\n\n  get headers(): Record<string, string> {\n    return this._headers;\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * @private\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Selects a collection.\n   *\n   * @param  {String}  name              The collection name.\n   * @param  {Object}  [options={}]      The options object.\n   * @param  {Object}  [options.headers] The headers object option.\n   * @param  {Boolean} [options.safe]    The safe option.\n   * @return {Collection}\n   */\n  collection(\n    name: string,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n    } = {}\n  ): Collection {\n    return new Collection(this.client, this, name, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n    });\n  }\n\n  /**\n   * Retrieves the ETag of the collection list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getCollectionsTimestamp(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.collection(this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = (await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves the ETag of the group list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getGroupsTimestamp(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.group(this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = (await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves bucket data.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getData<T>(\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<T> {\n    const path = this._endpoints.bucket(this.name);\n    const request = {\n      headers: this._getHeaders(options),\n      path,\n    };\n    const { data } = (await this.client.execute(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    })) as { data: T };\n    return data;\n  }\n\n  /**\n   * Set bucket data.\n   * @param  {Object}  data                    The bucket data object.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers={}]    The headers object option.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.patch]         The patch option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setData<T extends MappableObject>(\n    data: T & { last_modified?: number },\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      patch?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(data)) {\n      throw new Error(\"A bucket object is required.\");\n    }\n\n    const bucket: T & { last_modified?: number; id?: string } = {\n      ...data,\n      id: this.name,\n    };\n\n    // For default bucket, we need to drop the id from the data object.\n    // Bug in Kinto < 3.1.1\n    const bucketId = bucket.id;\n    if (bucket.id === \"default\") {\n      delete bucket.id;\n    }\n\n    const path = this._endpoints.bucket(bucketId);\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n    const request = requests.updateRequest(\n      path,\n      { data: bucket, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Retrieves the list of history entries in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  @capable([\"history\"])\n  async listHistory<T>(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<HistoryEntry<T>>> {\n    const path = this._endpoints.history(this.name);\n    return this.client.paginatedList<HistoryEntry<T>>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of collections in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async listCollections(\n    options: PaginatedParams & {\n      filters?: Record<string, string | number>;\n      headers?: Record<string, string>;\n      retry?: number;\n      fields?: string[];\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.collection(this.name);\n    return this.client.paginatedList<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Creates a new collection in current bucket.\n   *\n   * @param  {String|undefined}  id          The collection id.\n   * @param  {Object}  [options={}]          The options object.\n   * @param  {Boolean} [options.safe]        The safe option.\n   * @param  {Object}  [options.headers]     The headers object option.\n   * @param  {Number}  [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.permissions] The permissions object.\n   * @param  {Object}  [options.data]        The data object.\n   * @return {Promise<Object, Error>}\n   */\n  async createCollection(\n    id?: string,\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      permissions?: { [key in Permission]?: string[] };\n      data?: any;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    const { permissions, data = {} } = options;\n    data.id = id;\n    const path = this._endpoints.collection(this.name, id);\n    const request = requests.createRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Deletes a collection from the current bucket.\n   *\n   * @param  {Object|String} collection              The collection to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteCollection(\n    collection: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const collectionObj = toDataBody(collection);\n    if (!collectionObj.id) {\n      throw new Error(\"A collection id is required.\");\n    }\n    const { id } = collectionObj;\n    const { last_modified } = { ...collectionObj, ...options };\n    const path = this._endpoints.collection(this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes collections from the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async deleteCollections(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.collection(this.name);\n    return this.client.paginatedDelete<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of groups in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async listGroups(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<Group>> {\n    const path = this._endpoints.group(this.name);\n    return this.client.paginatedList<Group>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Fetches a group in current bucket.\n   *\n   * @param  {String} id                The group id.\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async getGroup(\n    id: string,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      query?: { [key: string]: string };\n      fields?: string[];\n    } = {}\n  ): Promise<KintoResponse<Group>> {\n    const path = this._endpoints.group(this.name, id);\n    const request = {\n      headers: this._getHeaders(options),\n      path,\n    };\n    return this.client.execute<KintoResponse<Group>>(request, {\n      retry: this._getRetry(options),\n      query: options.query,\n      fields: options.fields,\n    }) as Promise<KintoResponse<Group>>;\n  }\n\n  /**\n   * Creates a new group in current bucket.\n   *\n   * @param  {String|undefined}  id                    The group id.\n   * @param  {Array<String>}     [members=[]]          The list of principals.\n   * @param  {Object}            [options={}]          The options object.\n   * @param  {Object}            [options.data]        The data object.\n   * @param  {Object}            [options.permissions] The permissions object.\n   * @param  {Boolean}           [options.safe]        The safe option.\n   * @param  {Object}            [options.headers]     The headers object option.\n   * @param  {Number}            [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async createGroup(\n    id?: string,\n    members: string[] = [],\n    options: {\n      data?: any;\n      permissions?: { [key in Permission]?: string[] };\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<Group>> {\n    const data = {\n      ...options.data,\n      id,\n      members,\n    };\n    const path = this._endpoints.group(this.name, id);\n    const { permissions } = options;\n    const request = requests.createRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<Group>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<Group>>;\n  }\n\n  /**\n   * Updates an existing group in current bucket.\n   *\n   * @param  {Object}  group                   The group object.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.data]          The data object.\n   * @param  {Object}  [options.permissions]   The permissions object.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async updateGroup<T extends MappableObject>(\n    group: KintoIdObject,\n    options: {\n      data?: T & { members?: string[] };\n      permissions?: { [key in Permission]?: string[] };\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n      patch?: boolean;\n    } = {}\n  ): Promise<KintoResponse<T & { members: string[] }>> {\n    if (!isObject(group)) {\n      throw new Error(\"A group object is required.\");\n    }\n    if (!group.id) {\n      throw new Error(\"A group id is required.\");\n    }\n    const data = {\n      ...options.data,\n      ...group,\n    };\n    const path = this._endpoints.group(this.name, group.id);\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<T & { members: string[] }>>(\n      request,\n      {\n        retry: this._getRetry(options),\n      }\n    ) as Promise<KintoResponse<T & { members: string[] }>>;\n  }\n\n  /**\n   * Deletes a group from the current bucket.\n   *\n   * @param  {Object|String} group                   The group to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteGroup(\n    group: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const groupObj = toDataBody(group);\n    const { id } = groupObj;\n    const { last_modified } = { ...groupObj, ...options };\n    const path = this._endpoints.group(this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes groups from the current bucket.\n   *\n   * @param  {Object} [options={}]          The options object.\n   * @param  {Object} [options.filters={}]  The filters object.\n   * @param  {Object} [options.headers]     The headers object option.\n   * @param  {Number} [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]      Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async deleteGroups(\n    options: PaginatedParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.group(this.name);\n    return this.client.paginatedDelete<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of permissions for this bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getPermissions(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<{ [key in Permission]?: string[] }> {\n    const request = {\n      headers: this._getHeaders(options),\n      path: this._endpoints.bucket(this.name),\n    };\n    const { permissions } = (await this.client.execute<KintoResponse>(request, {\n      retry: this._getRetry(options),\n    })) as KintoResponse;\n    return permissions;\n  }\n\n  /**\n   * Replaces all existing bucket permissions with the ones provided.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers={}]    The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const data = { last_modified };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Append principals to the bucket permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async addPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"add\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Remove principals from the bucket permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async removePermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"remove\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return this.client.execute<KintoResponse<{}>>(request, {\n      retry: this._getRetry(options),\n    }) as Promise<KintoResponse<{}>>;\n  }\n\n  /**\n   * Performs batch operations at the current bucket level.\n   *\n   * @param  {Function} fn                   The batch operation function.\n   * @param  {Object}   [options={}]         The options object.\n   * @param  {Object}   [options.headers]    The headers object option.\n   * @param  {Boolean}  [options.safe]       The safe option.\n   * @param  {Number}   [options.retry=0]    The retry option.\n   * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.\n   * @return {Promise<Object, Error>}\n   */\n  async batch(\n    fn: (client: Bucket) => void,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    return this.client.batch(fn, {\n      bucket: this.name,\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n      aggregate: !!options.aggregate,\n    });\n  }\n}\n","import {\n  partition,\n  qsify,\n  support,\n  nobatch,\n  toDataBody,\n  cleanUndefinedProperties,\n} from \"./utils\";\nimport HTTP, { HttpResponse } from \"./http\";\nimport endpoints from \"./endpoints\";\nimport * as requests from \"./requests\";\nimport { aggregate, AggregateResponse } from \"./batch\";\nimport Bucket from \"./bucket\";\nimport { addEndpointOptions, capable } from \"./utils\";\nimport {\n  HelloResponse,\n  KintoRequest,\n  BatchResponse,\n  OperationResponse,\n  DataResponse,\n  Permission,\n  KintoIdObject,\n  MappableObject,\n  KintoObject,\n  PermissionData,\n  KintoResponse,\n  ServerSettings,\n  ServerCapability,\n  User,\n  Emitter,\n  HttpMethod,\n  FetchFunction,\n} from \"./types\";\nimport Collection from \"./collection\";\n\n/**\n * Currently supported protocol version.\n * @type {String}\n */\nexport const SUPPORTED_PROTOCOL_VERSION = \"v1\";\n\nexport interface KintoClientOptions {\n  safe?: boolean;\n  events?: Emitter;\n  headers?: Record<string, string>;\n  retry?: number;\n  bucket?: string;\n  requestMode?: RequestMode;\n  timeout?: number;\n  batch?: boolean;\n  fetchFunc?: FetchFunction;\n}\n\nexport interface PaginatedParams {\n  sort?: string;\n  filters?: Record<string, string | number>;\n  limit?: number;\n  pages?: number;\n  since?: string;\n  fields?: string[];\n}\n\nexport interface PaginationResult<T> {\n  last_modified: string | null;\n  data: T[];\n  next: (nextPage?: string | null) => Promise<PaginationResult<T>>;\n  hasNextPage: boolean;\n  totalRecords: number;\n}\n\ntype BaseBatch = (client: KintoClientBase) => void;\ntype BucketBatch = (client: Bucket) => void;\ntype CollectionBatch = (client: Collection) => void;\n\n/**\n * High level HTTP client for the Kinto API.\n *\n * @example\n * const client = new KintoClient(\"https://kinto.dev.mozaws.net/v1\");\n * client.bucket(\"default\")\n *    .collection(\"my-blog\")\n *    .createRecord({title: \"First article\"})\n *   .then(console.log.bind(console))\n *   .catch(console.error.bind(console));\n */\nexport default class KintoClientBase {\n  private _backoffReleaseTime: number | null;\n  private _requests: KintoRequest[];\n  private _isBatch: boolean;\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n  public serverInfo: HelloResponse | null;\n  public events?: Emitter;\n  public http: HTTP;\n  public endpoints: typeof endpoints;\n  private _remote!: string;\n  private _version!: string;\n\n  /**\n   * Constructor.\n   *\n   * @param  {String}       remote  The remote URL.\n   * @param  {Object}       [options={}]                  The options object.\n   * @param  {Boolean}      [options.safe=true]           Adds concurrency headers to every requests.\n   * @param  {EventEmitter} [options.events=EventEmitter] The events handler instance.\n   * @param  {Object}       [options.headers={}]          The key-value headers to pass to each request.\n   * @param  {Object}       [options.retry=0]             Number of retries when request fails (default: 0)\n   * @param  {String}       [options.bucket=\"default\"]    The default bucket to use.\n   * @param  {String}       [options.requestMode=\"cors\"]  The HTTP request mode (from ES6 fetch spec).\n   * @param  {Number}       [options.timeout=null]        The request timeout in ms, if any.\n   * @param  {Function}     [options.fetchFunc=fetch]     The function to be used to execute HTTP requests.\n   */\n  constructor(remote: string, options: KintoClientOptions) {\n    if (typeof remote !== \"string\" || !remote.length) {\n      throw new Error(\"Invalid remote URL: \" + remote);\n    }\n    if (remote[remote.length - 1] === \"/\") {\n      remote = remote.slice(0, -1);\n    }\n    this._backoffReleaseTime = null;\n\n    this._requests = [];\n    this._isBatch = !!options.batch;\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n    this._headers = options.headers || {};\n\n    // public properties\n    /**\n     * The remote server base URL.\n     * @type {String}\n     */\n    this.remote = remote;\n    /**\n     * Current server information.\n     * @ignore\n     * @type {Object|null}\n     */\n    this.serverInfo = null;\n    /**\n     * The event emitter instance. Should comply with the `EventEmitter`\n     * interface.\n     * @ignore\n     * @type {Class}\n     */\n    this.events = options.events;\n\n    this.endpoints = endpoints;\n\n    const { fetchFunc, requestMode, timeout } = options;\n    /**\n     * The HTTP instance.\n     * @ignore\n     * @type {HTTP}\n     */\n    this.http = new HTTP(this.events, { fetchFunc, requestMode, timeout });\n    this._registerHTTPEvents();\n  }\n\n  /**\n   * The remote endpoint base URL. Setting the value will also extract and\n   * validate the version.\n   * @type {String}\n   */\n  get remote(): string {\n    return this._remote;\n  }\n\n  /**\n   * @ignore\n   */\n  set remote(url: string) {\n    let version;\n    try {\n      version = url.match(/\\/(v\\d+)\\/?$/)![1];\n    } catch (err) {\n      throw new Error(\"The remote URL must contain the version: \" + url);\n    }\n    if (version !== SUPPORTED_PROTOCOL_VERSION) {\n      throw new Error(`Unsupported protocol version: ${version}`);\n    }\n    this._remote = url;\n    this._version = version;\n  }\n\n  /**\n   * The current server protocol version, eg. `v1`.\n   * @type {String}\n   */\n  get version(): string {\n    return this._version;\n  }\n\n  /**\n   * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is\n   * ongoing.\n   *\n   * @type {Number}\n   */\n  get backoff(): number {\n    const currentTime = new Date().getTime();\n    if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {\n      return this._backoffReleaseTime - currentTime;\n    }\n    return 0;\n  }\n\n  /**\n   * Registers HTTP events.\n   * @private\n   */\n  private _registerHTTPEvents(): void {\n    // Prevent registering event from a batch client instance\n    if (!this._isBatch && this.events) {\n      this.events.on(\"backoff\", (backoffMs) => {\n        this._backoffReleaseTime = backoffMs;\n      });\n    }\n  }\n\n  /**\n   * Retrieve a bucket object to perform operations on it.\n   *\n   * @param  {String}  name              The bucket name.\n   * @param  {Object}  [options={}]      The request options.\n   * @param  {Boolean} [options.safe]    The resulting safe option.\n   * @param  {Number}  [options.retry]   The resulting retry option.\n   * @param  {Object}  [options.headers] The extended headers object option.\n   * @return {Bucket}\n   */\n  bucket(\n    name: string,\n    options: {\n      safe?: boolean;\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Bucket {\n    return new Bucket(this, name, {\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Set client \"headers\" for every request, updating previous headers (if any).\n   *\n   * @param {Object} headers The headers to merge with existing ones.\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this._headers = {\n      ...this._headers,\n      ...headers,\n    };\n    this.serverInfo = null;\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * Note that unlike other options, headers aren't overridden, but\n   * merged instead.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Object}\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Retrieves the server's \"hello\" endpoint. This endpoint reveals\n   * server capabilities and settings as well as telling the client\n   * \"who they are\" according to their given authorization headers.\n   *\n   * @private\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Object}  [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  private async _getHello(\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<HelloResponse> {\n    const path = this.remote + endpoints.root();\n    const { json } = await this.http.request<HelloResponse>(\n      path,\n      { headers: this._getHeaders(options) },\n      { retry: this._getRetry(options) }\n    );\n    return json;\n  }\n\n  /**\n   * Retrieves server information and persist them locally. This operation is\n   * usually performed a single time during the instance lifecycle.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async fetchServerInfo(\n    options: { retry?: number } = {}\n  ): Promise<HelloResponse> {\n    if (this.serverInfo) {\n      return this.serverInfo;\n    }\n    this.serverInfo = await this._getHello({ retry: this._getRetry(options) });\n    return this.serverInfo;\n  }\n\n  /**\n   * Retrieves Kinto server settings.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchServerSettings(\n    options: { retry?: number } = {}\n  ): Promise<ServerSettings> {\n    const { settings } = await this.fetchServerInfo(options);\n    return settings;\n  }\n\n  /**\n   * Retrieve server capabilities information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchServerCapabilities(\n    options: {\n      retry?: number;\n    } = {}\n  ): Promise<{ [key: string]: ServerCapability }> {\n    const { capabilities } = await this.fetchServerInfo(options);\n    return capabilities;\n  }\n\n  /**\n   * Retrieve authenticated user information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Object}  [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchUser(\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<User | undefined> {\n    const { user } = await this._getHello(options);\n    return user;\n  }\n\n  /**\n   * Retrieve authenticated user information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchHTTPApiVersion(\n    options: {\n      retry?: number;\n    } = {}\n  ): Promise<string> {\n    const { http_api_version } = await this.fetchServerInfo(options);\n    return http_api_version;\n  }\n\n  /**\n   * Process batch requests, chunking them according to the batch_max_requests\n   * server setting when needed.\n   *\n   * @param  {Array}  requests     The list of batch subrequests to perform.\n   * @param  {Object} [options={}] The options object.\n   * @return {Promise<Object, Error>}\n   */\n  private async _batchRequests(\n    requests: KintoRequest[],\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<OperationResponse[]> {\n    const headers = this._getHeaders(options);\n    if (!requests.length) {\n      return [];\n    }\n    const serverSettings = await this.fetchServerSettings({\n      retry: this._getRetry(options),\n    });\n    const maxRequests = serverSettings[\"batch_max_requests\"];\n    if (maxRequests && requests.length > maxRequests) {\n      const chunks = partition(requests, maxRequests);\n      const results = [];\n      for (const chunk of chunks) {\n        const result = await this._batchRequests(chunk, options);\n        results.push(...result);\n      }\n      return results;\n    }\n    const { responses } = (await this.execute<BatchResponse>(\n      {\n        // FIXME: is this really necessary, since it's also present in\n        // the \"defaults\"?\n        headers,\n        path: endpoints.batch(),\n        method: \"POST\",\n        body: {\n          defaults: { headers },\n          requests,\n        },\n      },\n      { retry: this._getRetry(options) }\n    )) as BatchResponse;\n    return responses;\n  }\n\n  /**\n   * Sends batch requests to the remote server.\n   *\n   * Note: Reserved for internal use only.\n   *\n   * @ignore\n   * @param  {Function} fn                        The function to use for describing batch ops.\n   * @param  {Object}   [options={}]              The options object.\n   * @param  {Boolean}  [options.safe]            The safe option.\n   * @param  {Number}   [options.retry]           The retry option.\n   * @param  {String}   [options.bucket]          The bucket name option.\n   * @param  {String}   [options.collection]      The collection name option.\n   * @param  {Object}   [options.headers]         The headers object option.\n   * @param  {Boolean}  [options.aggregate=false] Produces an aggregated result object.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"Can't use batch within a batch!\")\n  async batch(\n    fn: BaseBatch | BucketBatch | CollectionBatch,\n    options: {\n      safe?: boolean;\n      retry?: number;\n      bucket?: string;\n      collection?: string;\n      headers?: Record<string, string>;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    const rootBatch = new KintoClientBase(this.remote, {\n      events: this.events,\n      batch: true,\n      safe: this._getSafe(options),\n      retry: this._getRetry(options),\n    });\n    if (options.bucket && options.collection) {\n      (fn as CollectionBatch)(\n        rootBatch.bucket(options.bucket).collection(options.collection)\n      );\n    } else if (options.bucket) {\n      (fn as BucketBatch)(rootBatch.bucket(options.bucket));\n    } else {\n      (fn as BaseBatch)(rootBatch);\n    }\n    const responses = await this._batchRequests(rootBatch._requests, options);\n    if (options.aggregate) {\n      return aggregate(responses, rootBatch._requests);\n    } else {\n      return responses;\n    }\n  }\n\n  /**\n   * Executes an atomic HTTP request.\n   *\n   * @param  {Object}  request             The request object.\n   * @param  {String}  request.path        The path to fetch, relative\n   *     to the Kinto server root.\n   * @param  {String}  [request.method=\"GET\"] The method to use in the\n   *     request.\n   * @param  {Body}    [request.body]      The request body.\n   * @param  {Object}  [request.headers={}] The request headers.\n   * @param  {Object}  [options={}]        The options object.\n   * @param  {Boolean} [options.raw=false] If true, resolve with full response\n   * @param  {Boolean} [options.stringify=true] If true, serialize body data to\n   * @param  {Number}  [options.retry=0]   The number of times to\n   *     retry a request if the server responds with Retry-After.\n   * JSON.\n   * @return {Promise<Object, Error>}\n   */\n  async execute<T>(\n    request: KintoRequest,\n    options: {\n      raw?: boolean;\n      stringify?: boolean;\n      retry?: number;\n      query?: { [key: string]: string };\n      fields?: string[];\n    } = {}\n  ): Promise<T | HttpResponse<T>> {\n    const { raw = false, stringify = true } = options;\n    // If we're within a batch, add the request to the stack to send at once.\n    if (this._isBatch) {\n      this._requests.push(request);\n      // Resolve with a message in case people attempt at consuming the result\n      // from within a batch operation.\n      const msg = (\"This result is generated from within a batch \" +\n        \"operation and should not be consumed.\") as unknown as T;\n      return raw\n        ? ({ status: 0, json: msg, headers: new Headers() } as HttpResponse<T>)\n        : msg;\n    }\n    const uri = this.remote + addEndpointOptions(request.path, options);\n    const result = await this.http.request<T>(\n      uri,\n      cleanUndefinedProperties({\n        // Limit requests to only those parts that would be allowed in\n        // a batch request -- don't pass through other fancy fetch()\n        // options like integrity, redirect, mode because they will\n        // break on a batch request.  A batch request only allows\n        // headers, method, path (above), and body.\n        method: request.method,\n        headers: request.headers,\n        body: stringify ? JSON.stringify(request.body) : request.body,\n      }),\n      { retry: this._getRetry(options) }\n    );\n    return raw ? result : result.json;\n  }\n\n  /**\n   * Perform an operation with a given HTTP method on some pages from\n   * a paginated list, following the `next-page` header automatically\n   * until we have processed the requested number of pages. Return a\n   * response with a `.next()` method that can be called to perform\n   * the requested HTTP method on more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when doing operation on pages.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to operate on. Undefined means one page. Pass\n   *     Infinity to operate on everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start doing operation on pages.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   * @param  {String}  [options.method=\"GET\"]\n   *     The method to use in the request.\n   */\n  async paginatedOperation<T>(\n    path: string,\n    params: PaginatedParams = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      method?: HttpMethod;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    // FIXME: this is called even in batch requests, which doesn't\n    // make any sense (since all batch requests get a \"dummy\"\n    // response; see execute() above).\n    const { sort, filters, limit, pages, since, fields } = {\n      sort: \"-last_modified\",\n      ...params,\n    };\n    // Safety/Consistency check on ETag value.\n    if (since && typeof since !== \"string\") {\n      throw new Error(\n        `Invalid value for since (${since}), should be ETag value.`\n      );\n    }\n\n    const query: { [key: string]: any } = {\n      ...filters,\n      _sort: sort,\n      _limit: limit,\n      _since: since,\n    };\n    if (fields) {\n      query._fields = fields;\n    }\n    const querystring = qsify(query);\n    let results: T[] = [],\n      current = 0;\n\n    const next = async function (\n      nextPage: string | null\n    ): Promise<PaginationResult<T>> {\n      if (!nextPage) {\n        throw new Error(\"Pagination exhausted.\");\n      }\n\n      return processNextPage(nextPage);\n    };\n\n    const processNextPage = async (\n      nextPage: string\n    ): Promise<PaginationResult<T>> => {\n      const { headers } = options;\n      return handleResponse(await this.http.request(nextPage, { headers }));\n    };\n\n    const pageResults = (\n      results: T[],\n      nextPage: string | null,\n      etag: string | null\n    ): PaginationResult<T> => {\n      // ETag string is supposed to be opaque and stored as-is.\n      // ETag header values are quoted (because of * and W/\"foo\").\n      return {\n        last_modified: etag ? etag.replace(/\"/g, \"\") : etag,\n        data: results,\n        next: next.bind(null, nextPage),\n        hasNextPage: !!nextPage,\n        totalRecords: -1,\n      };\n    };\n\n    const handleResponse = async function ({\n      headers = new Headers(),\n      json = {} as DataResponse<T[]>,\n    }: HttpResponse<DataResponse<T[]>>): Promise<PaginationResult<T>> {\n      const nextPage = headers.get(\"Next-Page\");\n      const etag = headers.get(\"ETag\");\n\n      if (!pages) {\n        return pageResults(json.data, nextPage, etag);\n      }\n      // Aggregate new results with previous ones\n      results = results.concat(json.data);\n      current += 1;\n      if (current >= pages || !nextPage) {\n        // Pagination exhausted\n        return pageResults(results, nextPage, etag);\n      }\n      // Follow next page\n      return processNextPage(nextPage);\n    };\n\n    return handleResponse(\n      (await this.execute(\n        // N.B.: This doesn't use _getHeaders, because all calls to\n        // `paginatedList` are assumed to come from calls that already\n        // have headers merged at e.g. the bucket or collection level.\n        {\n          headers: options.headers ? options.headers : {},\n          path: path + \"?\" + querystring,\n          method: options.method,\n        },\n        // N.B. This doesn't use _getRetry, because all calls to\n        // `paginatedList` are assumed to come from calls that already\n        // used `_getRetry` at e.g. the bucket or collection level.\n        { raw: true, retry: options.retry || 0 }\n      )) as HttpResponse<DataResponse<T[]>>\n    );\n  }\n\n  /**\n   * Fetch some pages from a paginated list, following the `next-page`\n   * header automatically until we have fetched the requested number\n   * of pages. Return a response with a `.next()` method that can be\n   * called to fetch more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when fetching.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to fetch. Undefined means one page. Pass\n   *     Infinity to fetch everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start fetching.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   */\n  async paginatedList<T>(\n    path: string,\n    params: PaginatedParams = {},\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<PaginationResult<T>> {\n    return this.paginatedOperation<T>(path, params, options);\n  }\n\n  /**\n   * Delete multiple objects, following the pagination if the number of\n   * objects exceeds the page limit until we have deleted the requested\n   * number of pages. Return a response with a `.next()` method that can\n   * be called to delete more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when deleting.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to delete. Undefined means one page. Pass\n   *     Infinity to delete everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start deleting.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   */\n  paginatedDelete<T>(\n    path: string,\n    params: PaginatedParams = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const { headers, safe, last_modified } = options;\n    const deleteRequest = requests.deleteRequest(path, {\n      headers,\n      safe: safe ? safe : false,\n      last_modified,\n    });\n    return this.paginatedOperation<T>(path, params, {\n      ...options,\n      headers: deleteRequest.headers as Record<string, string>,\n      method: \"DELETE\",\n    });\n  }\n\n  /**\n   * Lists all permissions.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object[], Error>}\n   */\n  @capable([\"permissions_endpoint\"])\n  async listPermissions(\n    options: PaginatedParams & {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<PaginationResult<PermissionData>> {\n    const path = endpoints.permissions();\n    // Ensure the default sort parameter is something that exists in permissions\n    // entries, as `last_modified` doesn't; here, we pick \"id\".\n    const paginationOptions = { sort: \"id\", ...options };\n    return this.paginatedList<PermissionData>(path, paginationOptions, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of buckets.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Array}  [options.fields]     Limit response to\n   *     just some fields.\n   * @return {Promise<Object[], Error>}\n   */\n  async listBuckets(\n    options: PaginatedParams & {\n      retry?: number;\n      headers?: Record<string, string>;\n      filters?: Record<string, string | number>;\n      fields?: string[];\n      since?: string;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = endpoints.bucket();\n    return this.paginatedList<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Creates a new bucket on the server.\n   *\n   * @param  {String|null}  id                The bucket name (optional).\n   * @param  {Object}       [options={}]      The options object.\n   * @param  {Boolean}      [options.data]    The bucket data option.\n   * @param  {Boolean}      [options.safe]    The safe option.\n   * @param  {Object}       [options.headers] The headers object option.\n   * @param  {Number}       [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async createBucket<T extends MappableObject>(\n    id: string | null,\n    options: {\n      data?: T & { id?: string };\n      permissions?: Partial<Record<Permission, string[]>>;\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const { data, permissions } = options;\n    const _data = { ...data, id: id ? id : undefined };\n    const path = _data.id ? endpoints.bucket(_data.id) : endpoints.bucket();\n    return this.execute<KintoResponse<T>>(\n      requests.createRequest(\n        path,\n        { data: _data, permissions },\n        {\n          headers: this._getHeaders(options),\n          safe: this._getSafe(options),\n        }\n      ),\n      { retry: this._getRetry(options) }\n    ) as Promise<KintoResponse<T>>;\n  }\n\n  /**\n   * Deletes a bucket from the server.\n   *\n   * @ignore\n   * @param  {Object|String} bucket                  The bucket to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteBucket(\n    bucket: string | KintoIdObject,\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const bucketObj = toDataBody(bucket);\n    if (!bucketObj.id) {\n      throw new Error(\"A bucket id is required.\");\n    }\n    const path = endpoints.bucket(bucketObj.id);\n    const { last_modified } = { ...bucketObj, ...options };\n    return this.execute<KintoResponse<{ deleted: boolean }>>(\n      requests.deleteRequest(path, {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }),\n      { retry: this._getRetry(options) }\n    ) as Promise<KintoResponse<{ deleted: boolean }>>;\n  }\n\n  /**\n   * Deletes buckets.\n   *\n   * @param  {Object} [options={}]             The options object.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object} [options.headers={}]     Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]        Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.filters={}]     The filters object.\n   * @param  {Array}  [options.fields]         Limit response to\n   *     just some fields.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object[], Error>}\n   */\n  @support(\"1.4\", \"2.0\")\n  async deleteBuckets(\n    options: PaginatedParams & {\n      safe?: boolean;\n      retry?: number;\n      headers?: Record<string, string>;\n      last_modified?: number;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = endpoints.bucket();\n    return this.paginatedDelete<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: options.safe,\n      last_modified: options.last_modified,\n    });\n  }\n\n  @capable([\"accounts\"])\n  async createAccount(\n    username: string,\n    password: string\n  ): Promise<KintoResponse<{ password: string }>> {\n    return this.execute<KintoResponse<{ password: string }>>(\n      requests.createRequest(\n        `/accounts/${username}`,\n        { data: { password } },\n        { method: \"PUT\" }\n      )\n    ) as Promise<KintoResponse<{ password: string }>>;\n  }\n}\n","import KintoClientBase, { KintoClientOptions, SUPPORTED_PROTOCOL_VERSION } from \"./base\";\nimport { AggregateResponse } from \"./batch\";\nimport Collection from \"./collection\";\nimport { KintoObject, KintoIdObject, KintoResponse, Permission, PermissionData } from \"./types\";\n\nexport default class KintoClient extends KintoClientBase {\n  constructor(remote: string, options: Partial<KintoClientOptions> = {}) {\n    const events = options.events;\n\n    super(remote, Object.assign({ events }, options));\n  }\n}\n\nexport {\n  KintoObject,\n  KintoIdObject,\n  Collection,\n  AggregateResponse,\n  KintoResponse,\n  Permission,\n  PermissionData,\n  SUPPORTED_PROTOCOL_VERSION\n};\n"],"names":["atob","FormData","Headers","requests.updateRequest","requests.jsonPatchPermissionsRequest","requests.createRequest","uuid","addAttachmentRequest","requests.addAttachmentRequest","requests.deleteRequest","endpoints","deleteRequest"],"mappings":"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"}