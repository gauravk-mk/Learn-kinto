(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.KintoClient = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

module.exports = _applyDecoratedDescriptor;
},{}],2:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
},{}],3:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
},{}],4:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],5:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],6:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],7:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
},{}],8:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
},{}],9:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
},{"./setPrototypeOf":16}],10:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],11:[function(require,module,exports){
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

module.exports = _interopRequireWildcard;
},{}],12:[function(require,module,exports){
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;
},{}],13:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
},{}],14:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;
},{}],15:[function(require,module,exports){
var _typeof = require("../helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
},{"../helpers/typeof":19,"./assertThisInitialized":3}],16:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
},{}],17:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
},{"./arrayWithHoles":2,"./iterableToArrayLimit":13,"./nonIterableRest":14}],18:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArray = require("./iterableToArray");

var nonIterableRest = require("./nonIterableRest");

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
}

module.exports = _toArray;
},{"./arrayWithHoles":2,"./iterableToArray":12,"./nonIterableRest":14}],19:[function(require,module,exports){
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],20:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],21:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":20}],22:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],23:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)

},{"base64-js":22,"buffer":23,"ieee754":25}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],25:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],26:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":29,"./v4":30}],27:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

},{}],28:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],29:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":27,"./lib/rng":28}],30:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":27,"./lib/rng":28}],31:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.SUPPORTED_PROTOCOL_VERSION = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));

var _utils = require("./utils");

var _http = _interopRequireDefault(require("./http"));

var _endpoint = _interopRequireDefault(require("./endpoint"));

var requests = _interopRequireWildcard(require("./requests"));

var _batch2 = require("./batch");

var _bucket = _interopRequireDefault(require("./bucket"));

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Currently supported protocol version.
 * @type {String}
 */
var SUPPORTED_PROTOCOL_VERSION = "v1";
/**
 * High level HTTP client for the Kinto API.
 *
 * @example
 * const client = new KintoClient("https://kinto.dev.mozaws.net/v1");
 * client.bucket("default")
 *    .collection("my-blog")
 *    .createRecord({title: "First article"})
 *   .then(console.log.bind(console))
 *   .catch(console.error.bind(console));
 */

exports.SUPPORTED_PROTOCOL_VERSION = SUPPORTED_PROTOCOL_VERSION;
var KintoClientBase = (_dec = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec2 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec3 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec4 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec5 = (0, _utils.nobatch)("Can't use batch within a batch!"), _dec6 = (0, _utils.capable)(["permissions_endpoint"]), _dec7 = (0, _utils.support)("1.4", "2.0"), _dec8 = (0, _utils.capable)(["accounts"]), (_class =
/*#__PURE__*/
function () {
  /**
   * Constructor.
   *
   * @param  {String}       remote  The remote URL.
   * @param  {Object}       [options={}]                  The options object.
   * @param  {Boolean}      [options.safe=true]           Adds concurrency headers to every requests.
   * @param  {EventEmitter} [options.events=EventEmitter] The events handler instance.
   * @param  {Object}       [options.headers={}]          The key-value headers to pass to each request.
   * @param  {Object}       [options.retry=0]             Number of retries when request fails (default: 0)
   * @param  {String}       [options.bucket="default"]    The default bucket to use.
   * @param  {String}       [options.requestMode="cors"]  The HTTP request mode (from ES6 fetch spec).
   * @param  {Number}       [options.timeout=null]        The request timeout in ms, if any.
   */
  function KintoClientBase(remote) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, KintoClientBase);

    if (typeof remote !== "string" || !remote.length) {
      throw new Error("Invalid remote URL: " + remote);
    }

    if (remote[remote.length - 1] === "/") {
      remote = remote.slice(0, -1);
    }

    this._backoffReleaseTime = null;
    this._requests = [];
    this._isBatch = !!options.batch;
    this._retry = options.retry || 0;
    this._safe = !!options.safe;
    this._headers = options.headers || {}; // public properties

    /**
     * The remote server base URL.
     * @type {String}
     */

    this.remote = remote;
    /**
     * Current server information.
     * @ignore
     * @type {Object|null}
     */

    this.serverInfo = null;
    /**
     * The event emitter instance. Should comply with the `EventEmitter`
     * interface.
     * @ignore
     * @type {Class}
     */

    this.events = options.events;
    var requestMode = options.requestMode,
        timeout = options.timeout;
    /**
     * The HTTP instance.
     * @ignore
     * @type {HTTP}
     */

    this.http = new _http["default"](this.events, {
      requestMode: requestMode,
      timeout: timeout
    });

    this._registerHTTPEvents();
  }
  /**
   * The remote endpoint base URL. Setting the value will also extract and
   * validate the version.
   * @type {String}
   */


  (0, _createClass2["default"])(KintoClientBase, [{
    key: "_registerHTTPEvents",

    /**
     * Registers HTTP events.
     * @private
     */
    value: function _registerHTTPEvents() {
      var _this = this;

      // Prevent registering event from a batch client instance
      if (!this._isBatch) {
        this.events.on("backoff", function (backoffMs) {
          _this._backoffReleaseTime = backoffMs;
        });
      }
    }
    /**
     * Retrieve a bucket object to perform operations on it.
     *
     * @param  {String}  name              The bucket name.
     * @param  {Object}  [options={}]      The request options.
     * @param  {Boolean} [options.safe]    The resulting safe option.
     * @param  {Number}  [options.retry]   The resulting retry option.
     * @param  {Object}  [options.headers] The extended headers object option.
     * @return {Bucket}
     */

  }, {
    key: "bucket",
    value: function bucket(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new _bucket["default"](this, name, {
        batch: this._isBatch,
        headers: this._getHeaders(options),
        safe: this._getSafe(options),
        retry: this._getRetry(options)
      });
    }
    /**
     * Set client "headers" for every request, updating previous headers (if any).
     *
     * @param {Object} headers The headers to merge with existing ones.
     */

  }, {
    key: "setHeaders",
    value: function setHeaders(headers) {
      this._headers = _objectSpread({}, this._headers, {}, headers);
      this.serverInfo = null;
    }
    /**
     * Get the value of "headers" for a given request, merging the
     * per-request headers with our own "default" headers.
     *
     * Note that unlike other options, headers aren't overridden, but
     * merged instead.
     *
     * @private
     * @param {Object} options The options for a request.
     * @returns {Object}
     */

  }, {
    key: "_getHeaders",
    value: function _getHeaders(options) {
      return _objectSpread({}, this._headers, {}, options.headers);
    }
    /**
     * Get the value of "safe" for a given request, using the
     * per-request option if present or falling back to our default
     * otherwise.
     *
     * @private
     * @param {Object} options The options for a request.
     * @returns {Boolean}
     */

  }, {
    key: "_getSafe",
    value: function _getSafe(options) {
      return _objectSpread({
        safe: this._safe
      }, options).safe;
    }
    /**
     * As _getSafe, but for "retry".
     *
     * @private
     */

  }, {
    key: "_getRetry",
    value: function _getRetry(options) {
      return _objectSpread({
        retry: this._retry
      }, options).retry;
    }
    /**
     * Retrieves the server's "hello" endpoint. This endpoint reveals
     * server capabilities and settings as well as telling the client
     * "who they are" according to their given authorization headers.
     *
     * @private
     * @param  {Object}  [options={}] The request options.
     * @param  {Object}  [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "_getHello",
    value: function () {
      var _getHello2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var options,
            path,
            _ref,
            json,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                path = this.remote + (0, _endpoint["default"])("root");
                _context.next = 4;
                return this.http.request(path, {
                  headers: this._getHeaders(options)
                }, {
                  retry: this._getRetry(options)
                });

              case 4:
                _ref = _context.sent;
                json = _ref.json;
                return _context.abrupt("return", json);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function _getHello() {
        return _getHello2.apply(this, arguments);
      };
    }()
    /**
     * Retrieves server information and persist them locally. This operation is
     * usually performed a single time during the instance lifecycle.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerInfo",
    value: function () {
      var _fetchServerInfo = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var options,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

                if (!this.serverInfo) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", this.serverInfo);

              case 3:
                _context2.next = 5;
                return this._getHello({
                  retry: this._getRetry(options)
                });

              case 5:
                this.serverInfo = _context2.sent;
                return _context2.abrupt("return", this.serverInfo);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function fetchServerInfo() {
        return _fetchServerInfo.apply(this, arguments);
      };
    }()
    /**
     * Retrieves Kinto server settings.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerSettings",
    value: function () {
      var _fetchServerSettings = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(options) {
        var _ref2, settings;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.fetchServerInfo(options);

              case 2:
                _ref2 = _context3.sent;
                settings = _ref2.settings;
                return _context3.abrupt("return", settings);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function fetchServerSettings(_x) {
        return _fetchServerSettings.apply(this, arguments);
      };
    }()
    /**
     * Retrieve server capabilities information.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerCapabilities",
    value: function () {
      var _fetchServerCapabilities = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4() {
        var options,
            _ref3,
            capabilities,
            _args4 = arguments;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                _context4.next = 3;
                return this.fetchServerInfo(options);

              case 3:
                _ref3 = _context4.sent;
                capabilities = _ref3.capabilities;
                return _context4.abrupt("return", capabilities);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function fetchServerCapabilities() {
        return _fetchServerCapabilities.apply(this, arguments);
      };
    }()
    /**
     * Retrieve authenticated user information.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Object}  [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchUser",
    value: function () {
      var _fetchUser = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        var options,
            _ref4,
            user,
            _args5 = arguments;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                _context5.next = 3;
                return this._getHello(options);

              case 3:
                _ref4 = _context5.sent;
                user = _ref4.user;
                return _context5.abrupt("return", user);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function fetchUser() {
        return _fetchUser.apply(this, arguments);
      };
    }()
    /**
     * Retrieve authenticated user information.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchHTTPApiVersion",
    value: function () {
      var _fetchHTTPApiVersion = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        var options,
            _ref5,
            http_api_version,
            _args6 = arguments;

        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                _context6.next = 3;
                return this.fetchServerInfo(options);

              case 3:
                _ref5 = _context6.sent;
                http_api_version = _ref5.http_api_version;
                return _context6.abrupt("return", http_api_version);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function fetchHTTPApiVersion() {
        return _fetchHTTPApiVersion.apply(this, arguments);
      };
    }()
    /**
     * Process batch requests, chunking them according to the batch_max_requests
     * server setting when needed.
     *
     * @param  {Array}  requests     The list of batch subrequests to perform.
     * @param  {Object} [options={}] The options object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "_batchRequests",
    value: function () {
      var _batchRequests2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(requests) {
        var _this2 = this;

        var options,
            headers,
            serverSettings,
            maxRequests,
            chunks,
            _ref6,
            responses,
            _args7 = arguments;

        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                headers = this._getHeaders(options);

                if (requests.length) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt("return", []);

              case 4:
                _context7.next = 6;
                return this.fetchServerSettings({
                  retry: this._getRetry(options)
                });

              case 6:
                serverSettings = _context7.sent;
                maxRequests = serverSettings["batch_max_requests"];

                if (!(maxRequests && requests.length > maxRequests)) {
                  _context7.next = 11;
                  break;
                }

                chunks = (0, _utils.partition)(requests, maxRequests);
                return _context7.abrupt("return", (0, _utils.pMap)(chunks, function (chunk) {
                  return _this2._batchRequests(chunk, options);
                }));

              case 11:
                _context7.next = 13;
                return this.execute({
                  // FIXME: is this really necessary, since it's also present in
                  // the "defaults"?
                  headers: headers,
                  path: (0, _endpoint["default"])("batch"),
                  method: "POST",
                  body: {
                    defaults: {
                      headers: headers
                    },
                    requests: requests
                  }
                }, {
                  retry: this._getRetry(options)
                });

              case 13:
                _ref6 = _context7.sent;
                responses = _ref6.responses;
                return _context7.abrupt("return", responses);

              case 16:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function _batchRequests(_x2) {
        return _batchRequests2.apply(this, arguments);
      };
    }()
    /**
     * Sends batch requests to the remote server.
     *
     * Note: Reserved for internal use only.
     *
     * @ignore
     * @param  {Function} fn                        The function to use for describing batch ops.
     * @param  {Object}   [options={}]              The options object.
     * @param  {Boolean}  [options.safe]            The safe option.
     * @param  {Number}   [options.retry]           The retry option.
     * @param  {String}   [options.bucket]          The bucket name option.
     * @param  {String}   [options.collection]      The collection name option.
     * @param  {Object}   [options.headers]         The headers object option.
     * @param  {Boolean}  [options.aggregate=false] Produces an aggregated result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function () {
      var _batch = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(fn) {
        var options,
            rootBatch,
            bucketBatch,
            collBatch,
            batchClient,
            responses,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                rootBatch = new KintoClientBase(this.remote, {
                  events: this.events,
                  batch: true,
                  safe: this._getSafe(options),
                  retry: this._getRetry(options)
                });

                if (options.bucket) {
                  bucketBatch = rootBatch.bucket(options.bucket);

                  if (options.collection) {
                    collBatch = bucketBatch.collection(options.collection);
                  }
                }

                batchClient = collBatch || bucketBatch || rootBatch;
                fn(batchClient);
                _context8.next = 7;
                return this._batchRequests(rootBatch._requests, options);

              case 7:
                responses = _context8.sent;

                if (!options.aggregate) {
                  _context8.next = 12;
                  break;
                }

                return _context8.abrupt("return", (0, _batch2.aggregate)(responses, rootBatch._requests));

              case 12:
                return _context8.abrupt("return", responses);

              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function batch(_x3) {
        return _batch.apply(this, arguments);
      };
    }()
    /**
     * Executes an atomic HTTP request.
     *
     * @private
     * @param  {Object}  request             The request object.
     * @param  {String}  request.path        The path to fetch, relative
     *     to the Kinto server root.
     * @param  {String}  [request.method="GET"] The method to use in the
     *     request.
     * @param  {Body}    [request.body]      The request body.
     * @param  {Object}  [request.headers={}] The request headers.
     * @param  {Object}  [options={}]        The options object.
     * @param  {Boolean} [options.raw=false] If true, resolve with full response
     * @param  {Boolean} [options.stringify=true] If true, serialize body data to
     * @param  {Number}  [options.retry=0]   The number of times to
     *     retry a request if the server responds with Retry-After.
     * JSON.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "execute",
    value: function () {
      var _execute = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(request) {
        var options,
            _options$raw,
            raw,
            _options$stringify,
            stringify,
            msg,
            result,
            _args9 = arguments;

        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
                _options$raw = options.raw, raw = _options$raw === void 0 ? false : _options$raw, _options$stringify = options.stringify, stringify = _options$stringify === void 0 ? true : _options$stringify; // If we're within a batch, add the request to the stack to send at once.

                if (!this._isBatch) {
                  _context9.next = 6;
                  break;
                }

                this._requests.push(request); // Resolve with a message in case people attempt at consuming the result
                // from within a batch operation.


                msg = "This result is generated from within a batch " + "operation and should not be consumed.";
                return _context9.abrupt("return", raw ? {
                  json: msg,
                  headers: {
                    get: function get() {}
                  }
                } : msg);

              case 6:
                _context9.next = 8;
                return this.http.request(this.remote + request.path, (0, _utils.cleanUndefinedProperties)({
                  // Limit requests to only those parts that would be allowed in
                  // a batch request -- don't pass through other fancy fetch()
                  // options like integrity, redirect, mode because they will
                  // break on a batch request.  A batch request only allows
                  // headers, method, path (above), and body.
                  method: request.method,
                  headers: request.headers,
                  body: stringify ? JSON.stringify(request.body) : request.body
                }), {
                  retry: this._getRetry(options)
                });

              case 8:
                result = _context9.sent;
                return _context9.abrupt("return", raw ? result : result.json);

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function execute(_x4) {
        return _execute.apply(this, arguments);
      };
    }()
    /**
     * Fetch some pages from a paginated list, following the `next-page`
     * header automatically until we have fetched the requested number
     * of pages. Return a response with a `.next()` method that can be
     * called to fetch more results.
     *
     * @private
     * @param  {String}  path
     *     The path to make the request to.
     * @param  {Object}  params
     *     The parameters to use when making the request.
     * @param  {String}  [params.sort="-last_modified"]
     *     The sorting order to use when fetching.
     * @param  {Object}  [params.filters={}]
     *     The filters to send in the request.
     * @param  {Number}  [params.limit=undefined]
     *     The limit to send in the request. Undefined means no limit.
     * @param  {Number}  [params.pages=undefined]
     *     The number of pages to fetch. Undefined means one page. Pass
     *     Infinity to fetch everything.
     * @param  {String}  [params.since=undefined]
     *     The ETag from which to start fetching.
     * @param  {Array}   [params.fields]
     *     Limit response to just some fields.
     * @param  {Object}  [options={}]
     *     Additional request-level parameters to use in all requests.
     * @param  {Object}  [options.headers={}]
     *     Headers to use during all requests.
     * @param  {Number}  [options.retry=0]
     *     Number of times to retry each request if the server responds
     *     with Retry-After.
     */

  }, {
    key: "paginatedList",
    value: function () {
      var _paginatedList = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(path, params) {
        var _this3 = this;

        var options,
            _sort$params,
            sort,
            filters,
            limit,
            pages,
            since,
            fields,
            query,
            querystring,
            results,
            current,
            next,
            processNextPage,
            pageResults,
            handleResponse,
            _args13 = arguments;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                options = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : {};
                // FIXME: this is called even in batch requests, which doesn't
                // make any sense (since all batch requests get a "dummy"
                // response; see execute() above).
                _sort$params = _objectSpread({
                  sort: "-last_modified"
                }, params), sort = _sort$params.sort, filters = _sort$params.filters, limit = _sort$params.limit, pages = _sort$params.pages, since = _sort$params.since, fields = _sort$params.fields; // Safety/Consistency check on ETag value.

                if (!(since && typeof since !== "string")) {
                  _context13.next = 4;
                  break;
                }

                throw new Error("Invalid value for since (".concat(since, "), should be ETag value."));

              case 4:
                query = _objectSpread({}, filters, {
                  _sort: sort,
                  _limit: limit,
                  _since: since
                });

                if (fields) {
                  query._fields = fields;
                }

                querystring = (0, _utils.qsify)(query);
                results = [], current = 0;

                next =
                /*#__PURE__*/
                function () {
                  var _ref7 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee10(nextPage) {
                    return _regenerator["default"].wrap(function _callee10$(_context10) {
                      while (1) {
                        switch (_context10.prev = _context10.next) {
                          case 0:
                            if (nextPage) {
                              _context10.next = 2;
                              break;
                            }

                            throw new Error("Pagination exhausted.");

                          case 2:
                            return _context10.abrupt("return", processNextPage(nextPage));

                          case 3:
                          case "end":
                            return _context10.stop();
                        }
                      }
                    }, _callee10);
                  }));

                  return function next(_x7) {
                    return _ref7.apply(this, arguments);
                  };
                }();

                processNextPage =
                /*#__PURE__*/
                function () {
                  var _ref8 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee11(nextPage) {
                    var headers;
                    return _regenerator["default"].wrap(function _callee11$(_context11) {
                      while (1) {
                        switch (_context11.prev = _context11.next) {
                          case 0:
                            headers = options.headers;
                            _context11.t0 = handleResponse;
                            _context11.next = 4;
                            return _this3.http.request(nextPage, {
                              headers: headers
                            });

                          case 4:
                            _context11.t1 = _context11.sent;
                            return _context11.abrupt("return", (0, _context11.t0)(_context11.t1));

                          case 6:
                          case "end":
                            return _context11.stop();
                        }
                      }
                    }, _callee11);
                  }));

                  return function processNextPage(_x8) {
                    return _ref8.apply(this, arguments);
                  };
                }();

                pageResults = function pageResults(results, nextPage, etag) {
                  // ETag string is supposed to be opaque and stored «as-is».
                  // ETag header values are quoted (because of * and W/"foo").
                  return {
                    last_modified: etag ? etag.replace(/"/g, "") : etag,
                    data: results,
                    next: next.bind(null, nextPage),
                    hasNextPage: !!nextPage
                  };
                };

                handleResponse =
                /*#__PURE__*/
                function () {
                  var _ref9 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee12(_ref10) {
                    var headers, json, nextPage, etag;
                    return _regenerator["default"].wrap(function _callee12$(_context12) {
                      while (1) {
                        switch (_context12.prev = _context12.next) {
                          case 0:
                            headers = _ref10.headers, json = _ref10.json;
                            nextPage = headers.get("Next-Page");
                            etag = headers.get("ETag");

                            if (pages) {
                              _context12.next = 5;
                              break;
                            }

                            return _context12.abrupt("return", pageResults(json.data, nextPage, etag));

                          case 5:
                            // Aggregate new results with previous ones
                            results = results.concat(json.data);
                            current += 1;

                            if (!(current >= pages || !nextPage)) {
                              _context12.next = 9;
                              break;
                            }

                            return _context12.abrupt("return", pageResults(results, nextPage, etag));

                          case 9:
                            return _context12.abrupt("return", processNextPage(nextPage));

                          case 10:
                          case "end":
                            return _context12.stop();
                        }
                      }
                    }, _callee12);
                  }));

                  return function handleResponse(_x9) {
                    return _ref9.apply(this, arguments);
                  };
                }();

                _context13.t0 = handleResponse;
                _context13.next = 15;
                return this.execute( // N.B.: This doesn't use _getHeaders, because all calls to
                // `paginatedList` are assumed to come from calls that already
                // have headers merged at e.g. the bucket or collection level.
                {
                  headers: options.headers,
                  path: path + "?" + querystring
                }, // N.B. This doesn't use _getRetry, because all calls to
                // `paginatedList` are assumed to come from calls that already
                // used `_getRetry` at e.g. the bucket or collection level.
                {
                  raw: true,
                  retry: options.retry || 0
                });

              case 15:
                _context13.t1 = _context13.sent;
                return _context13.abrupt("return", (0, _context13.t0)(_context13.t1));

              case 17:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function paginatedList(_x5, _x6) {
        return _paginatedList.apply(this, arguments);
      };
    }()
    /**
     * Lists all permissions.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number} [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object[], Error>}
     */

  }, {
    key: "listPermissions",
    value: function () {
      var _listPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14() {
        var options,
            path,
            paginationOptions,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                options = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : {};
                path = (0, _endpoint["default"])("permissions"); // Ensure the default sort parameter is something that exists in permissions
                // entries, as `last_modified` doesn't; here, we pick "id".

                paginationOptions = _objectSpread({
                  sort: "id"
                }, options);
                return _context14.abrupt("return", this.paginatedList(path, paginationOptions, {
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options)
                }));

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function listPermissions() {
        return _listPermissions.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the list of buckets.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number} [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @param  {Object} [options.filters={}] The filters object.
     * @param  {Array}  [options.fields]     Limit response to
     *     just some fields.
     * @return {Promise<Object[], Error>}
     */

  }, {
    key: "listBuckets",
    value: function () {
      var _listBuckets = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15() {
        var options,
            path,
            _args15 = arguments;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                options = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};
                path = (0, _endpoint["default"])("bucket");
                return _context15.abrupt("return", this.paginatedList(path, options, {
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options)
                }));

              case 3:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      return function listBuckets() {
        return _listBuckets.apply(this, arguments);
      };
    }()
    /**
     * Creates a new bucket on the server.
     *
     * @param  {String|null}  id                The bucket name (optional).
     * @param  {Object}       [options={}]      The options object.
     * @param  {Boolean}      [options.data]    The bucket data option.
     * @param  {Boolean}      [options.safe]    The safe option.
     * @param  {Object}       [options.headers] The headers object option.
     * @param  {Number}       [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createBucket",
    value: function () {
      var _createBucket = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(id) {
        var options,
            _options$data,
            data,
            permissions,
            path,
            _args16 = arguments;

        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                options = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};
                _options$data = options.data, data = _options$data === void 0 ? {} : _options$data, permissions = options.permissions;

                if (id != null) {
                  data.id = id;
                }

                path = data.id ? (0, _endpoint["default"])("bucket", data.id) : (0, _endpoint["default"])("bucket");
                return _context16.abrupt("return", this.execute(requests.createRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                }), {
                  retry: this._getRetry(options)
                }));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function createBucket(_x10) {
        return _createBucket.apply(this, arguments);
      };
    }()
    /**
     * Deletes a bucket from the server.
     *
     * @ignore
     * @param  {Object|String} bucket                  The bucket to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Number}        [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteBucket",
    value: function () {
      var _deleteBucket = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(bucket) {
        var options,
            bucketObj,
            path,
            _bucketObj$options,
            last_modified,
            _args17 = arguments;

        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                options = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : {};
                bucketObj = (0, _utils.toDataBody)(bucket);

                if (bucketObj.id) {
                  _context17.next = 4;
                  break;
                }

                throw new Error("A bucket id is required.");

              case 4:
                path = (0, _endpoint["default"])("bucket", bucketObj.id);
                _bucketObj$options = _objectSpread({}, bucketObj, {}, options), last_modified = _bucketObj$options.last_modified;
                return _context17.abrupt("return", this.execute(requests.deleteRequest(path, {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                }), {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function deleteBucket(_x11) {
        return _deleteBucket.apply(this, arguments);
      };
    }()
    /**
     * Deletes all buckets on the server.
     *
     * @ignore
     * @param  {Object}  [options={}]            The options object.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteBuckets",
    value: function () {
      var _deleteBuckets = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18() {
        var options,
            path,
            _args18 = arguments;
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                options = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : {};
                path = (0, _endpoint["default"])("bucket");
                return _context18.abrupt("return", this.execute(requests.deleteRequest(path, {
                  last_modified: options.last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                }), {
                  retry: this._getRetry(options)
                }));

              case 3:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      return function deleteBuckets() {
        return _deleteBuckets.apply(this, arguments);
      };
    }()
  }, {
    key: "createAccount",
    value: function () {
      var _createAccount = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19(username, password) {
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                return _context19.abrupt("return", this.execute(requests.createRequest("/accounts/".concat(username), {
                  data: {
                    password: password
                  }
                }, {
                  method: "PUT"
                })));

              case 1:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      return function createAccount(_x12, _x13) {
        return _createAccount.apply(this, arguments);
      };
    }()
  }, {
    key: "remote",
    get: function get() {
      return this._remote;
    }
    /**
     * @ignore
     */
    ,
    set: function set(url) {
      var version;

      try {
        version = url.match(/\/(v\d+)\/?$/)[1];
      } catch (err) {
        throw new Error("The remote URL must contain the version: " + url);
      }

      if (version !== SUPPORTED_PROTOCOL_VERSION) {
        throw new Error("Unsupported protocol version: ".concat(version));
      }

      this._remote = url;
      this._version = version;
    }
    /**
     * The current server protocol version, eg. `v1`.
     * @type {String}
     */

  }, {
    key: "version",
    get: function get() {
      return this._version;
    }
    /**
     * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is
     * ongoing.
     *
     * @type {Number}
     */

  }, {
    key: "backoff",
    get: function get() {
      var currentTime = new Date().getTime();

      if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {
        return this._backoffReleaseTime - currentTime;
      }

      return 0;
    }
  }]);
  return KintoClientBase;
}(), ((0, _applyDecoratedDescriptor2["default"])(_class.prototype, "fetchServerSettings", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "fetchServerSettings"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "fetchServerCapabilities", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "fetchServerCapabilities"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "fetchUser", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "fetchUser"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "fetchHTTPApiVersion", [_dec4], Object.getOwnPropertyDescriptor(_class.prototype, "fetchHTTPApiVersion"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "batch", [_dec5], Object.getOwnPropertyDescriptor(_class.prototype, "batch"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "listPermissions", [_dec6], Object.getOwnPropertyDescriptor(_class.prototype, "listPermissions"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "deleteBuckets", [_dec7], Object.getOwnPropertyDescriptor(_class.prototype, "deleteBuckets"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "createAccount", [_dec8], Object.getOwnPropertyDescriptor(_class.prototype, "createAccount"), _class.prototype)), _class));
exports["default"] = KintoClientBase;

},{"./batch":32,"./bucket":33,"./endpoint":35,"./http":37,"./requests":39,"./utils":40,"@babel/runtime/helpers/applyDecoratedDescriptor":1,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/defineProperty":7,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/interopRequireWildcard":11,"@babel/runtime/regenerator":21}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aggregate = aggregate;

/**
 * Exports batch responses as a result object.
 *
 * @private
 * @param  {Array} responses The batch subrequest responses.
 * @param  {Array} requests  The initial issued requests.
 * @return {Object}
 */
function aggregate() {
  var responses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var requests = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (responses.length !== requests.length) {
    throw new Error("Responses length should match requests one.");
  }

  var results = {
    errors: [],
    published: [],
    conflicts: [],
    skipped: []
  };
  return responses.reduce(function (acc, response, index) {
    var status = response.status;
    var request = requests[index];

    if (status >= 200 && status < 400) {
      acc.published.push(response.body);
    } else if (status === 404) {
      // Extract the id manually from request path while waiting for Kinto/kinto#818
      var regex = /(buckets|groups|collections|records)\/([^/]+)$/;
      var extracts = request.path.match(regex);
      var id = extracts.length === 3 ? extracts[2] : undefined;
      acc.skipped.push({
        id: id,
        path: request.path,
        error: response.body
      });
    } else if (status === 412) {
      acc.conflicts.push({
        // XXX: specifying the type is probably superfluous
        type: "outgoing",
        local: request.body,
        remote: response.body.details && response.body.details.existing || null
      });
    } else {
      acc.errors.push({
        path: request.path,
        sent: request,
        error: response.body
      });
    }

    return acc;
  }, results);
}

},{}],33:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));

var _utils = require("./utils");

var _collection = _interopRequireDefault(require("./collection"));

var requests = _interopRequireWildcard(require("./requests"));

var _endpoint = _interopRequireDefault(require("./endpoint"));

var _dec, _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Abstract representation of a selected bucket.
 *
 */
var Bucket = (_dec = (0, _utils.capable)(["history"]), (_class =
/*#__PURE__*/
function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient} client            The client instance.
   * @param  {String}      name              The bucket name.
   * @param  {Object}      [options={}]      The headers object option.
   * @param  {Object}      [options.headers] The headers object option.
   * @param  {Boolean}     [options.safe]    The safe option.
   * @param  {Number}      [options.retry]   The retry option.
   */
  function Bucket(client, name) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, Bucket);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * The bucket name.
     * @type {String}
     */

    this.name = name;
    /**
     * @ignore
     */

    this._isBatch = !!options.batch;
    /**
     * @ignore
     */

    this._headers = options.headers || {};
    this._retry = options.retry || 0;
    this._safe = !!options.safe;
  }
  /**
   * Get the value of "headers" for a given request, merging the
   * per-request headers with our own "default" headers.
   *
   * @private
   */


  (0, _createClass2["default"])(Bucket, [{
    key: "_getHeaders",
    value: function _getHeaders(options) {
      return _objectSpread({}, this._headers, {}, options.headers);
    }
    /**
     * Get the value of "safe" for a given request, using the
     * per-request option if present or falling back to our default
     * otherwise.
     *
     * @private
     * @param {Object} options The options for a request.
     * @returns {Boolean}
     */

  }, {
    key: "_getSafe",
    value: function _getSafe(options) {
      return _objectSpread({
        safe: this._safe
      }, options).safe;
    }
    /**
     * As _getSafe, but for "retry".
     *
     * @private
     */

  }, {
    key: "_getRetry",
    value: function _getRetry(options) {
      return _objectSpread({
        retry: this._retry
      }, options).retry;
    }
    /**
     * Selects a collection.
     *
     * @param  {String}  name              The collection name.
     * @param  {Object}  [options={}]      The options object.
     * @param  {Object}  [options.headers] The headers object option.
     * @param  {Boolean} [options.safe]    The safe option.
     * @return {Collection}
     */

  }, {
    key: "collection",
    value: function collection(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new _collection["default"](this.client, this, name, {
        batch: this._isBatch,
        headers: this._getHeaders(options),
        retry: this._getRetry(options),
        safe: this._getSafe(options)
      });
    }
    /**
     * Retrieves the ETag of the collection list, for use with the `since` filtering option.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<String, Error>}
     */

  }, {
    key: "getCollectionsTimestamp",
    value: function () {
      var _getCollectionsTimestamp = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var options,
            path,
            request,
            _ref,
            headers,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                path = (0, _endpoint["default"])("collection", this.name);
                request = {
                  headers: this._getHeaders(options),
                  path: path,
                  method: "HEAD"
                };
                _context.next = 5;
                return this.client.execute(request, {
                  raw: true,
                  retry: this._getRetry(options)
                });

              case 5:
                _ref = _context.sent;
                headers = _ref.headers;
                return _context.abrupt("return", headers.get("ETag"));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getCollectionsTimestamp() {
        return _getCollectionsTimestamp.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the ETag of the group list, for use with the `since` filtering option.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<String, Error>}
     */

  }, {
    key: "getGroupsTimestamp",
    value: function () {
      var _getGroupsTimestamp = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var options,
            path,
            request,
            _ref2,
            headers,
            _args2 = arguments;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                path = (0, _endpoint["default"])("group", this.name);
                request = {
                  headers: this._getHeaders(options),
                  path: path,
                  method: "HEAD"
                };
                _context2.next = 5;
                return this.client.execute(request, {
                  raw: true,
                  retry: this._getRetry(options)
                });

              case 5:
                _ref2 = _context2.sent;
                headers = _ref2.headers;
                return _context2.abrupt("return", headers.get("ETag"));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function getGroupsTimestamp() {
        return _getGroupsTimestamp.apply(this, arguments);
      };
    }()
    /**
     * Retrieves bucket data.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Object} [options.query]   Query parameters to pass in
     *     the request. This might be useful for features that aren't
     *     yet supported by this library.
     * @param  {Array}  [options.fields]  Limit response to
     *     just some fields.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function () {
      var _getData = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        var options,
            path,
            request,
            _ref3,
            data,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                path = (0, _endpoint["default"])("bucket", this.name);
                path = (0, _utils.addEndpointOptions)(path, options);
                request = {
                  headers: this._getHeaders(options),
                  path: path
                };
                _context3.next = 6;
                return this.client.execute(request, {
                  retry: this._getRetry(options)
                });

              case 6:
                _ref3 = _context3.sent;
                data = _ref3.data;
                return _context3.abrupt("return", data);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getData() {
        return _getData.apply(this, arguments);
      };
    }()
    /**
     * Set bucket data.
     * @param  {Object}  data                    The bucket data object.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers={}]    The headers object option.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean} [options.patch]         The patch option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function () {
      var _setData = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(data) {
        var options,
            bucket,
            bucketId,
            path,
            patch,
            permissions,
            _data$options,
            last_modified,
            request,
            _args4 = arguments;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};

                if ((0, _utils.isObject)(data)) {
                  _context4.next = 3;
                  break;
                }

                throw new Error("A bucket object is required.");

              case 3:
                bucket = _objectSpread({}, data, {
                  id: this.name
                }); // For default bucket, we need to drop the id from the data object.
                // Bug in Kinto < 3.1.1

                bucketId = bucket.id;

                if (bucket.id === "default") {
                  delete bucket.id;
                }

                path = (0, _endpoint["default"])("bucket", bucketId);
                patch = options.patch, permissions = options.permissions;
                _data$options = _objectSpread({}, data, {}, options), last_modified = _data$options.last_modified;
                request = requests.updateRequest(path, {
                  data: bucket,
                  permissions: permissions
                }, {
                  last_modified: last_modified,
                  patch: patch,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context4.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function setData(_x) {
        return _setData.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the list of history entries in the current bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listHistory",
    value: function () {
      var _listHistory = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        var options,
            path,
            _args5 = arguments;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                path = (0, _endpoint["default"])("history", this.name);
                return _context5.abrupt("return", this.client.paginatedList(path, options, {
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options)
                }));

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function listHistory() {
        return _listHistory.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the list of collections in the current bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.filters={}] The filters object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @param  {Array}  [options.fields]  Limit response to
     *     just some fields.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listCollections",
    value: function () {
      var _listCollections = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        var options,
            path,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                path = (0, _endpoint["default"])("collection", this.name);
                return _context6.abrupt("return", this.client.paginatedList(path, options, {
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options)
                }));

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function listCollections() {
        return _listCollections.apply(this, arguments);
      };
    }()
    /**
     * Creates a new collection in current bucket.
     *
     * @param  {String|undefined}  id          The collection id.
     * @param  {Object}  [options={}]          The options object.
     * @param  {Boolean} [options.safe]        The safe option.
     * @param  {Object}  [options.headers]     The headers object option.
     * @param  {Number}  [options.retry=0]     Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}  [options.permissions] The permissions object.
     * @param  {Object}  [options.data]        The data object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createCollection",
    value: function () {
      var _createCollection = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(id) {
        var options,
            permissions,
            _options$data,
            data,
            path,
            request,
            _args7 = arguments;

        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                permissions = options.permissions, _options$data = options.data, data = _options$data === void 0 ? {} : _options$data;
                data.id = id;
                path = (0, _endpoint["default"])("collection", this.name, id);
                request = requests.createRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context7.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function createCollection(_x2) {
        return _createCollection.apply(this, arguments);
      };
    }()
    /**
     * Deletes a collection from the current bucket.
     *
     * @param  {Object|String} collection              The collection to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Number}        [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteCollection",
    value: function () {
      var _deleteCollection = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(collection) {
        var options,
            collectionObj,
            id,
            _collectionObj$option,
            last_modified,
            path,
            request,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                collectionObj = (0, _utils.toDataBody)(collection);

                if (collectionObj.id) {
                  _context8.next = 4;
                  break;
                }

                throw new Error("A collection id is required.");

              case 4:
                id = collectionObj.id;
                _collectionObj$option = _objectSpread({}, collectionObj, {}, options), last_modified = _collectionObj$option.last_modified;
                path = (0, _endpoint["default"])("collection", this.name, id);
                request = requests.deleteRequest(path, {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context8.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function deleteCollection(_x3) {
        return _deleteCollection.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the list of groups in the current bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.filters={}] The filters object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @param  {Array}  [options.fields]  Limit response to
     *     just some fields.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listGroups",
    value: function () {
      var _listGroups = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9() {
        var options,
            path,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                options = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {};
                path = (0, _endpoint["default"])("group", this.name);
                return _context9.abrupt("return", this.client.paginatedList(path, options, {
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options)
                }));

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function listGroups() {
        return _listGroups.apply(this, arguments);
      };
    }()
    /**
     * Fetches a group in current bucket.
     *
     * @param  {String} id                The group id.
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @param  {Object} [options.query]   Query parameters to pass in
     *     the request. This might be useful for features that aren't
     *     yet supported by this library.
     * @param  {Array}  [options.fields]  Limit response to
     *     just some fields.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getGroup",
    value: function () {
      var _getGroup = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(id) {
        var options,
            path,
            request,
            _args10 = arguments;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
                path = (0, _endpoint["default"])("group", this.name, id);
                path = (0, _utils.addEndpointOptions)(path, options);
                request = {
                  headers: this._getHeaders(options),
                  path: path
                };
                return _context10.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function getGroup(_x4) {
        return _getGroup.apply(this, arguments);
      };
    }()
    /**
     * Creates a new group in current bucket.
     *
     * @param  {String|undefined}  id                    The group id.
     * @param  {Array<String>}     [members=[]]          The list of principals.
     * @param  {Object}            [options={}]          The options object.
     * @param  {Object}            [options.data]        The data object.
     * @param  {Object}            [options.permissions] The permissions object.
     * @param  {Boolean}           [options.safe]        The safe option.
     * @param  {Object}            [options.headers]     The headers object option.
     * @param  {Number}            [options.retry=0]     Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createGroup",
    value: function () {
      var _createGroup = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(id) {
        var members,
            options,
            data,
            path,
            permissions,
            request,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                members = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : [];
                options = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : {};
                data = _objectSpread({}, options.data, {
                  id: id,
                  members: members
                });
                path = (0, _endpoint["default"])("group", this.name, id);
                permissions = options.permissions;
                request = requests.createRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context11.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function createGroup(_x5) {
        return _createGroup.apply(this, arguments);
      };
    }()
    /**
     * Updates an existing group in current bucket.
     *
     * @param  {Object}  group                   The group object.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.data]          The data object.
     * @param  {Object}  [options.permissions]   The permissions object.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateGroup",
    value: function () {
      var _updateGroup = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(group) {
        var options,
            data,
            path,
            patch,
            permissions,
            _data$options2,
            last_modified,
            request,
            _args12 = arguments;

        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                options = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};

                if ((0, _utils.isObject)(group)) {
                  _context12.next = 3;
                  break;
                }

                throw new Error("A group object is required.");

              case 3:
                if (group.id) {
                  _context12.next = 5;
                  break;
                }

                throw new Error("A group id is required.");

              case 5:
                data = _objectSpread({}, options.data, {}, group);
                path = (0, _endpoint["default"])("group", this.name, group.id);
                patch = options.patch, permissions = options.permissions;
                _data$options2 = _objectSpread({}, data, {}, options), last_modified = _data$options2.last_modified;
                request = requests.updateRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  last_modified: last_modified,
                  patch: patch,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context12.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 11:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function updateGroup(_x6) {
        return _updateGroup.apply(this, arguments);
      };
    }()
    /**
     * Deletes a group from the current bucket.
     *
     * @param  {Object|String} group                   The group to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Number}        [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteGroup",
    value: function () {
      var _deleteGroup = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(group) {
        var options,
            groupObj,
            id,
            _groupObj$options,
            last_modified,
            path,
            request,
            _args13 = arguments;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};
                groupObj = (0, _utils.toDataBody)(group);
                id = groupObj.id;
                _groupObj$options = _objectSpread({}, groupObj, {}, options), last_modified = _groupObj$options.last_modified;
                path = (0, _endpoint["default"])("group", this.name, id);
                request = requests.deleteRequest(path, {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context13.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function deleteGroup(_x7) {
        return _deleteGroup.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the list of permissions for this bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function () {
      var _getPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14() {
        var options,
            request,
            _ref4,
            permissions,
            _args14 = arguments;

        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                options = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : {};
                request = {
                  headers: this._getHeaders(options),
                  path: (0, _endpoint["default"])("bucket", this.name)
                };
                _context14.next = 4;
                return this.client.execute(request, {
                  retry: this._getRetry(options)
                });

              case 4:
                _ref4 = _context14.sent;
                permissions = _ref4.permissions;
                return _context14.abrupt("return", permissions);

              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function getPermissions() {
        return _getPermissions.apply(this, arguments);
      };
    }()
    /**
     * Replaces all existing bucket permissions with the ones provided.
     *
     * @param  {Object}  permissions             The permissions object.
     * @param  {Object}  [options={}]            The options object
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers={}]    The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function () {
      var _setPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(permissions) {
        var options,
            path,
            last_modified,
            data,
            request,
            _args15 = arguments;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                options = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {};

                if ((0, _utils.isObject)(permissions)) {
                  _context15.next = 3;
                  break;
                }

                throw new Error("A permissions object is required.");

              case 3:
                path = (0, _endpoint["default"])("bucket", this.name);
                last_modified = options.last_modified;
                data = {
                  last_modified: last_modified
                };
                request = requests.updateRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context15.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 8:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      return function setPermissions(_x8) {
        return _setPermissions.apply(this, arguments);
      };
    }()
    /**
     * Append principals to the bucket permissions.
     *
     * @param  {Object}  permissions             The permissions object.
     * @param  {Object}  [options={}]            The options object
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "addPermissions",
    value: function () {
      var _addPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(permissions) {
        var options,
            path,
            last_modified,
            request,
            _args16 = arguments;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                options = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};

                if ((0, _utils.isObject)(permissions)) {
                  _context16.next = 3;
                  break;
                }

                throw new Error("A permissions object is required.");

              case 3:
                path = (0, _endpoint["default"])("bucket", this.name);
                last_modified = options.last_modified;
                request = requests.jsonPatchPermissionsRequest(path, permissions, "add", {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context16.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function addPermissions(_x9) {
        return _addPermissions.apply(this, arguments);
      };
    }()
    /**
     * Remove principals from the bucket permissions.
     *
     * @param  {Object}  permissions             The permissions object.
     * @param  {Object}  [options={}]            The options object
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "removePermissions",
    value: function () {
      var _removePermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(permissions) {
        var options,
            path,
            last_modified,
            request,
            _args17 = arguments;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                options = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : {};

                if ((0, _utils.isObject)(permissions)) {
                  _context17.next = 3;
                  break;
                }

                throw new Error("A permissions object is required.");

              case 3:
                path = (0, _endpoint["default"])("bucket", this.name);
                last_modified = options.last_modified;
                request = requests.jsonPatchPermissionsRequest(path, permissions, "remove", {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context17.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function removePermissions(_x10) {
        return _removePermissions.apply(this, arguments);
      };
    }()
    /**
     * Performs batch operations at the current bucket level.
     *
     * @param  {Function} fn                   The batch operation function.
     * @param  {Object}   [options={}]         The options object.
     * @param  {Object}   [options.headers]    The headers object option.
     * @param  {Boolean}  [options.safe]       The safe option.
     * @param  {Number}   [options.retry=0]    The retry option.
     * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function () {
      var _batch = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18(fn) {
        var options,
            _args18 = arguments;
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                options = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : {};
                return _context18.abrupt("return", this.client.batch(fn, {
                  bucket: this.name,
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options),
                  safe: this._getSafe(options),
                  aggregate: !!options.aggregate
                }));

              case 2:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      return function batch(_x11) {
        return _batch.apply(this, arguments);
      };
    }()
  }]);
  return Bucket;
}(), ((0, _applyDecoratedDescriptor2["default"])(_class.prototype, "listHistory", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "listHistory"), _class.prototype)), _class));
exports["default"] = Bucket;

},{"./collection":34,"./endpoint":35,"./requests":39,"./utils":40,"@babel/runtime/helpers/applyDecoratedDescriptor":1,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/defineProperty":7,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/interopRequireWildcard":11,"@babel/runtime/regenerator":21}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));

var _uuid = require("uuid");

var _utils = require("./utils");

var requests = _interopRequireWildcard(require("./requests"));

var _endpoint = _interopRequireDefault(require("./endpoint"));

var _dec, _dec2, _dec3, _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Abstract representation of a selected collection.
 *
 */
var Collection = (_dec = (0, _utils.capable)(["attachments"]), _dec2 = (0, _utils.capable)(["attachments"]), _dec3 = (0, _utils.capable)(["history"]), (_class =
/*#__PURE__*/
function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient}  client            The client instance.
   * @param  {Bucket}       bucket            The bucket instance.
   * @param  {String}       name              The collection name.
   * @param  {Object}       [options={}]      The options object.
   * @param  {Object}       [options.headers] The headers object option.
   * @param  {Boolean}      [options.safe]    The safe option.
   * @param  {Number}       [options.retry]   The retry option.
   * @param  {Boolean}      [options.batch]   (Private) Whether this
   *     Collection is operating as part of a batch.
   */
  function Collection(client, bucket, name) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Collection);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * @ignore
     */

    this.bucket = bucket;
    /**
     * The collection name.
     * @type {String}
     */

    this.name = name;
    /**
     * @ignore
     */

    this._isBatch = !!options.batch;
    /**
     * @ignore
     */

    this._retry = options.retry || 0;
    this._safe = !!options.safe; // FIXME: This is kind of ugly; shouldn't the bucket be responsible
    // for doing the merge?

    this._headers = _objectSpread({}, this.bucket._headers, {}, options.headers);
  }
  /**
   * Get the value of "headers" for a given request, merging the
   * per-request headers with our own "default" headers.
   *
   * @private
   */


  (0, _createClass2["default"])(Collection, [{
    key: "_getHeaders",
    value: function _getHeaders(options) {
      return _objectSpread({}, this._headers, {}, options.headers);
    }
    /**
     * Get the value of "safe" for a given request, using the
     * per-request option if present or falling back to our default
     * otherwise.
     *
     * @private
     * @param {Object} options The options for a request.
     * @returns {Boolean}
     */

  }, {
    key: "_getSafe",
    value: function _getSafe(options) {
      return _objectSpread({
        safe: this._safe
      }, options).safe;
    }
    /**
     * As _getSafe, but for "retry".
     *
     * @private
     */

  }, {
    key: "_getRetry",
    value: function _getRetry(options) {
      return _objectSpread({
        retry: this._retry
      }, options).retry;
    }
    /**
     * Retrieves the total number of records in this collection.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Number, Error>}
     */

  }, {
    key: "getTotalRecords",
    value: function () {
      var _getTotalRecords = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var options,
            path,
            request,
            _ref,
            headers,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name);
                request = {
                  headers: this._getHeaders(options),
                  path: path,
                  method: "HEAD"
                };
                _context.next = 5;
                return this.client.execute(request, {
                  raw: true,
                  retry: this._getRetry(options)
                });

              case 5:
                _ref = _context.sent;
                headers = _ref.headers;
                return _context.abrupt("return", parseInt(headers.get("Total-Records"), 10));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getTotalRecords() {
        return _getTotalRecords.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the ETag of the records list, for use with the `since` filtering option.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<String, Error>}
     */

  }, {
    key: "getRecordsTimestamp",
    value: function () {
      var _getRecordsTimestamp = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var options,
            path,
            request,
            _ref2,
            headers,
            _args2 = arguments;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name);
                request = {
                  headers: this._getHeaders(options),
                  path: path,
                  method: "HEAD"
                };
                _context2.next = 5;
                return this.client.execute(request, {
                  raw: true,
                  retry: this._getRetry(options)
                });

              case 5:
                _ref2 = _context2.sent;
                headers = _ref2.headers;
                return _context2.abrupt("return", headers.get("ETag"));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function getRecordsTimestamp() {
        return _getRecordsTimestamp.apply(this, arguments);
      };
    }()
    /**
     * Retrieves collection data.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Object} [options.query]   Query parameters to pass in
     *     the request. This might be useful for features that aren't
     *     yet supported by this library.
     * @param  {Array}  [options.fields]  Limit response to
     *     just some fields.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function () {
      var _getData = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        var options,
            path,
            request,
            _ref3,
            data,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                path = (0, _endpoint["default"])("collection", this.bucket.name, this.name);
                path = (0, _utils.addEndpointOptions)(path, options);
                request = {
                  headers: this._getHeaders(options),
                  path: path
                };
                _context3.next = 6;
                return this.client.execute(request, {
                  retry: this._getRetry(options)
                });

              case 6:
                _ref3 = _context3.sent;
                data = _ref3.data;
                return _context3.abrupt("return", data);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getData() {
        return _getData.apply(this, arguments);
      };
    }()
    /**
     * Set collection data.
     * @param  {Object}   data                    The collection data object.
     * @param  {Object}   [options={}]            The options object.
     * @param  {Object}   [options.headers]       The headers object option.
     * @param  {Number}   [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean}  [options.safe]          The safe option.
     * @param  {Boolean}  [options.patch]         The patch option.
     * @param  {Number}   [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function () {
      var _setData = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(data) {
        var options,
            patch,
            permissions,
            _data$options,
            last_modified,
            path,
            request,
            _args4 = arguments;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};

                if ((0, _utils.isObject)(data)) {
                  _context4.next = 3;
                  break;
                }

                throw new Error("A collection object is required.");

              case 3:
                patch = options.patch, permissions = options.permissions;
                _data$options = _objectSpread({}, data, {}, options), last_modified = _data$options.last_modified;
                path = (0, _endpoint["default"])("collection", this.bucket.name, this.name);
                request = requests.updateRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  last_modified: last_modified,
                  patch: patch,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context4.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function setData(_x) {
        return _setData.apply(this, arguments);
      };
    }()
    /**
     * Retrieves the list of permissions for this collection.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function () {
      var _getPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        var options,
            path,
            request,
            _ref4,
            permissions,
            _args5 = arguments;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                path = (0, _endpoint["default"])("collection", this.bucket.name, this.name);
                request = {
                  headers: this._getHeaders(options),
                  path: path
                };
                _context5.next = 5;
                return this.client.execute(request, {
                  retry: this._getRetry(options)
                });

              case 5:
                _ref4 = _context5.sent;
                permissions = _ref4.permissions;
                return _context5.abrupt("return", permissions);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function getPermissions() {
        return _getPermissions.apply(this, arguments);
      };
    }()
    /**
     * Replaces all existing collection permissions with the ones provided.
     *
     * @param  {Object}   permissions             The permissions object.
     * @param  {Object}   [options={}]            The options object
     * @param  {Object}   [options.headers]       The headers object option.
     * @param  {Number}   [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean}  [options.safe]          The safe option.
     * @param  {Number}   [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function () {
      var _setPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(permissions) {
        var options,
            path,
            data,
            request,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if ((0, _utils.isObject)(permissions)) {
                  _context6.next = 3;
                  break;
                }

                throw new Error("A permissions object is required.");

              case 3:
                path = (0, _endpoint["default"])("collection", this.bucket.name, this.name);
                data = {
                  last_modified: options.last_modified
                };
                request = requests.updateRequest(path, {
                  data: data,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context6.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function setPermissions(_x2) {
        return _setPermissions.apply(this, arguments);
      };
    }()
    /**
     * Append principals to the collection permissions.
     *
     * @param  {Object}  permissions             The permissions object.
     * @param  {Object}  [options={}]            The options object
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "addPermissions",
    value: function () {
      var _addPermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(permissions) {
        var options,
            path,
            last_modified,
            request,
            _args7 = arguments;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};

                if ((0, _utils.isObject)(permissions)) {
                  _context7.next = 3;
                  break;
                }

                throw new Error("A permissions object is required.");

              case 3:
                path = (0, _endpoint["default"])("collection", this.bucket.name, this.name);
                last_modified = options.last_modified;
                request = requests.jsonPatchPermissionsRequest(path, permissions, "add", {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context7.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function addPermissions(_x3) {
        return _addPermissions.apply(this, arguments);
      };
    }()
    /**
     * Remove principals from the collection permissions.
     *
     * @param  {Object}  permissions             The permissions object.
     * @param  {Object}  [options={}]            The options object
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "removePermissions",
    value: function () {
      var _removePermissions = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(permissions) {
        var options,
            path,
            last_modified,
            request,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};

                if ((0, _utils.isObject)(permissions)) {
                  _context8.next = 3;
                  break;
                }

                throw new Error("A permissions object is required.");

              case 3:
                path = (0, _endpoint["default"])("collection", this.bucket.name, this.name);
                last_modified = options.last_modified;
                request = requests.jsonPatchPermissionsRequest(path, permissions, "remove", {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context8.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function removePermissions(_x4) {
        return _removePermissions.apply(this, arguments);
      };
    }()
    /**
     * Creates a record in current collection.
     *
     * @param  {Object}  record                The record to create.
     * @param  {Object}  [options={}]          The options object.
     * @param  {Object}  [options.headers]     The headers object option.
     * @param  {Number}  [options.retry=0]     Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean} [options.safe]        The safe option.
     * @param  {Object}  [options.permissions] The permissions option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createRecord",
    value: function () {
      var _createRecord = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(record) {
        var options,
            permissions,
            path,
            request,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
                permissions = options.permissions;
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name, record.id);
                request = requests.createRequest(path, {
                  data: record,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context9.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function createRecord(_x5) {
        return _createRecord.apply(this, arguments);
      };
    }()
    /**
     * Adds an attachment to a record, creating the record when it doesn't exist.
     *
     * @param  {String}  dataURL                 The data url.
     * @param  {Object}  [record={}]             The record data.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @param  {Object}  [options.permissions]   The permissions option.
     * @param  {String}  [options.filename]      Force the attachment filename.
     * @param  {String}  [options.gzipped]       Force the attachment to be gzipped or not.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "addAttachment",
    value: function () {
      var _addAttachment = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(dataURI) {
        var record,
            options,
            permissions,
            id,
            path,
            _record$options,
            last_modified,
            addAttachmentRequest,
            _args10 = arguments;

        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                record = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
                options = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : {};
                permissions = options.permissions;
                id = record.id || _uuid.v4.v4();
                path = (0, _endpoint["default"])("attachment", this.bucket.name, this.name, id);
                _record$options = _objectSpread({}, record, {}, options), last_modified = _record$options.last_modified;
                addAttachmentRequest = requests.addAttachmentRequest(path, dataURI, {
                  data: record,
                  permissions: permissions
                }, {
                  last_modified: last_modified,
                  filename: options.filename,
                  gzipped: options.gzipped,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                _context10.next = 9;
                return this.client.execute(addAttachmentRequest, {
                  stringify: false,
                  retry: this._getRetry(options)
                });

              case 9:
                return _context10.abrupt("return", this.getRecord(id));

              case 10:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function addAttachment(_x6) {
        return _addAttachment.apply(this, arguments);
      };
    }()
    /**
     * Removes an attachment from a given record.
     *
     * @param  {Object}  recordId                The record id.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     */

  }, {
    key: "removeAttachment",
    value: function () {
      var _removeAttachment = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(recordId) {
        var options,
            last_modified,
            path,
            request,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};
                last_modified = options.last_modified;
                path = (0, _endpoint["default"])("attachment", this.bucket.name, this.name, recordId);
                request = requests.deleteRequest(path, {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context11.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function removeAttachment(_x7) {
        return _removeAttachment.apply(this, arguments);
      };
    }()
    /**
     * Updates a record in current collection.
     *
     * @param  {Object}  record                  The record to update.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @param  {Object}  [options.permissions]   The permissions option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateRecord",
    value: function () {
      var _updateRecord = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(record) {
        var options,
            permissions,
            _record$options2,
            last_modified,
            path,
            request,
            _args12 = arguments;

        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                options = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};

                if ((0, _utils.isObject)(record)) {
                  _context12.next = 3;
                  break;
                }

                throw new Error("A record object is required.");

              case 3:
                if (record.id) {
                  _context12.next = 5;
                  break;
                }

                throw new Error("A record id is required.");

              case 5:
                permissions = options.permissions;
                _record$options2 = _objectSpread({}, record, {}, options), last_modified = _record$options2.last_modified;
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name, record.id);
                request = requests.updateRequest(path, {
                  data: record,
                  permissions: permissions
                }, {
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options),
                  last_modified: last_modified,
                  patch: !!options.patch
                });
                return _context12.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 10:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function updateRecord(_x8) {
        return _updateRecord.apply(this, arguments);
      };
    }()
    /**
     * Deletes a record from the current collection.
     *
     * @param  {Object|String} record                  The record to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Number}        [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteRecord",
    value: function () {
      var _deleteRecord = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(record) {
        var options,
            recordObj,
            id,
            _recordObj$options,
            last_modified,
            path,
            request,
            _args13 = arguments;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};
                recordObj = (0, _utils.toDataBody)(record);

                if (recordObj.id) {
                  _context13.next = 4;
                  break;
                }

                throw new Error("A record id is required.");

              case 4:
                id = recordObj.id;
                _recordObj$options = _objectSpread({}, recordObj, {}, options), last_modified = _recordObj$options.last_modified;
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name, id);
                request = requests.deleteRequest(path, {
                  last_modified: last_modified,
                  headers: this._getHeaders(options),
                  safe: this._getSafe(options)
                });
                return _context13.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 9:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function deleteRecord(_x9) {
        return _deleteRecord.apply(this, arguments);
      };
    }()
    /**
     * Retrieves a record from the current collection.
     *
     * @param  {String} id                The record id to retrieve.
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @param  {Object} [options.query]   Query parameters to pass in
     *     the request. This might be useful for features that aren't
     *     yet supported by this library.
     * @param  {Array}  [options.fields]  Limit response to
     *     just some fields.
     * @param  {Number} [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getRecord",
    value: function () {
      var _getRecord = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14(id) {
        var options,
            path,
            request,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                options = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name, id);
                path = (0, _utils.addEndpointOptions)(path, options);
                request = {
                  headers: this._getHeaders(options),
                  path: path
                };
                return _context14.abrupt("return", this.client.execute(request, {
                  retry: this._getRetry(options)
                }));

              case 5:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function getRecord(_x10) {
        return _getRecord.apply(this, arguments);
      };
    }()
    /**
     * Lists records from the current collection.
     *
     * Sorting is done by passing a `sort` string option:
     *
     * - The field to order the results by, prefixed with `-` for descending.
     * Default: `-last_modified`.
     *
     * @see http://kinto.readthedocs.io/en/stable/api/1.x/sorting.html
     *
     * Filtering is done by passing a `filters` option object:
     *
     * - `{fieldname: "value"}`
     * - `{min_fieldname: 4000}`
     * - `{in_fieldname: "1,2,3"}`
     * - `{not_fieldname: 0}`
     * - `{exclude_fieldname: "0,1"}`
     *
     * @see http://kinto.readthedocs.io/en/stable/api/1.x/filtering.html
     *
     * Paginating is done by passing a `limit` option, then calling the `next()`
     * method from the resolved result object to fetch the next page, if any.
     *
     * @param  {Object}   [options={}]                    The options object.
     * @param  {Object}   [options.headers]               The headers object option.
     * @param  {Number}   [options.retry=0]               Number of retries to make
     *     when faced with transient errors.
     * @param  {Object}   [options.filters={}]            The filters object.
     * @param  {String}   [options.sort="-last_modified"] The sort field.
     * @param  {String}   [options.at]                    The timestamp to get a snapshot at.
     * @param  {String}   [options.limit=null]            The limit field.
     * @param  {String}   [options.pages=1]               The number of result pages to aggregate.
     * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.
     * @param  {Array}    [options.fields]                Limit response to just some fields.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "listRecords",
    value: function () {
      var _listRecords = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15() {
        var options,
            path,
            _args15 = arguments;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                options = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};
                path = (0, _endpoint["default"])("record", this.bucket.name, this.name);

                if (!Object.prototype.hasOwnProperty.call(options, "at")) {
                  _context15.next = 6;
                  break;
                }

                return _context15.abrupt("return", this.getSnapshot(options.at));

              case 6:
                return _context15.abrupt("return", this.client.paginatedList(path, options, {
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options)
                }));

              case 7:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      return function listRecords() {
        return _listRecords.apply(this, arguments);
      };
    }()
    /**
     * @private
     */

  }, {
    key: "isHistoryComplete",
    value: function () {
      var _isHistoryComplete = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16() {
        var _ref5, _ref5$data, oldestHistoryEntry;

        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.bucket.listHistory({
                  limit: 1,
                  filters: {
                    action: "create",
                    resource_name: "collection",
                    collection_id: this.name
                  }
                });

              case 2:
                _ref5 = _context16.sent;
                _ref5$data = (0, _slicedToArray2["default"])(_ref5.data, 1);
                oldestHistoryEntry = _ref5$data[0];
                return _context16.abrupt("return", !!oldestHistoryEntry);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function isHistoryComplete() {
        return _isHistoryComplete.apply(this, arguments);
      };
    }()
    /**
     * @private
     */

  }, {
    key: "listChangesBackTo",
    value: function () {
      var _listChangesBackTo = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(at) {
        var _ref6, changes;

        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.isHistoryComplete();

              case 2:
                if (_context17.sent) {
                  _context17.next = 4;
                  break;
                }

                throw new Error("Computing a snapshot is only possible when the full history for a " + "collection is available. Here, the history plugin seems to have " + "been enabled after the creation of the collection.");

              case 4:
                _context17.next = 6;
                return this.bucket.listHistory({
                  pages: Infinity,
                  // all pages up to target timestamp are required
                  sort: "-target.data.last_modified",
                  filters: {
                    resource_name: "record",
                    collection_id: this.name,
                    "max_target.data.last_modified": String(at) // eq. to <=

                  }
                });

              case 6:
                _ref6 = _context17.sent;
                changes = _ref6.data;
                return _context17.abrupt("return", changes);

              case 9:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function listChangesBackTo(_x11) {
        return _listChangesBackTo.apply(this, arguments);
      };
    }()
    /**
     * @private
     */

  }, {
    key: "getSnapshot",
    value: function () {
      var _getSnapshot = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18(at) {
        var changes, seenIds, snapshot, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!(!Number.isInteger(at) || at <= 0)) {
                  _context18.next = 2;
                  break;
                }

                throw new Error("Invalid argument, expected a positive integer.");

              case 2:
                _context18.next = 4;
                return this.listChangesBackTo(at);

              case 4:
                changes = _context18.sent;
                // Replay changes to compute the requested snapshot.
                seenIds = new Set();
                snapshot = [];
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context18.prev = 10;

                _loop = function _loop() {
                  var _ref7 = _step.value;
                  var action = _ref7.action,
                      record = _ref7.target.data;

                  if (action == "delete") {
                    seenIds.add(record.id); // ensure not reprocessing deleted entries

                    snapshot = snapshot.filter(function (r) {
                      return r.id !== record.id;
                    });
                  } else if (!seenIds.has(record.id)) {
                    seenIds.add(record.id);
                    snapshot.push(record);
                  }
                };

                for (_iterator = changes[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  _loop();
                }

                _context18.next = 19;
                break;

              case 15:
                _context18.prev = 15;
                _context18.t0 = _context18["catch"](10);
                _didIteratorError = true;
                _iteratorError = _context18.t0;

              case 19:
                _context18.prev = 19;
                _context18.prev = 20;

                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }

              case 22:
                _context18.prev = 22;

                if (!_didIteratorError) {
                  _context18.next = 25;
                  break;
                }

                throw _iteratorError;

              case 25:
                return _context18.finish(22);

              case 26:
                return _context18.finish(19);

              case 27:
                return _context18.abrupt("return", {
                  last_modified: String(at),
                  data: snapshot.sort(function (a, b) {
                    return b.last_modified - a.last_modified;
                  }),
                  next: function next() {
                    throw new Error("Snapshots don't support pagination");
                  },
                  hasNextPage: false,
                  totalRecords: snapshot.length
                });

              case 28:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[10, 15, 19, 27], [20,, 22, 26]]);
      }));

      return function getSnapshot(_x12) {
        return _getSnapshot.apply(this, arguments);
      };
    }()
    /**
     * Performs batch operations at the current collection level.
     *
     * @param  {Function} fn                   The batch operation function.
     * @param  {Object}   [options={}]         The options object.
     * @param  {Object}   [options.headers]    The headers object option.
     * @param  {Boolean}  [options.safe]       The safe option.
     * @param  {Number}   [options.retry]      The retry option.
     * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function () {
      var _batch = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19(fn) {
        var options,
            _args19 = arguments;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                options = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};
                return _context19.abrupt("return", this.client.batch(fn, {
                  bucket: this.bucket.name,
                  collection: this.name,
                  headers: this._getHeaders(options),
                  retry: this._getRetry(options),
                  safe: this._getSafe(options),
                  aggregate: !!options.aggregate
                }));

              case 2:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      return function batch(_x13) {
        return _batch.apply(this, arguments);
      };
    }()
  }]);
  return Collection;
}(), ((0, _applyDecoratedDescriptor2["default"])(_class.prototype, "addAttachment", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "addAttachment"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "removeAttachment", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "removeAttachment"), _class.prototype), (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "getSnapshot", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "getSnapshot"), _class.prototype)), _class));
exports["default"] = Collection;

},{"./endpoint":35,"./requests":39,"./utils":40,"@babel/runtime/helpers/applyDecoratedDescriptor":1,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/defineProperty":7,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/interopRequireWildcard":11,"@babel/runtime/helpers/slicedToArray":17,"@babel/runtime/regenerator":21,"uuid":26}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = endpoint;

/**
 * Endpoints templates.
 * @type {Object}
 */
var ENDPOINTS = {
  root: function root() {
    return "/";
  },
  batch: function batch() {
    return "/batch";
  },
  permissions: function permissions() {
    return "/permissions";
  },
  bucket: function bucket(_bucket) {
    return "/buckets" + (_bucket ? "/".concat(_bucket) : "");
  },
  history: function history(bucket) {
    return "".concat(ENDPOINTS.bucket(bucket), "/history");
  },
  collection: function collection(bucket, coll) {
    return "".concat(ENDPOINTS.bucket(bucket), "/collections") + (coll ? "/".concat(coll) : "");
  },
  group: function group(bucket, _group) {
    return "".concat(ENDPOINTS.bucket(bucket), "/groups") + (_group ? "/".concat(_group) : "");
  },
  record: function record(bucket, coll, id) {
    return "".concat(ENDPOINTS.collection(bucket, coll), "/records") + (id ? "/".concat(id) : "");
  },
  attachment: function attachment(bucket, coll, id) {
    return "".concat(ENDPOINTS.record(bucket, coll, id), "/attachment");
  }
};
/**
 * Retrieves a server enpoint by its name.
 *
 * @private
 * @param  {String}    name The endpoint name.
 * @param  {...string} args The endpoint parameters.
 * @return {String}
 */

function endpoint(name) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return ENDPOINTS[name].apply(ENDPOINTS, args);
}

},{}],36:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnparseableResponseError = exports.ServerResponse = exports.NetworkTimeoutError = exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

function _extendableBuiltin5(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

function _extendableBuiltin3(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

/**
 * Kinto server error code descriptors.
 * @type {Object}
 */
var ERROR_CODES = {
  104: "Missing Authorization Token",
  105: "Invalid Authorization Token",
  106: "Request body was not valid JSON",
  107: "Invalid request parameter",
  108: "Missing request parameter",
  109: "Invalid posted data",
  110: "Invalid Token / id",
  111: "Missing Token / id",
  112: "Content-Length header was not provided",
  113: "Request body too large",
  114: "Resource was created, updated or deleted meanwhile",
  115: "Method not allowed on this end point (hint: server may be readonly)",
  116: "Requested version not available on this server",
  117: "Client has sent too many requests",
  121: "Resource access is forbidden for this user",
  122: "Another resource violates constraint",
  201: "Service Temporary unavailable due to high load",
  202: "Service deprecated",
  999: "Internal Server Error"
};
var _default = ERROR_CODES;
exports["default"] = _default;

var NetworkTimeoutError =
/*#__PURE__*/
function (_extendableBuiltin2) {
  (0, _inherits2["default"])(NetworkTimeoutError, _extendableBuiltin2);

  function NetworkTimeoutError(url, options) {
    var _this;

    (0, _classCallCheck2["default"])(this, NetworkTimeoutError);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(NetworkTimeoutError).call(this, "Timeout while trying to access ".concat(url, " with ").concat(JSON.stringify(options))));

    if (Error.captureStackTrace) {
      Error.captureStackTrace((0, _assertThisInitialized2["default"])(_this), NetworkTimeoutError);
    }

    _this.url = url;
    _this.options = options;
    return _this;
  }

  return NetworkTimeoutError;
}(_extendableBuiltin(Error));

exports.NetworkTimeoutError = NetworkTimeoutError;

var UnparseableResponseError =
/*#__PURE__*/
function (_extendableBuiltin4) {
  (0, _inherits2["default"])(UnparseableResponseError, _extendableBuiltin4);

  function UnparseableResponseError(response, body, error) {
    var _this2;

    (0, _classCallCheck2["default"])(this, UnparseableResponseError);
    var status = response.status;
    _this2 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(UnparseableResponseError).call(this, "Response from server unparseable (HTTP ".concat(status || 0, "; ").concat(error, "): ").concat(body)));

    if (Error.captureStackTrace) {
      Error.captureStackTrace((0, _assertThisInitialized2["default"])(_this2), UnparseableResponseError);
    }

    _this2.status = status;
    _this2.response = response;
    _this2.stack = error.stack;
    _this2.error = error;
    return _this2;
  }

  return UnparseableResponseError;
}(_extendableBuiltin3(Error));
/**
 * "Error" subclass representing a >=400 response from the server.
 *
 * Whether or not this is an error depends on your application.
 *
 * The `json` field can be undefined if the server responded with an
 * empty response body. This shouldn't generally happen. Most "bad"
 * responses come with a JSON error description, or (if they're
 * fronted by a CDN or nginx or something) occasionally non-JSON
 * responses (which become UnparseableResponseErrors, above).
 */


exports.UnparseableResponseError = UnparseableResponseError;

var ServerResponse =
/*#__PURE__*/
function (_extendableBuiltin6) {
  (0, _inherits2["default"])(ServerResponse, _extendableBuiltin6);

  function ServerResponse(response, json) {
    var _this3;

    (0, _classCallCheck2["default"])(this, ServerResponse);
    var status = response.status;
    var statusText = response.statusText;
    var errnoMsg;

    if (json) {
      // Try to fill in information from the JSON error.
      statusText = json.error || statusText; // Take errnoMsg from either ERROR_CODES or json.message.

      if (json.errno && json.errno in ERROR_CODES) {
        errnoMsg = ERROR_CODES[json.errno];
      } else if (json.message) {
        errnoMsg = json.message;
      } // If we had both ERROR_CODES and json.message, and they differ,
      // combine them.


      if (errnoMsg && json.message && json.message !== errnoMsg) {
        errnoMsg += " (".concat(json.message, ")");
      }
    }

    var message = "HTTP ".concat(status, " ").concat(statusText);

    if (errnoMsg) {
      message += ": ".concat(errnoMsg);
    }

    _this3 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ServerResponse).call(this, message.trim()));

    if (Error.captureStackTrace) {
      Error.captureStackTrace((0, _assertThisInitialized2["default"])(_this3), ServerResponse);
    }

    _this3.response = response;
    _this3.data = json;
    return _this3;
  }

  return ServerResponse;
}(_extendableBuiltin5(Error));

exports.ServerResponse = ServerResponse;

},{"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":15}],37:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _utils = require("./utils");

var _errors = require("./errors");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Enhanced HTTP client for the Kinto protocol.
 * @private
 */
var HTTP =
/*#__PURE__*/
function () {
  (0, _createClass2["default"])(HTTP, null, [{
    key: "DEFAULT_REQUEST_HEADERS",

    /**
     * Default HTTP request headers applied to each outgoing request.
     *
     * @type {Object}
     */
    get: function get() {
      return {
        Accept: "application/json",
        "Content-Type": "application/json"
      };
    }
    /**
     * Default options.
     *
     * @type {Object}
     */

  }, {
    key: "defaultOptions",
    get: function get() {
      return {
        timeout: null,
        requestMode: "cors"
      };
    }
    /**
     * Constructor.
     *
     * @param {EventEmitter} events                       The event handler.
     * @param {Object}       [options={}}                 The options object.
     * @param {Number}       [options.timeout=null]       The request timeout in ms, if any (default: `null`).
     * @param {String}       [options.requestMode="cors"] The HTTP request mode (default: `"cors"`).
     */

  }]);

  function HTTP(events) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, HTTP);

    // public properties

    /**
     * The event emitter instance.
     * @type {EventEmitter}
     */
    if (!events) {
      throw new Error("No events handler provided");
    }

    this.events = events;
    /**
     * The request mode.
     * @see  https://fetch.spec.whatwg.org/#requestmode
     * @type {String}
     */

    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode;
    /**
     * The request timeout.
     * @type {Number}
     */

    this.timeout = options.timeout || HTTP.defaultOptions.timeout;
  }
  /**
   * @private
   */


  (0, _createClass2["default"])(HTTP, [{
    key: "timedFetch",
    value: function timedFetch(url, options) {
      var _this = this;

      var hasTimedout = false;
      return new Promise(function (resolve, reject) {
        // Detect if a request has timed out.
        var _timeoutId;

        if (_this.timeout) {
          _timeoutId = setTimeout(function () {
            hasTimedout = true;

            if (options && options.headers) {
              options = _objectSpread({}, options, {
                headers: (0, _utils.replaceKey)(options.headers, "authorization", "**** (suppressed)")
              });
            }

            reject(new _errors.NetworkTimeoutError(url, options));
          }, _this.timeout);
        }

        function proceedWithHandler(fn) {
          return function (arg) {
            if (!hasTimedout) {
              if (_timeoutId) {
                clearTimeout(_timeoutId);
              }

              fn(arg);
            }
          };
        }

        fetch(url, options).then(proceedWithHandler(resolve))["catch"](proceedWithHandler(reject));
      });
    }
    /**
     * @private
     */

  }, {
    key: "processResponse",
    value: function () {
      var _processResponse = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(response) {
        var status, headers, text, json;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                status = response.status, headers = response.headers;
                _context.next = 3;
                return response.text();

              case 3:
                text = _context.sent;

                if (!(text.length !== 0)) {
                  _context.next = 12;
                  break;
                }

                _context.prev = 5;
                json = JSON.parse(text);
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](5);
                throw new _errors.UnparseableResponseError(response, text, _context.t0);

              case 12:
                if (!(status >= 400)) {
                  _context.next = 14;
                  break;
                }

                throw new _errors.ServerResponse(response, json);

              case 14:
                return _context.abrupt("return", {
                  status: status,
                  json: json,
                  headers: headers
                });

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[5, 9]]);
      }));

      return function processResponse(_x) {
        return _processResponse.apply(this, arguments);
      };
    }()
    /**
     * @private
     */

  }, {
    key: "retry",
    value: function () {
      var _retry = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(url, retryAfter, request, options) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return (0, _utils.delay)(retryAfter);

              case 2:
                return _context2.abrupt("return", this.request(url, request, _objectSpread({}, options, {
                  retry: options.retry - 1
                })));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function retry(_x2, _x3, _x4, _x5) {
        return _retry.apply(this, arguments);
      };
    }()
    /**
     * Performs an HTTP request to the Kinto server.
     *
     * Resolves with an objet containing the following HTTP response properties:
     * - `{Number}  status`  The HTTP status code.
     * - `{Object}  json`    The JSON response body.
     * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.
     *
     * @param  {String} url               The URL.
     * @param  {Object} [request={}]      The request object, passed to
     *     fetch() as its options object.
     * @param  {Object} [request.headers] The request headers object (default: {})
     * @param  {Object} [options={}]      Options for making the
     *     request
     * @param  {Number} [options.retry]   Number of retries (default: 0)
     * @return {Promise}
     */

  }, {
    key: "request",
    value: function () {
      var _request2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(url) {
        var _request,
            options,
            response,
            status,
            headers,
            retryAfter,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _request = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {
                  headers: {}
                };
                options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {
                  retry: 0
                };
                // Ensure default request headers are always set
                _request.headers = _objectSpread({}, HTTP.DEFAULT_REQUEST_HEADERS, {}, _request.headers); // If a multipart body is provided, remove any custom Content-Type header as
                // the fetch() implementation will add the correct one for us.

                if (_request.body && typeof _request.body.append === "function") {
                  delete _request.headers["Content-Type"];
                }

                _request.mode = this.requestMode;
                _context3.next = 7;
                return this.timedFetch(url, _request);

              case 7:
                response = _context3.sent;
                status = response.status, headers = response.headers;

                this._checkForDeprecationHeader(headers);

                this._checkForBackoffHeader(status, headers); // Check if the server summons the client to retry after a while.


                retryAfter = this._checkForRetryAfterHeader(status, headers); // If number of allowed of retries is not exhausted, retry the same request.

                if (!(retryAfter && options.retry > 0)) {
                  _context3.next = 16;
                  break;
                }

                return _context3.abrupt("return", this.retry(url, retryAfter, _request, options));

              case 16:
                return _context3.abrupt("return", this.processResponse(response));

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function request(_x6) {
        return _request2.apply(this, arguments);
      };
    }()
  }, {
    key: "_checkForDeprecationHeader",
    value: function _checkForDeprecationHeader(headers) {
      var alertHeader = headers.get("Alert");

      if (!alertHeader) {
        return;
      }

      var alert;

      try {
        alert = JSON.parse(alertHeader);
      } catch (err) {
        console.warn("Unable to parse Alert header message", alertHeader);
        return;
      }

      console.warn(alert.message, alert.url);
      this.events.emit("deprecated", alert);
    }
  }, {
    key: "_checkForBackoffHeader",
    value: function _checkForBackoffHeader(status, headers) {
      var backoffMs;
      var backoffSeconds = parseInt(headers.get("Backoff"), 10);

      if (backoffSeconds > 0) {
        backoffMs = new Date().getTime() + backoffSeconds * 1000;
      } else {
        backoffMs = 0;
      }

      this.events.emit("backoff", backoffMs);
    }
  }, {
    key: "_checkForRetryAfterHeader",
    value: function _checkForRetryAfterHeader(status, headers) {
      var retryAfter = headers.get("Retry-After");

      if (!retryAfter) {
        return;
      }

      var delay = parseInt(retryAfter, 10) * 1000;
      retryAfter = new Date().getTime() + delay;
      this.events.emit("retry-after", retryAfter);
      return delay;
    }
  }]);
  return HTTP;
}();

exports["default"] = HTTP;

},{"./errors":36,"./utils":40,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/defineProperty":7,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/regenerator":21}],38:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _events = require("events");

var _base = _interopRequireDefault(require("./base"));

var KintoClient =
/*#__PURE__*/
function (_KintoClientBase) {
  (0, _inherits2["default"])(KintoClient, _KintoClientBase);

  function KintoClient(remote) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, KintoClient);
    var events = options.events || new _events.EventEmitter();
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(KintoClient).call(this, remote, Object.assign({
      events: events
    }, options)));
  }

  return KintoClient;
}(_base["default"]); // This is a hack to avoid Browserify to expose the above class
// at `new KintoClient()` instead of `new KintoClient.default()`.
// See https://github.com/Kinto/kinto-http.js/issues/77


exports["default"] = KintoClient;

if ((typeof module === "undefined" ? "undefined" : (0, _typeof2["default"])(module)) === "object") {
  module.exports = KintoClient;
}

},{"./base":31,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":15,"@babel/runtime/helpers/typeof":19,"events":24}],39:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRequest = createRequest;
exports.updateRequest = updateRequest;
exports.jsonPatchPermissionsRequest = jsonPatchPermissionsRequest;
exports.deleteRequest = deleteRequest;
exports.addAttachmentRequest = addAttachmentRequest;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("./utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var requestDefaults = {
  safe: false,
  // check if we should set default content type here
  headers: {},
  permissions: undefined,
  data: undefined,
  patch: false
};
/**
 * @private
 */

function safeHeader(safe, last_modified) {
  if (!safe) {
    return {};
  }

  if (last_modified) {
    return {
      "If-Match": "\"".concat(last_modified, "\"")
    };
  }

  return {
    "If-None-Match": "*"
  };
}
/**
 * @private
 */


function createRequest(path, _ref) {
  var data = _ref.data,
      permissions = _ref.permissions;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var _requestDefaults$opti = _objectSpread({}, requestDefaults, {}, options),
      headers = _requestDefaults$opti.headers,
      safe = _requestDefaults$opti.safe;

  var method = options.method || data && data.id ? "PUT" : "POST";
  return {
    method: method,
    path: path,
    headers: _objectSpread({}, headers, {}, safeHeader(safe)),
    body: {
      data: data,
      permissions: permissions
    }
  };
}
/**
 * @private
 */


function updateRequest(path, _ref2) {
  var data = _ref2.data,
      permissions = _ref2.permissions;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var _requestDefaults$opti2 = _objectSpread({}, requestDefaults, {}, options),
      headers = _requestDefaults$opti2.headers,
      safe = _requestDefaults$opti2.safe,
      patch = _requestDefaults$opti2.patch;

  var _data$options = _objectSpread({}, data, {}, options),
      last_modified = _data$options.last_modified;

  if (Object.keys((0, _utils.omit)(data, "id", "last_modified")).length === 0) {
    data = undefined;
  }

  return {
    method: patch ? "PATCH" : "PUT",
    path: path,
    headers: _objectSpread({}, headers, {}, safeHeader(safe, last_modified)),
    body: {
      data: data,
      permissions: permissions
    }
  };
}
/**
 * @private
 */


function jsonPatchPermissionsRequest(path, permissions, opType) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var _requestDefaults$opti3 = _objectSpread({}, requestDefaults, {}, options),
      headers = _requestDefaults$opti3.headers,
      safe = _requestDefaults$opti3.safe,
      last_modified = _requestDefaults$opti3.last_modified;

  var ops = [];

  for (var _i = 0, _Object$entries = Object.entries(permissions); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2),
        type = _Object$entries$_i[0],
        principals = _Object$entries$_i[1];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = principals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var principal = _step.value;
        ops.push({
          op: opType,
          path: "/permissions/".concat(type, "/").concat(principal)
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return {
    method: "PATCH",
    path: path,
    headers: _objectSpread({}, headers, {}, safeHeader(safe, last_modified), {
      "Content-Type": "application/json-patch+json"
    }),
    body: ops
  };
}
/**
 * @private
 */


function deleteRequest(path) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _requestDefaults$opti4 = _objectSpread({}, requestDefaults, {}, options),
      headers = _requestDefaults$opti4.headers,
      safe = _requestDefaults$opti4.safe,
      last_modified = _requestDefaults$opti4.last_modified;

  if (safe && !last_modified) {
    throw new Error("Safe concurrency check requires a last_modified value.");
  }

  return {
    method: "DELETE",
    path: path,
    headers: _objectSpread({}, headers, {}, safeHeader(safe, last_modified))
  };
}
/**
 * @private
 */


function addAttachmentRequest(path, dataURI) {
  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      data = _ref3.data,
      permissions = _ref3.permissions;

  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var _requestDefaults$opti5 = _objectSpread({}, requestDefaults, {}, options),
      headers = _requestDefaults$opti5.headers,
      safe = _requestDefaults$opti5.safe,
      gzipped = _requestDefaults$opti5.gzipped;

  var _data$options2 = _objectSpread({}, data, {}, options),
      last_modified = _data$options2.last_modified;

  var body = {
    data: data,
    permissions: permissions
  };
  var formData = (0, _utils.createFormData)(dataURI, body, options);
  var customPath = gzipped != null ? customPath = path + "?gzipped=" + (gzipped ? "true" : "false") : path;
  return {
    method: "POST",
    path: customPath,
    headers: _objectSpread({}, headers, {}, safeHeader(safe, last_modified)),
    body: formData
  };
}

},{"./utils":40,"@babel/runtime/helpers/defineProperty":7,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/slicedToArray":17}],40:[function(require,module,exports){
(function (Buffer){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.partition = partition;
exports.delay = delay;
exports.pMap = pMap;
exports.omit = omit;
exports.replaceKey = replaceKey;
exports.toDataBody = toDataBody;
exports.qsify = qsify;
exports.checkVersion = checkVersion;
exports.support = support;
exports.capable = capable;
exports.nobatch = nobatch;
exports.isObject = isObject;
exports.parseDataURL = parseDataURL;
exports.extractFileInfo = extractFileInfo;
exports.createFormData = createFormData;
exports.cleanUndefinedProperties = cleanUndefinedProperties;
exports.addEndpointOptions = addEndpointOptions;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Chunks an array into n pieces.
 *
 * @private
 * @param  {Array}  array
 * @param  {Number} n
 * @return {Array}
 */
function partition(array, n) {
  if (n <= 0) {
    return array;
  }

  return array.reduce(function (acc, x, i) {
    if (i === 0 || i % n === 0) {
      acc.push([x]);
    } else {
      acc[acc.length - 1].push(x);
    }

    return acc;
  }, []);
}
/**
 * Returns a Promise always resolving after the specified amount in milliseconds.
 *
 * @return Promise<void>
 */


function delay(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}
/**
 * Maps a list to promises using the provided mapping function, executes them
 * sequentially then returns a Promise resolving with ordered results obtained.
 * Think of this as a sequential Promise.all.
 *
 * @private
 * @param  {Array}    list The list to map.
 * @param  {Function} fn   The mapping function.
 * @return {Promise}
 */


function pMap(_x, _x2) {
  return _pMap.apply(this, arguments);
}
/**
 * Takes an object and returns a copy of it with the provided keys omitted.
 *
 * @private
 * @param  {Object}    obj  The source object.
 * @param  {...String} keys The keys to omit.
 * @return {Object}
 */


function _pMap() {
  _pMap = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(list, fn) {
    var results;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            results = [];
            _context2.next = 3;
            return list.reduce(
            /*#__PURE__*/
            function () {
              var _ref = (0, _asyncToGenerator2["default"])(
              /*#__PURE__*/
              _regenerator["default"].mark(function _callee(promise, entry) {
                var out;
                return _regenerator["default"].wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return promise;

                      case 2:
                        _context.next = 4;
                        return fn(entry);

                      case 4:
                        out = _context.sent;
                        results = results.concat(out);

                      case 6:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x3, _x4) {
                return _ref.apply(this, arguments);
              };
            }(), Promise.resolve());

          case 3:
            return _context2.abrupt("return", results);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _pMap.apply(this, arguments);
}

function omit(obj) {
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  return Object.keys(obj).reduce(function (acc, key) {
    if (!keys.includes(key)) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}
/**
 * Replace an object key (case insensitive) value with the specified one.
 *
 * @private
 * @param  {Object} obj
 * @param  {String} key
 * @param  {Object} value
 * @return {Object}
 */


function replaceKey(obj, key, value) {
  return Object.keys(obj).reduce(function (acc, k) {
    acc[k] = k.toLowerCase() == key.toLowerCase() ? value : obj[k];
    return acc;
  }, {});
}
/**
 * Always returns a resource data object from the provided argument.
 *
 * @private
 * @param  {Object|String} resource
 * @return {Object}
 */


function toDataBody(resource) {
  if (isObject(resource)) {
    return resource;
  }

  if (typeof resource === "string") {
    return {
      id: resource
    };
  }

  throw new Error("Invalid argument.");
}
/**
 * Transforms an object into an URL query string, stripping out any undefined
 * values.
 *
 * @param  {Object} obj
 * @return {String}
 */


function qsify(obj) {
  var encode = function encode(v) {
    return encodeURIComponent(typeof v === "boolean" ? String(v) : v);
  };

  var stripUndefined = function stripUndefined(o) {
    return JSON.parse(JSON.stringify(o));
  };

  var stripped = stripUndefined(obj);
  return Object.keys(stripped).map(function (k) {
    var ks = encode(k) + "=";

    if (Array.isArray(stripped[k])) {
      return ks + stripped[k].map(function (v) {
        return encode(v);
      }).join(",");
    } else {
      return ks + encode(stripped[k]);
    }
  }).join("&");
}
/**
 * Checks if a version is within the provided range.
 *
 * @param  {String} version    The version to check.
 * @param  {String} minVersion The minimum supported version (inclusive).
 * @param  {String} maxVersion The minimum supported version (exclusive).
 * @throws {Error} If the version is outside of the provided range.
 */


function checkVersion(version, minVersion, maxVersion) {
  var extract = function extract(str) {
    return str.split(".").map(function (x) {
      return parseInt(x, 10);
    });
  };

  var _extract = extract(version),
      _extract2 = (0, _slicedToArray2["default"])(_extract, 2),
      verMajor = _extract2[0],
      verMinor = _extract2[1];

  var _extract3 = extract(minVersion),
      _extract4 = (0, _slicedToArray2["default"])(_extract3, 2),
      minMajor = _extract4[0],
      minMinor = _extract4[1];

  var _extract5 = extract(maxVersion),
      _extract6 = (0, _slicedToArray2["default"])(_extract5, 2),
      maxMajor = _extract6[0],
      maxMinor = _extract6[1];

  var checks = [verMajor < minMajor, verMajor === minMajor && verMinor < minMinor, verMajor > maxMajor, verMajor === maxMajor && verMinor >= maxMinor];

  if (checks.some(function (x) {
    return x;
  })) {
    throw new Error("Version ".concat(version, " doesn't satisfy ").concat(minVersion, " <= x < ").concat(maxVersion));
  }
}
/**
 * Generates a decorator function ensuring a version check is performed against
 * the provided requirements before executing it.
 *
 * @param  {String} min The required min version (inclusive).
 * @param  {String} max The required max version (inclusive).
 * @return {Function}
 */


function support(min, max) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          // "this" is the current instance which its method is decorated.
          var client = "client" in _this ? _this.client : _this;
          return client.fetchHTTPApiVersion().then(function (version) {
            return checkVersion(version, min, max);
          }).then(function () {
            return fn.apply(_this, args);
          });
        };

        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}
/**
 * Generates a decorator function ensuring that the specified capabilities are
 * available on the server before executing it.
 *
 * @param  {Array<String>} capabilities The required capabilities.
 * @return {Function}
 */


function capable(capabilities) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this2 = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          // "this" is the current instance which its method is decorated.
          var client = "client" in _this2 ? _this2.client : _this2;
          return client.fetchServerCapabilities().then(function (available) {
            var missing = capabilities.filter(function (c) {
              return !(c in available);
            });

            if (missing.length > 0) {
              var missingStr = missing.join(", ");
              throw new Error("Required capabilities ".concat(missingStr, " not present on server"));
            }
          }).then(function () {
            return fn.apply(_this2, args);
          });
        };

        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}
/**
 * Generates a decorator function ensuring an operation is not performed from
 * within a batch request.
 *
 * @param  {String} message The error message to throw.
 * @return {Function}
 */


function nobatch(message) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this3 = this;

        var wrappedMethod = function wrappedMethod() {
          // "this" is the current instance which its method is decorated.
          if (_this3._isBatch) {
            throw new Error(message);
          }

          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return fn.apply(_this3, args);
        };

        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}
/**
 * Returns true if the specified value is an object (i.e. not an array nor null).
 * @param  {Object} thing The value to inspect.
 * @return {bool}
 */


function isObject(thing) {
  return (0, _typeof2["default"])(thing) === "object" && thing !== null && !Array.isArray(thing);
}
/**
 * Parses a data url.
 * @param  {String} dataURL The data url.
 * @return {Object}
 */


function parseDataURL(dataURL) {
  var regex = /^data:(.*);base64,(.*)/;
  var match = dataURL.match(regex);

  if (!match) {
    throw new Error("Invalid data-url: ".concat(String(dataURL).substr(0, 32), "..."));
  }

  var props = match[1];
  var base64 = match[2];

  var _props$split = props.split(";"),
      _props$split2 = (0, _toArray2["default"])(_props$split),
      type = _props$split2[0],
      rawParams = _props$split2.slice(1);

  var params = rawParams.reduce(function (acc, param) {
    var _param$split = param.split("="),
        _param$split2 = (0, _slicedToArray2["default"])(_param$split, 2),
        key = _param$split2[0],
        value = _param$split2[1];

    return _objectSpread({}, acc, (0, _defineProperty2["default"])({}, key, value));
  }, {});
  return _objectSpread({}, params, {
    type: type,
    base64: base64
  });
}
/**
 * Extracts file information from a data url.
 * @param  {String} dataURL The data url.
 * @return {Object}
 */


function extractFileInfo(dataURL) {
  var _parseDataURL = parseDataURL(dataURL),
      name = _parseDataURL.name,
      type = _parseDataURL.type,
      base64 = _parseDataURL.base64;

  var binary = atob(base64);
  var array = [];

  for (var i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  }

  var blob;

  if (typeof Blob !== "undefined") {
    // Running in a browser environment.
    blob = new Blob([new Uint8Array(array)], {
      type: type
    });
  } else {
    // In NodeJS. Blob is not available.
    blob = Buffer.from(array);
  }

  return {
    blob: blob,
    name: name
  };
}
/**
 * Creates a FormData instance from a data url and an existing JSON response
 * body.
 * @param  {String} dataURL            The data url.
 * @param  {Object} body               The response body.
 * @param  {Object} [options={}]       The options object.
 * @param  {Object} [options.filename] Force attachment file name.
 * @return {FormData}
 */


function createFormData(dataURL, body) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$filename = options.filename,
      filename = _options$filename === void 0 ? "untitled" : _options$filename;

  var _extractFileInfo = extractFileInfo(dataURL),
      blob = _extractFileInfo.blob,
      name = _extractFileInfo.name;

  var formData = new FormData();
  formData.append("attachment", blob, name || filename);

  for (var property in body) {
    if (typeof body[property] !== "undefined") {
      formData.append(property, JSON.stringify(body[property]));
    }
  }

  return formData;
}
/**
 * Clones an object with all its undefined keys removed.
 * @private
 */


function cleanUndefinedProperties(obj) {
  var result = {};

  for (var key in obj) {
    if (typeof obj[key] !== "undefined") {
      result[key] = obj[key];
    }
  }

  return result;
}
/**
 * Handle common query parameters for Kinto requests.
 *
 * @param  {String}  [path]  The endpoint base path.
 * @param  {Array}   [options.fields]    Fields to limit the
 *   request to.
 * @param  {Object}  [options.query={}]  Additional query arguments.
 */


function addEndpointOptions(path) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var query = _objectSpread({}, options.query);

  if (options.fields) {
    query._fields = options.fields;
  }

  var queryString = qsify(query);

  if (queryString) {
    return path + "?" + queryString;
  }

  return path;
}

}).call(this,require("buffer").Buffer)

},{"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/defineProperty":7,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/slicedToArray":17,"@babel/runtime/helpers/toArray":18,"@babel/runtime/helpers/typeof":19,"@babel/runtime/regenerator":21,"buffer":23}]},{},[38])(38)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcHBseURlY29yYXRlZERlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsInNyYy9iYXNlLmpzIiwic3JjL2JhdGNoLmpzIiwic3JjL2J1Y2tldC5qcyIsInNyYy9jb2xsZWN0aW9uLmpzIiwic3JjL2VuZHBvaW50LmpzIiwic3JjL2Vycm9ycy5qcyIsInNyYy9odHRwLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3JlcXVlc3RzLmpzIiwic3JjL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0dEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQVNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUdBOzs7O0FBSU8sSUFBTSwwQkFBMEIsR0FBRyxJQUFuQztBQUVQ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QUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsS0FBRCxDQUF6Qjs7QUFDQSxNQUFJLFdBQUosRUFBaUI7QUFDZixXQUFPLElBQUksR0FBRyxHQUFQLEdBQWEsV0FBcEI7QUFDRDs7QUFDRCxTQUFPLElBQVA7QUFDRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICB2YXIgZGVzYyA9IHt9O1xuICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gIH0pO1xuICBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTtcbiAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gIGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikge1xuICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICB9XG5cbiAgZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7XG4gIH0sIGRlc2MpO1xuXG4gIGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkge1xuICAgIGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwO1xuICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgIGRlc2MgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRlc2M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcjsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307XG5cbiAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcbiAgICByZXR1cm4gbmV3T2JqO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHYxID0gcmVxdWlyZSgnLi92MScpO1xudmFyIHY0ID0gcmVxdWlyZSgnLi92NCcpO1xuXG52YXIgdXVpZCA9IHY0O1xudXVpZC52MSA9IHYxO1xudXVpZC52NCA9IHY0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXV0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge1xuICBwYXJ0aXRpb24sXG4gIHBNYXAsXG4gIHFzaWZ5LFxuICBzdXBwb3J0LFxuICBub2JhdGNoLFxuICB0b0RhdGFCb2R5LFxuICBjbGVhblVuZGVmaW5lZFByb3BlcnRpZXMsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgSFRUUCBmcm9tIFwiLi9odHRwXCI7XG5pbXBvcnQgZW5kcG9pbnQgZnJvbSBcIi4vZW5kcG9pbnRcIjtcbmltcG9ydCAqIGFzIHJlcXVlc3RzIGZyb20gXCIuL3JlcXVlc3RzXCI7XG5pbXBvcnQgeyBhZ2dyZWdhdGUgfSBmcm9tIFwiLi9iYXRjaFwiO1xuaW1wb3J0IEJ1Y2tldCBmcm9tIFwiLi9idWNrZXRcIjtcbmltcG9ydCB7IGNhcGFibGUgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTiA9IFwidjFcIjtcblxuLyoqXG4gKiBIaWdoIGxldmVsIEhUVFAgY2xpZW50IGZvciB0aGUgS2ludG8gQVBJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjbGllbnQgPSBuZXcgS2ludG9DbGllbnQoXCJodHRwczovL2tpbnRvLmRldi5tb3phd3MubmV0L3YxXCIpO1xuICogY2xpZW50LmJ1Y2tldChcImRlZmF1bHRcIilcbiAqICAgIC5jb2xsZWN0aW9uKFwibXktYmxvZ1wiKVxuICogICAgLmNyZWF0ZVJlY29yZCh7dGl0bGU6IFwiRmlyc3QgYXJ0aWNsZVwifSlcbiAqICAgLnRoZW4oY29uc29sZS5sb2cuYmluZChjb25zb2xlKSlcbiAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbnRvQ2xpZW50QmFzZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICByZW1vdGUgIFRoZSByZW1vdGUgVVJMLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zPXt9XSAgICAgICAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICBbb3B0aW9ucy5zYWZlPXRydWVdICAgICAgICAgICBBZGRzIGNvbmN1cnJlbmN5IGhlYWRlcnMgdG8gZXZlcnkgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSAge0V2ZW50RW1pdHRlcn0gW29wdGlvbnMuZXZlbnRzPUV2ZW50RW1pdHRlcl0gVGhlIGV2ZW50cyBoYW5kbGVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zLmhlYWRlcnM9e31dICAgICAgICAgIFRoZSBrZXktdmFsdWUgaGVhZGVycyB0byBwYXNzIHRvIGVhY2ggcmVxdWVzdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgICAgICAgICBOdW1iZXIgb2YgcmV0cmllcyB3aGVuIHJlcXVlc3QgZmFpbHMgKGRlZmF1bHQ6IDApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgW29wdGlvbnMuYnVja2V0PVwiZGVmYXVsdFwiXSAgICBUaGUgZGVmYXVsdCBidWNrZXQgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIFtvcHRpb25zLnJlcXVlc3RNb2RlPVwiY29yc1wiXSAgVGhlIEhUVFAgcmVxdWVzdCBtb2RlIChmcm9tIEVTNiBmZXRjaCBzcGVjKS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICBbb3B0aW9ucy50aW1lb3V0PW51bGxdICAgICAgICBUaGUgcmVxdWVzdCB0aW1lb3V0IGluIG1zLCBpZiBhbnkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW1vdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgcmVtb3RlICE9PSBcInN0cmluZ1wiIHx8ICFyZW1vdGUubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlbW90ZSBVUkw6IFwiICsgcmVtb3RlKTtcbiAgICB9XG4gICAgaWYgKHJlbW90ZVtyZW1vdGUubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgICByZW1vdGUgPSByZW1vdGUuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICB0aGlzLl9iYWNrb2ZmUmVsZWFzZVRpbWUgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuICAgIHRoaXMuX3JldHJ5ID0gb3B0aW9ucy5yZXRyeSB8fCAwO1xuICAgIHRoaXMuX3NhZmUgPSAhIW9wdGlvbnMuc2FmZTtcbiAgICB0aGlzLl9oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXG4gICAgLy8gcHVibGljIHByb3BlcnRpZXNcbiAgICAvKipcbiAgICAgKiBUaGUgcmVtb3RlIHNlcnZlciBiYXNlIFVSTC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2VydmVyIGluZm9ybWF0aW9uLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zZXJ2ZXJJbmZvID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS4gU2hvdWxkIGNvbXBseSB3aXRoIHRoZSBgRXZlbnRFbWl0dGVyYFxuICAgICAqIGludGVyZmFjZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGUge0NsYXNzfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG5cbiAgICBjb25zdCB7IHJlcXVlc3RNb2RlLCB0aW1lb3V0IH0gPSBvcHRpb25zO1xuICAgIC8qKlxuICAgICAqIFRoZSBIVFRQIGluc3RhbmNlLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAdHlwZSB7SFRUUH1cbiAgICAgKi9cbiAgICB0aGlzLmh0dHAgPSBuZXcgSFRUUCh0aGlzLmV2ZW50cywgeyByZXF1ZXN0TW9kZSwgdGltZW91dCB9KTtcbiAgICB0aGlzLl9yZWdpc3RlckhUVFBFdmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVtb3RlIGVuZHBvaW50IGJhc2UgVVJMLiBTZXR0aW5nIHRoZSB2YWx1ZSB3aWxsIGFsc28gZXh0cmFjdCBhbmRcbiAgICogdmFsaWRhdGUgdGhlIHZlcnNpb24uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcmVtb3RlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGU7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc2V0IHJlbW90ZSh1cmwpIHtcbiAgICBsZXQgdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbiA9IHVybC5tYXRjaCgvXFwvKHZcXGQrKVxcLz8kLylbMV07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVtb3RlIFVSTCBtdXN0IGNvbnRhaW4gdGhlIHZlcnNpb246IFwiICsgdXJsKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb24gIT09IFNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3RlID0gdXJsO1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNlcnZlciBwcm90b2NvbCB2ZXJzaW9uLCBlZy4gYHYxYC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2tvZmYgcmVtYWluaW5nIHRpbWUsIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gemVybyBpZiBubyBiYWNrb2ZmIGlzXG4gICAqIG9uZ29pbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYmFja29mZigpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmICh0aGlzLl9iYWNrb2ZmUmVsZWFzZVRpbWUgJiYgY3VycmVudFRpbWUgPCB0aGlzLl9iYWNrb2ZmUmVsZWFzZVRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9iYWNrb2ZmUmVsZWFzZVRpbWUgLSBjdXJyZW50VGltZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIEhUVFAgZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVySFRUUEV2ZW50cygpIHtcbiAgICAvLyBQcmV2ZW50IHJlZ2lzdGVyaW5nIGV2ZW50IGZyb20gYSBiYXRjaCBjbGllbnQgaW5zdGFuY2VcbiAgICBpZiAoIXRoaXMuX2lzQmF0Y2gpIHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKFwiYmFja29mZlwiLCBiYWNrb2ZmTXMgPT4ge1xuICAgICAgICB0aGlzLl9iYWNrb2ZmUmVsZWFzZVRpbWUgPSBiYWNrb2ZmTXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBidWNrZXQgb2JqZWN0IHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICAgICAgICAgICAgVGhlIGJ1Y2tldCBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICBUaGUgcmVzdWx0aW5nIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeV0gICBUaGUgcmVzdWx0aW5nIHJldHJ5IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gVGhlIGV4dGVuZGVkIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7QnVja2V0fVxuICAgKi9cbiAgYnVja2V0KG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgQnVja2V0KHRoaXMsIG5hbWUsIHtcbiAgICAgIGJhdGNoOiB0aGlzLl9pc0JhdGNoLFxuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGNsaWVudCBcImhlYWRlcnNcIiBmb3IgZXZlcnkgcmVxdWVzdCwgdXBkYXRpbmcgcHJldmlvdXMgaGVhZGVycyAoaWYgYW55KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgVGhlIGhlYWRlcnMgdG8gbWVyZ2Ugd2l0aCBleGlzdGluZyBvbmVzLlxuICAgKi9cbiAgc2V0SGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5faGVhZGVycyA9IHtcbiAgICAgIC4uLnRoaXMuX2hlYWRlcnMsXG4gICAgICAuLi5oZWFkZXJzLFxuICAgIH07XG4gICAgdGhpcy5zZXJ2ZXJJbmZvID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIFwiaGVhZGVyc1wiIGZvciBhIGdpdmVuIHJlcXVlc3QsIG1lcmdpbmcgdGhlXG4gICAqIHBlci1yZXF1ZXN0IGhlYWRlcnMgd2l0aCBvdXIgb3duIFwiZGVmYXVsdFwiIGhlYWRlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB1bmxpa2Ugb3RoZXIgb3B0aW9ucywgaGVhZGVycyBhcmVuJ3Qgb3ZlcnJpZGRlbiwgYnV0XG4gICAqIG1lcmdlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgYSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgX2dldEhlYWRlcnMob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLl9oZWFkZXJzLFxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBcInNhZmVcIiBmb3IgYSBnaXZlbiByZXF1ZXN0LCB1c2luZyB0aGVcbiAgICogcGVyLXJlcXVlc3Qgb3B0aW9uIGlmIHByZXNlbnQgb3IgZmFsbGluZyBiYWNrIHRvIG91ciBkZWZhdWx0XG4gICAqIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIGEgcmVxdWVzdC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBfZ2V0U2FmZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHsgc2FmZTogdGhpcy5fc2FmZSwgLi4ub3B0aW9ucyB9LnNhZmU7XG4gIH1cblxuICAvKipcbiAgICogQXMgX2dldFNhZmUsIGJ1dCBmb3IgXCJyZXRyeVwiLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJldHJ5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4geyByZXRyeTogdGhpcy5fcmV0cnksIC4uLm9wdGlvbnMgfS5yZXRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNlcnZlcidzIFwiaGVsbG9cIiBlbmRwb2ludC4gVGhpcyBlbmRwb2ludCByZXZlYWxzXG4gICAqIHNlcnZlciBjYXBhYmlsaXRpZXMgYW5kIHNldHRpbmdzIGFzIHdlbGwgYXMgdGVsbGluZyB0aGUgY2xpZW50XG4gICAqIFwid2hvIHRoZXkgYXJlXCIgYWNjb3JkaW5nIHRvIHRoZWlyIGdpdmVuIGF1dGhvcml6YXRpb24gaGVhZGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dIFRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnM9e31dIEhlYWRlcnMgdG8gdXNlIHdoZW4gbWFraW5nXG4gICAqICAgICB0aGlzIHJlcXVlc3QuXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgX2dldEhlbGxvKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnJlbW90ZSArIGVuZHBvaW50KFwicm9vdFwiKTtcbiAgICBjb25zdCB7IGpzb24gfSA9IGF3YWl0IHRoaXMuaHR0cC5yZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHsgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSB9LFxuICAgICAgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfVxuICAgICk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHNlcnZlciBpbmZvcm1hdGlvbiBhbmQgcGVyc2lzdCB0aGVtIGxvY2FsbHkuIFRoaXMgb3BlcmF0aW9uIGlzXG4gICAqIHVzdWFsbHkgcGVyZm9ybWVkIGEgc2luZ2xlIHRpbWUgZHVyaW5nIHRoZSBpbnN0YW5jZSBsaWZlY3ljbGUuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeT0wXSAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGZldGNoU2VydmVySW5mbyhvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXJJbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJJbmZvO1xuICAgIH1cbiAgICB0aGlzLnNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRIZWxsbyh7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9KTtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBLaW50byBzZXJ2ZXIgc2V0dGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeT0wXSAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIEBub2JhdGNoKFwiVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCB3aXRoaW4gYSBiYXRjaCBvcGVyYXRpb24uXCIpXG4gIGFzeW5jIGZldGNoU2VydmVyU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IGF3YWl0IHRoaXMuZmV0Y2hTZXJ2ZXJJbmZvKG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXR0aW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBzZXJ2ZXIgY2FwYWJpbGl0aWVzIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gVGhlIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF0gICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBAbm9iYXRjaChcIlRoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aGluIGEgYmF0Y2ggb3BlcmF0aW9uLlwiKVxuICBhc3luYyBmZXRjaFNlcnZlckNhcGFiaWxpdGllcyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNhcGFiaWxpdGllcyB9ID0gYXdhaXQgdGhpcy5mZXRjaFNlcnZlckluZm8ob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzPXt9XSBIZWFkZXJzIHRvIHVzZSB3aGVuIG1ha2luZ1xuICAgKiAgICAgdGhpcyByZXF1ZXN0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeT0wXSAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIEBub2JhdGNoKFwiVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCB3aXRoaW4gYSBiYXRjaCBvcGVyYXRpb24uXCIpXG4gIGFzeW5jIGZldGNoVXNlcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHVzZXIgfSA9IGF3YWl0IHRoaXMuX2dldEhlbGxvKG9wdGlvbnMpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGF1dGhlbnRpY2F0ZWQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dIFRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQG5vYmF0Y2goXCJUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhpbiBhIGJhdGNoIG9wZXJhdGlvbi5cIilcbiAgYXN5bmMgZmV0Y2hIVFRQQXBpVmVyc2lvbihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGh0dHBfYXBpX3ZlcnNpb24gfSA9IGF3YWl0IHRoaXMuZmV0Y2hTZXJ2ZXJJbmZvKG9wdGlvbnMpO1xuICAgIHJldHVybiBodHRwX2FwaV92ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYmF0Y2ggcmVxdWVzdHMsIGNodW5raW5nIHRoZW0gYWNjb3JkaW5nIHRvIHRoZSBiYXRjaF9tYXhfcmVxdWVzdHNcbiAgICogc2VydmVyIHNldHRpbmcgd2hlbiBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSAgcmVxdWVzdHMgICAgIFRoZSBsaXN0IG9mIGJhdGNoIHN1YnJlcXVlc3RzIHRvIHBlcmZvcm0uXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIF9iYXRjaFJlcXVlc3RzKHJlcXVlc3RzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKTtcbiAgICBpZiAoIXJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJTZXR0aW5ncyA9IGF3YWl0IHRoaXMuZmV0Y2hTZXJ2ZXJTZXR0aW5ncyh7XG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UmVxdWVzdHMgPSBzZXJ2ZXJTZXR0aW5nc1tcImJhdGNoX21heF9yZXF1ZXN0c1wiXTtcbiAgICBpZiAobWF4UmVxdWVzdHMgJiYgcmVxdWVzdHMubGVuZ3RoID4gbWF4UmVxdWVzdHMpIHtcbiAgICAgIGNvbnN0IGNodW5rcyA9IHBhcnRpdGlvbihyZXF1ZXN0cywgbWF4UmVxdWVzdHMpO1xuICAgICAgcmV0dXJuIHBNYXAoY2h1bmtzLCBjaHVuayA9PiB0aGlzLl9iYXRjaFJlcXVlc3RzKGNodW5rLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzcG9uc2VzIH0gPSBhd2FpdCB0aGlzLmV4ZWN1dGUoXG4gICAgICB7XG4gICAgICAgIC8vIEZJWE1FOiBpcyB0aGlzIHJlYWxseSBuZWNlc3NhcnksIHNpbmNlIGl0J3MgYWxzbyBwcmVzZW50IGluXG4gICAgICAgIC8vIHRoZSBcImRlZmF1bHRzXCI/XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHBhdGg6IGVuZHBvaW50KFwiYmF0Y2hcIiksXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBkZWZhdWx0czogeyBoZWFkZXJzIH0sXG4gICAgICAgICAgcmVxdWVzdHMsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBiYXRjaCByZXF1ZXN0cyB0byB0aGUgcmVtb3RlIHNlcnZlci5cbiAgICpcbiAgICogTm90ZTogUmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiB0byB1c2UgZm9yIGRlc2NyaWJpbmcgYmF0Y2ggb3BzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnM9e31dICAgICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5zYWZlXSAgICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLnJldHJ5XSAgICAgICAgICAgVGhlIHJldHJ5IG9wdGlvbi5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIFtvcHRpb25zLmJ1Y2tldF0gICAgICAgICAgVGhlIGJ1Y2tldCBuYW1lIG9wdGlvbi5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIFtvcHRpb25zLmNvbGxlY3Rpb25dICAgICAgVGhlIGNvbGxlY3Rpb24gbmFtZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5hZ2dyZWdhdGU9ZmFsc2VdIFByb2R1Y2VzIGFuIGFnZ3JlZ2F0ZWQgcmVzdWx0IG9iamVjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIEBub2JhdGNoKFwiQ2FuJ3QgdXNlIGJhdGNoIHdpdGhpbiBhIGJhdGNoIVwiKVxuICBhc3luYyBiYXRjaChmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdEJhdGNoID0gbmV3IEtpbnRvQ2xpZW50QmFzZSh0aGlzLnJlbW90ZSwge1xuICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cyxcbiAgICAgIGJhdGNoOiB0cnVlLFxuICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSxcbiAgICB9KTtcbiAgICBsZXQgYnVja2V0QmF0Y2gsIGNvbGxCYXRjaDtcbiAgICBpZiAob3B0aW9ucy5idWNrZXQpIHtcbiAgICAgIGJ1Y2tldEJhdGNoID0gcm9vdEJhdGNoLmJ1Y2tldChvcHRpb25zLmJ1Y2tldCk7XG4gICAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uKSB7XG4gICAgICAgIGNvbGxCYXRjaCA9IGJ1Y2tldEJhdGNoLmNvbGxlY3Rpb24ob3B0aW9ucy5jb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmF0Y2hDbGllbnQgPSBjb2xsQmF0Y2ggfHwgYnVja2V0QmF0Y2ggfHwgcm9vdEJhdGNoO1xuICAgIGZuKGJhdGNoQ2xpZW50KTtcbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCB0aGlzLl9iYXRjaFJlcXVlc3RzKHJvb3RCYXRjaC5fcmVxdWVzdHMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmFnZ3JlZ2F0ZSkge1xuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZShyZXNwb25zZXMsIHJvb3RCYXRjaC5fcmVxdWVzdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiBhdG9taWMgSFRUUCByZXF1ZXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICByZXF1ZXN0ICAgICAgICAgICAgIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgcmVxdWVzdC5wYXRoICAgICAgICBUaGUgcGF0aCB0byBmZXRjaCwgcmVsYXRpdmVcbiAgICogICAgIHRvIHRoZSBLaW50byBzZXJ2ZXIgcm9vdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3JlcXVlc3QubWV0aG9kPVwiR0VUXCJdIFRoZSBtZXRob2QgdG8gdXNlIGluIHRoZVxuICAgKiAgICAgcmVxdWVzdC5cbiAgICogQHBhcmFtICB7Qm9keX0gICAgW3JlcXVlc3QuYm9keV0gICAgICBUaGUgcmVxdWVzdCBib2R5LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbcmVxdWVzdC5oZWFkZXJzPXt9XSBUaGUgcmVxdWVzdCBoZWFkZXJzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMucmF3PWZhbHNlXSBJZiB0cnVlLCByZXNvbHZlIHdpdGggZnVsbCByZXNwb25zZVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zdHJpbmdpZnk9dHJ1ZV0gSWYgdHJ1ZSwgc2VyaWFsaXplIGJvZHkgZGF0YSB0b1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeT0wXSAgIFRoZSBudW1iZXIgb2YgdGltZXMgdG9cbiAgICogICAgIHJldHJ5IGEgcmVxdWVzdCBpZiB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggUmV0cnktQWZ0ZXIuXG4gICAqIEpTT04uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBleGVjdXRlKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcmF3ID0gZmFsc2UsIHN0cmluZ2lmeSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgLy8gSWYgd2UncmUgd2l0aGluIGEgYmF0Y2gsIGFkZCB0aGUgcmVxdWVzdCB0byB0aGUgc3RhY2sgdG8gc2VuZCBhdCBvbmNlLlxuICAgIGlmICh0aGlzLl9pc0JhdGNoKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgLy8gUmVzb2x2ZSB3aXRoIGEgbWVzc2FnZSBpbiBjYXNlIHBlb3BsZSBhdHRlbXB0IGF0IGNvbnN1bWluZyB0aGUgcmVzdWx0XG4gICAgICAvLyBmcm9tIHdpdGhpbiBhIGJhdGNoIG9wZXJhdGlvbi5cbiAgICAgIGNvbnN0IG1zZyA9XG4gICAgICAgIFwiVGhpcyByZXN1bHQgaXMgZ2VuZXJhdGVkIGZyb20gd2l0aGluIGEgYmF0Y2ggXCIgK1xuICAgICAgICBcIm9wZXJhdGlvbiBhbmQgc2hvdWxkIG5vdCBiZSBjb25zdW1lZC5cIjtcbiAgICAgIHJldHVybiByYXcgPyB7IGpzb246IG1zZywgaGVhZGVyczogeyBnZXQoKSB7fSB9IH0gOiBtc2c7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaHR0cC5yZXF1ZXN0KFxuICAgICAgdGhpcy5yZW1vdGUgKyByZXF1ZXN0LnBhdGgsXG4gICAgICBjbGVhblVuZGVmaW5lZFByb3BlcnRpZXMoe1xuICAgICAgICAvLyBMaW1pdCByZXF1ZXN0cyB0byBvbmx5IHRob3NlIHBhcnRzIHRoYXQgd291bGQgYmUgYWxsb3dlZCBpblxuICAgICAgICAvLyBhIGJhdGNoIHJlcXVlc3QgLS0gZG9uJ3QgcGFzcyB0aHJvdWdoIG90aGVyIGZhbmN5IGZldGNoKClcbiAgICAgICAgLy8gb3B0aW9ucyBsaWtlIGludGVncml0eSwgcmVkaXJlY3QsIG1vZGUgYmVjYXVzZSB0aGV5IHdpbGxcbiAgICAgICAgLy8gYnJlYWsgb24gYSBiYXRjaCByZXF1ZXN0LiAgQSBiYXRjaCByZXF1ZXN0IG9ubHkgYWxsb3dzXG4gICAgICAgIC8vIGhlYWRlcnMsIG1ldGhvZCwgcGF0aCAoYWJvdmUpLCBhbmQgYm9keS5cbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICBib2R5OiBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpIDogcmVxdWVzdC5ib2R5LFxuICAgICAgfSksXG4gICAgICB7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9XG4gICAgKTtcbiAgICByZXR1cm4gcmF3ID8gcmVzdWx0IDogcmVzdWx0Lmpzb247XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggc29tZSBwYWdlcyBmcm9tIGEgcGFnaW5hdGVkIGxpc3QsIGZvbGxvd2luZyB0aGUgYG5leHQtcGFnZWBcbiAgICogaGVhZGVyIGF1dG9tYXRpY2FsbHkgdW50aWwgd2UgaGF2ZSBmZXRjaGVkIHRoZSByZXF1ZXN0ZWQgbnVtYmVyXG4gICAqIG9mIHBhZ2VzLiBSZXR1cm4gYSByZXNwb25zZSB3aXRoIGEgYC5uZXh0KClgIG1ldGhvZCB0aGF0IGNhbiBiZVxuICAgKiBjYWxsZWQgdG8gZmV0Y2ggbW9yZSByZXN1bHRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoXG4gICAqICAgICBUaGUgcGF0aCB0byBtYWtlIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBwYXJhbXNcbiAgICogICAgIFRoZSBwYXJhbWV0ZXJzIHRvIHVzZSB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3BhcmFtcy5zb3J0PVwiLWxhc3RfbW9kaWZpZWRcIl1cbiAgICogICAgIFRoZSBzb3J0aW5nIG9yZGVyIHRvIHVzZSB3aGVuIGZldGNoaW5nLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbcGFyYW1zLmZpbHRlcnM9e31dXG4gICAqICAgICBUaGUgZmlsdGVycyB0byBzZW5kIGluIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbcGFyYW1zLmxpbWl0PXVuZGVmaW5lZF1cbiAgICogICAgIFRoZSBsaW1pdCB0byBzZW5kIGluIHRoZSByZXF1ZXN0LiBVbmRlZmluZWQgbWVhbnMgbm8gbGltaXQuXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtwYXJhbXMucGFnZXM9dW5kZWZpbmVkXVxuICAgKiAgICAgVGhlIG51bWJlciBvZiBwYWdlcyB0byBmZXRjaC4gVW5kZWZpbmVkIG1lYW5zIG9uZSBwYWdlLiBQYXNzXG4gICAqICAgICBJbmZpbml0eSB0byBmZXRjaCBldmVyeXRoaW5nLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbcGFyYW1zLnNpbmNlPXVuZGVmaW5lZF1cbiAgICogICAgIFRoZSBFVGFnIGZyb20gd2hpY2ggdG8gc3RhcnQgZmV0Y2hpbmcuXG4gICAqIEBwYXJhbSAge0FycmF5fSAgIFtwYXJhbXMuZmllbGRzXVxuICAgKiAgICAgTGltaXQgcmVzcG9uc2UgdG8ganVzdCBzb21lIGZpZWxkcy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dXG4gICAqICAgICBBZGRpdGlvbmFsIHJlcXVlc3QtbGV2ZWwgcGFyYW1ldGVycyB0byB1c2UgaW4gYWxsIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzPXt9XVxuICAgKiAgICAgSGVhZGVycyB0byB1c2UgZHVyaW5nIGFsbCByZXF1ZXN0cy5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF1cbiAgICogICAgIE51bWJlciBvZiB0aW1lcyB0byByZXRyeSBlYWNoIHJlcXVlc3QgaWYgdGhlIHNlcnZlciByZXNwb25kc1xuICAgKiAgICAgd2l0aCBSZXRyeS1BZnRlci5cbiAgICovXG4gIGFzeW5jIHBhZ2luYXRlZExpc3QocGF0aCwgcGFyYW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBGSVhNRTogdGhpcyBpcyBjYWxsZWQgZXZlbiBpbiBiYXRjaCByZXF1ZXN0cywgd2hpY2ggZG9lc24ndFxuICAgIC8vIG1ha2UgYW55IHNlbnNlIChzaW5jZSBhbGwgYmF0Y2ggcmVxdWVzdHMgZ2V0IGEgXCJkdW1teVwiXG4gICAgLy8gcmVzcG9uc2U7IHNlZSBleGVjdXRlKCkgYWJvdmUpLlxuICAgIGNvbnN0IHsgc29ydCwgZmlsdGVycywgbGltaXQsIHBhZ2VzLCBzaW5jZSwgZmllbGRzIH0gPSB7XG4gICAgICBzb3J0OiBcIi1sYXN0X21vZGlmaWVkXCIsXG4gICAgICAuLi5wYXJhbXMsXG4gICAgfTtcbiAgICAvLyBTYWZldHkvQ29uc2lzdGVuY3kgY2hlY2sgb24gRVRhZyB2YWx1ZS5cbiAgICBpZiAoc2luY2UgJiYgdHlwZW9mIHNpbmNlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBzaW5jZSAoJHtzaW5jZX0pLCBzaG91bGQgYmUgRVRhZyB2YWx1ZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5ID0ge1xuICAgICAgLi4uZmlsdGVycyxcbiAgICAgIF9zb3J0OiBzb3J0LFxuICAgICAgX2xpbWl0OiBsaW1pdCxcbiAgICAgIF9zaW5jZTogc2luY2UsXG4gICAgfTtcbiAgICBpZiAoZmllbGRzKSB7XG4gICAgICBxdWVyeS5fZmllbGRzID0gZmllbGRzO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHFzaWZ5KHF1ZXJ5KTtcbiAgICBsZXQgcmVzdWx0cyA9IFtdLFxuICAgICAgY3VycmVudCA9IDA7XG5cbiAgICBjb25zdCBuZXh0ID0gYXN5bmMgZnVuY3Rpb24obmV4dFBhZ2UpIHtcbiAgICAgIGlmICghbmV4dFBhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnaW5hdGlvbiBleGhhdXN0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2Nlc3NOZXh0UGFnZShuZXh0UGFnZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHByb2Nlc3NOZXh0UGFnZSA9IGFzeW5jIG5leHRQYWdlID0+IHtcbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gb3B0aW9ucztcbiAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZShhd2FpdCB0aGlzLmh0dHAucmVxdWVzdChuZXh0UGFnZSwgeyBoZWFkZXJzIH0pKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFnZVJlc3VsdHMgPSAocmVzdWx0cywgbmV4dFBhZ2UsIGV0YWcpID0+IHtcbiAgICAgIC8vIEVUYWcgc3RyaW5nIGlzIHN1cHBvc2VkIHRvIGJlIG9wYXF1ZSBhbmQgc3RvcmVkIMKrYXMtaXPCuy5cbiAgICAgIC8vIEVUYWcgaGVhZGVyIHZhbHVlcyBhcmUgcXVvdGVkIChiZWNhdXNlIG9mICogYW5kIFcvXCJmb29cIikuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXN0X21vZGlmaWVkOiBldGFnID8gZXRhZy5yZXBsYWNlKC9cIi9nLCBcIlwiKSA6IGV0YWcsXG4gICAgICAgIGRhdGE6IHJlc3VsdHMsXG4gICAgICAgIG5leHQ6IG5leHQuYmluZChudWxsLCBuZXh0UGFnZSksXG4gICAgICAgIGhhc05leHRQYWdlOiAhIW5leHRQYWdlLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSBhc3luYyBmdW5jdGlvbih7IGhlYWRlcnMsIGpzb24gfSkge1xuICAgICAgY29uc3QgbmV4dFBhZ2UgPSBoZWFkZXJzLmdldChcIk5leHQtUGFnZVwiKTtcbiAgICAgIGNvbnN0IGV0YWcgPSBoZWFkZXJzLmdldChcIkVUYWdcIik7XG5cbiAgICAgIGlmICghcGFnZXMpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2VSZXN1bHRzKGpzb24uZGF0YSwgbmV4dFBhZ2UsIGV0YWcpO1xuICAgICAgfVxuICAgICAgLy8gQWdncmVnYXRlIG5ldyByZXN1bHRzIHdpdGggcHJldmlvdXMgb25lc1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGpzb24uZGF0YSk7XG4gICAgICBjdXJyZW50ICs9IDE7XG4gICAgICBpZiAoY3VycmVudCA+PSBwYWdlcyB8fCAhbmV4dFBhZ2UpIHtcbiAgICAgICAgLy8gUGFnaW5hdGlvbiBleGhhdXN0ZWRcbiAgICAgICAgcmV0dXJuIHBhZ2VSZXN1bHRzKHJlc3VsdHMsIG5leHRQYWdlLCBldGFnKTtcbiAgICAgIH1cbiAgICAgIC8vIEZvbGxvdyBuZXh0IHBhZ2VcbiAgICAgIHJldHVybiBwcm9jZXNzTmV4dFBhZ2UobmV4dFBhZ2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2UoXG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoXG4gICAgICAgIC8vIE4uQi46IFRoaXMgZG9lc24ndCB1c2UgX2dldEhlYWRlcnMsIGJlY2F1c2UgYWxsIGNhbGxzIHRvXG4gICAgICAgIC8vIGBwYWdpbmF0ZWRMaXN0YCBhcmUgYXNzdW1lZCB0byBjb21lIGZyb20gY2FsbHMgdGhhdCBhbHJlYWR5XG4gICAgICAgIC8vIGhhdmUgaGVhZGVycyBtZXJnZWQgYXQgZS5nLiB0aGUgYnVja2V0IG9yIGNvbGxlY3Rpb24gbGV2ZWwuXG4gICAgICAgIHsgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLCBwYXRoOiBwYXRoICsgXCI/XCIgKyBxdWVyeXN0cmluZyB9LFxuICAgICAgICAvLyBOLkIuIFRoaXMgZG9lc24ndCB1c2UgX2dldFJldHJ5LCBiZWNhdXNlIGFsbCBjYWxscyB0b1xuICAgICAgICAvLyBgcGFnaW5hdGVkTGlzdGAgYXJlIGFzc3VtZWQgdG8gY29tZSBmcm9tIGNhbGxzIHRoYXQgYWxyZWFkeVxuICAgICAgICAvLyB1c2VkIGBfZ2V0UmV0cnlgIGF0IGUuZy4gdGhlIGJ1Y2tldCBvciBjb2xsZWN0aW9uIGxldmVsLlxuICAgICAgICB7IHJhdzogdHJ1ZSwgcmV0cnk6IG9wdGlvbnMucmV0cnkgfHwgMCB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgcGVybWlzc2lvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnM9e31dIEhlYWRlcnMgdG8gdXNlIHdoZW4gbWFraW5nXG4gICAqICAgICB0aGlzIHJlcXVlc3QuXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0W10sIEVycm9yPn1cbiAgICovXG4gIEBjYXBhYmxlKFtcInBlcm1pc3Npb25zX2VuZHBvaW50XCJdKVxuICBhc3luYyBsaXN0UGVybWlzc2lvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwicGVybWlzc2lvbnNcIik7XG4gICAgLy8gRW5zdXJlIHRoZSBkZWZhdWx0IHNvcnQgcGFyYW1ldGVyIGlzIHNvbWV0aGluZyB0aGF0IGV4aXN0cyBpbiBwZXJtaXNzaW9uc1xuICAgIC8vIGVudHJpZXMsIGFzIGBsYXN0X21vZGlmaWVkYCBkb2Vzbid0OyBoZXJlLCB3ZSBwaWNrIFwiaWRcIi5cbiAgICBjb25zdCBwYWdpbmF0aW9uT3B0aW9ucyA9IHsgc29ydDogXCJpZFwiLCAuLi5vcHRpb25zIH07XG4gICAgcmV0dXJuIHRoaXMucGFnaW5hdGVkTGlzdChwYXRoLCBwYWdpbmF0aW9uT3B0aW9ucywge1xuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgYnVja2V0cy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVycz17fV0gSGVhZGVycyB0byB1c2Ugd2hlbiBtYWtpbmdcbiAgICogICAgIHRoaXMgcmVxdWVzdC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5yZXRyeT0wXSAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJzPXt9XSBUaGUgZmlsdGVycyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0FycmF5fSAgW29wdGlvbnMuZmllbGRzXSAgICAgTGltaXQgcmVzcG9uc2UgdG9cbiAgICogICAgIGp1c3Qgc29tZSBmaWVsZHMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0W10sIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiKTtcbiAgICByZXR1cm4gdGhpcy5wYWdpbmF0ZWRMaXN0KHBhdGgsIG9wdGlvbnMsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBidWNrZXQgb24gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfG51bGx9ICBpZCAgICAgICAgICAgICAgICBUaGUgYnVja2V0IG5hbWUgKG9wdGlvbmFsKS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgW29wdGlvbnMuZGF0YV0gICAgVGhlIGJ1Y2tldCBkYXRhIG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICBbb3B0aW9ucy5zYWZlXSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICBbb3B0aW9ucy5yZXRyeT0wXSBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJ1Y2tldChpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkYXRhID0ge30sIHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICBkYXRhLmlkID0gaWQ7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBkYXRhLmlkID8gZW5kcG9pbnQoXCJidWNrZXRcIiwgZGF0YS5pZCkgOiBlbmRwb2ludChcImJ1Y2tldFwiKTtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKFxuICAgICAgcmVxdWVzdHMuY3JlYXRlUmVxdWVzdChcbiAgICAgICAgcGF0aCxcbiAgICAgICAgeyBkYXRhLCBwZXJtaXNzaW9ucyB9LFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGJ1Y2tldCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gYnVja2V0ICAgICAgICAgICAgICAgICAgVGhlIGJ1Y2tldCB0byBkZWxldGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQnVja2V0KGJ1Y2tldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYnVja2V0T2JqID0gdG9EYXRhQm9keShidWNrZXQpO1xuICAgIGlmICghYnVja2V0T2JqLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGJ1Y2tldCBpZCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiLCBidWNrZXRPYmouaWQpO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5idWNrZXRPYmosIC4uLm9wdGlvbnMgfTtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKFxuICAgICAgcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICB9KSxcbiAgICAgIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGJ1Y2tldHMgb24gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQHN1cHBvcnQoXCIxLjRcIiwgXCIyLjBcIilcbiAgYXN5bmMgZGVsZXRlQnVja2V0cyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJidWNrZXRcIik7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIHJlcXVlc3RzLmRlbGV0ZVJlcXVlc3QocGF0aCwge1xuICAgICAgICBsYXN0X21vZGlmaWVkOiBvcHRpb25zLmxhc3RfbW9kaWZpZWQsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICB9KSxcbiAgICAgIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH1cbiAgICApO1xuICB9XG5cbiAgQGNhcGFibGUoW1wiYWNjb3VudHNcIl0pXG4gIGFzeW5jIGNyZWF0ZUFjY291bnQodXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShcbiAgICAgIHJlcXVlc3RzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICAgIGAvYWNjb3VudHMvJHt1c2VybmFtZX1gLFxuICAgICAgICB7IGRhdGE6IHsgcGFzc3dvcmQgfSB9LFxuICAgICAgICB7IG1ldGhvZDogXCJQVVRcIiB9XG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBFeHBvcnRzIGJhdGNoIHJlc3BvbnNlcyBhcyBhIHJlc3VsdCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0FycmF5fSByZXNwb25zZXMgVGhlIGJhdGNoIHN1YnJlcXVlc3QgcmVzcG9uc2VzLlxuICogQHBhcmFtICB7QXJyYXl9IHJlcXVlc3RzICBUaGUgaW5pdGlhbCBpc3N1ZWQgcmVxdWVzdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZ2dyZWdhdGUocmVzcG9uc2VzID0gW10sIHJlcXVlc3RzID0gW10pIHtcbiAgaWYgKHJlc3BvbnNlcy5sZW5ndGggIT09IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlcyBsZW5ndGggc2hvdWxkIG1hdGNoIHJlcXVlc3RzIG9uZS5cIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0cyA9IHtcbiAgICBlcnJvcnM6IFtdLFxuICAgIHB1Ymxpc2hlZDogW10sXG4gICAgY29uZmxpY3RzOiBbXSxcbiAgICBza2lwcGVkOiBbXSxcbiAgfTtcbiAgcmV0dXJuIHJlc3BvbnNlcy5yZWR1Y2UoKGFjYywgcmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXMgfSA9IHJlc3BvbnNlO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpbmRleF07XG4gICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgNDAwKSB7XG4gICAgICBhY2MucHVibGlzaGVkLnB1c2gocmVzcG9uc2UuYm9keSk7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgaWQgbWFudWFsbHkgZnJvbSByZXF1ZXN0IHBhdGggd2hpbGUgd2FpdGluZyBmb3IgS2ludG8va2ludG8jODE4XG4gICAgICBjb25zdCByZWdleCA9IC8oYnVja2V0c3xncm91cHN8Y29sbGVjdGlvbnN8cmVjb3JkcylcXC8oW14vXSspJC87XG4gICAgICBjb25zdCBleHRyYWN0cyA9IHJlcXVlc3QucGF0aC5tYXRjaChyZWdleCk7XG4gICAgICBjb25zdCBpZCA9IGV4dHJhY3RzLmxlbmd0aCA9PT0gMyA/IGV4dHJhY3RzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgYWNjLnNraXBwZWQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBwYXRoOiByZXF1ZXN0LnBhdGgsXG4gICAgICAgIGVycm9yOiByZXNwb25zZS5ib2R5LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQxMikge1xuICAgICAgYWNjLmNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgLy8gWFhYOiBzcGVjaWZ5aW5nIHRoZSB0eXBlIGlzIHByb2JhYmx5IHN1cGVyZmx1b3VzXG4gICAgICAgIHR5cGU6IFwib3V0Z29pbmdcIixcbiAgICAgICAgbG9jYWw6IHJlcXVlc3QuYm9keSxcbiAgICAgICAgcmVtb3RlOlxuICAgICAgICAgIChyZXNwb25zZS5ib2R5LmRldGFpbHMgJiYgcmVzcG9uc2UuYm9keS5kZXRhaWxzLmV4aXN0aW5nKSB8fCBudWxsLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5lcnJvcnMucHVzaCh7XG4gICAgICAgIHBhdGg6IHJlcXVlc3QucGF0aCxcbiAgICAgICAgc2VudDogcmVxdWVzdCxcbiAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmJvZHksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgcmVzdWx0cyk7XG59XG4iLCJpbXBvcnQgeyB0b0RhdGFCb2R5LCBpc09iamVjdCwgY2FwYWJsZSwgYWRkRW5kcG9pbnRPcHRpb25zIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL2NvbGxlY3Rpb25cIjtcbmltcG9ydCAqIGFzIHJlcXVlc3RzIGZyb20gXCIuL3JlcXVlc3RzXCI7XG5pbXBvcnQgZW5kcG9pbnQgZnJvbSBcIi4vZW5kcG9pbnRcIjtcblxuLyoqXG4gKiBBYnN0cmFjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGVkIGJ1Y2tldC5cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1Y2tldCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtICB7S2ludG9DbGllbnR9IGNsaWVudCAgICAgICAgICAgIFRoZSBjbGllbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICBuYW1lICAgICAgICAgICAgICBUaGUgYnVja2V0IG5hbWUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICBbb3B0aW9ucz17fV0gICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgIFtvcHRpb25zLnNhZmVdICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgIFtvcHRpb25zLnJldHJ5XSAgIFRoZSByZXRyeSBvcHRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAvKipcbiAgICAgKiBUaGUgYnVja2V0IG5hbWUuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX3JldHJ5ID0gb3B0aW9ucy5yZXRyeSB8fCAwO1xuICAgIHRoaXMuX3NhZmUgPSAhIW9wdGlvbnMuc2FmZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIFwiaGVhZGVyc1wiIGZvciBhIGdpdmVuIHJlcXVlc3QsIG1lcmdpbmcgdGhlXG4gICAqIHBlci1yZXF1ZXN0IGhlYWRlcnMgd2l0aCBvdXIgb3duIFwiZGVmYXVsdFwiIGhlYWRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SGVhZGVycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuX2hlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIFwic2FmZVwiIGZvciBhIGdpdmVuIHJlcXVlc3QsIHVzaW5nIHRoZVxuICAgKiBwZXItcmVxdWVzdCBvcHRpb24gaWYgcHJlc2VudCBvciBmYWxsaW5nIGJhY2sgdG8gb3VyIGRlZmF1bHRcbiAgICogb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgYSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIF9nZXRTYWZlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4geyBzYWZlOiB0aGlzLl9zYWZlLCAuLi5vcHRpb25zIH0uc2FmZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyBfZ2V0U2FmZSwgYnV0IGZvciBcInJldHJ5XCIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmV0cnkob3B0aW9ucykge1xuICAgIHJldHVybiB7IHJldHJ5OiB0aGlzLl9yZXRyeSwgLi4ub3B0aW9ucyB9LnJldHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgICAgICAgICAgICBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbn1cbiAgICovXG4gIGNvbGxlY3Rpb24obmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuY2xpZW50LCB0aGlzLCBuYW1lLCB7XG4gICAgICBiYXRjaDogdGhpcy5faXNCYXRjaCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgRVRhZyBvZiB0aGUgY29sbGVjdGlvbiBsaXN0LCBmb3IgdXNlIHdpdGggdGhlIGBzaW5jZWAgZmlsdGVyaW5nIG9wdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5yZXRyeT0wXSBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGdldENvbGxlY3Rpb25zVGltZXN0YW1wKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5uYW1lKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHBhdGgsXG4gICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgIH07XG4gICAgY29uc3QgeyBoZWFkZXJzIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSxcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycy5nZXQoXCJFVGFnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgRVRhZyBvZiB0aGUgZ3JvdXAgbGlzdCwgZm9yIHVzZSB3aXRoIHRoZSBgc2luY2VgIGZpbHRlcmluZyBvcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nLCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBnZXRHcm91cHNUaW1lc3RhbXAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiZ3JvdXBcIiwgdGhpcy5uYW1lKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHBhdGgsXG4gICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgIH07XG4gICAgY29uc3QgeyBoZWFkZXJzIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSxcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycy5nZXQoXCJFVGFnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBidWNrZXQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5xdWVyeV0gICBRdWVyeSBwYXJhbWV0ZXJzIHRvIHBhc3MgaW5cbiAgICogICAgIHRoZSByZXF1ZXN0LiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBmb3IgZmVhdHVyZXMgdGhhdCBhcmVuJ3RcbiAgICogICAgIHlldCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAgKiBAcGFyYW0gIHtBcnJheX0gIFtvcHRpb25zLmZpZWxkc10gIExpbWl0IHJlc3BvbnNlIHRvXG4gICAqICAgICBqdXN0IHNvbWUgZmllbGRzLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnJldHJ5PTBdIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcGF0aCA9IGVuZHBvaW50KFwiYnVja2V0XCIsIHRoaXMubmFtZSk7XG4gICAgcGF0aCA9IGFkZEVuZHBvaW50T3B0aW9ucyhwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHBhdGgsXG4gICAgfTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwge1xuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBidWNrZXQgZGF0YS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgZGF0YSAgICAgICAgICAgICAgICAgICAgVGhlIGJ1Y2tldCBkYXRhIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzPXt9XSAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5wYXRjaF0gICAgICAgICBUaGUgcGF0Y2ggb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBzZXREYXRhKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgYnVja2V0IG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgYnVja2V0ID0geyAuLi5kYXRhLCBpZDogdGhpcy5uYW1lIH07XG5cbiAgICAvLyBGb3IgZGVmYXVsdCBidWNrZXQsIHdlIG5lZWQgdG8gZHJvcCB0aGUgaWQgZnJvbSB0aGUgZGF0YSBvYmplY3QuXG4gICAgLy8gQnVnIGluIEtpbnRvIDwgMy4xLjFcbiAgICBjb25zdCBidWNrZXRJZCA9IGJ1Y2tldC5pZDtcbiAgICBpZiAoYnVja2V0LmlkID09PSBcImRlZmF1bHRcIikge1xuICAgICAgZGVsZXRlIGJ1Y2tldC5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJidWNrZXRcIiwgYnVja2V0SWQpO1xuICAgIGNvbnN0IHsgcGF0Y2gsIHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5kYXRhLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QoXG4gICAgICBwYXRoLFxuICAgICAgeyBkYXRhOiBidWNrZXQsIHBlcm1pc3Npb25zIH0sXG4gICAgICB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQsXG4gICAgICAgIHBhdGNoLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGhpc3RvcnkgZW50cmllcyBpbiB0aGUgY3VycmVudCBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0PiwgRXJyb3I+fVxuICAgKi9cbiAgQGNhcGFibGUoW1wiaGlzdG9yeVwiXSlcbiAgYXN5bmMgbGlzdEhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiaGlzdG9yeVwiLCB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5wYWdpbmF0ZWRMaXN0KHBhdGgsIG9wdGlvbnMsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGNvbGxlY3Rpb25zIGluIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuZmlsdGVycz17fV0gVGhlIGZpbHRlcnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge0FycmF5fSAgW29wdGlvbnMuZmllbGRzXSAgTGltaXQgcmVzcG9uc2UgdG9cbiAgICogICAgIGp1c3Qgc29tZSBmaWVsZHMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0PiwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgbGlzdENvbGxlY3Rpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucGFnaW5hdGVkTGlzdChwYXRoLCBvcHRpb25zLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sbGVjdGlvbiBpbiBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfHVuZGVmaW5lZH0gIGlkICAgICAgICAgIFRoZSBjb2xsZWN0aW9uIGlkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF0gICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5wZXJtaXNzaW9uc10gVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuZGF0YV0gICAgICAgIFRoZSBkYXRhIG9iamVjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNvbGxlY3Rpb24oaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGVybWlzc2lvbnMsIGRhdGEgPSB7fSB9ID0gb3B0aW9ucztcbiAgICBkYXRhLmlkID0gaWQ7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHBhdGgsXG4gICAgICB7IGRhdGEsIHBlcm1pc3Npb25zIH0sXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0LCB7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29sbGVjdGlvbiBmcm9tIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiAgICAgICAgICAgICAgVGhlIGNvbGxlY3Rpb24gdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29sbGVjdGlvbk9iaiA9IHRvRGF0YUJvZHkoY29sbGVjdGlvbik7XG4gICAgaWYgKCFjb2xsZWN0aW9uT2JqLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbGxlY3Rpb24gaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkIH0gPSBjb2xsZWN0aW9uT2JqO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5jb2xsZWN0aW9uT2JqLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCB7XG4gICAgICBsYXN0X21vZGlmaWVkLFxuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGdyb3VwcyBpbiB0aGUgY3VycmVudCBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmZpbHRlcnM9e31dIFRoZSBmaWx0ZXJzIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnJldHJ5PTBdIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtBcnJheX0gIFtvcHRpb25zLmZpZWxkc10gIExpbWl0IHJlc3BvbnNlIHRvXG4gICAqICAgICBqdXN0IHNvbWUgZmllbGRzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE9iamVjdD4sIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGxpc3RHcm91cHMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiZ3JvdXBcIiwgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucGFnaW5hdGVkTGlzdChwYXRoLCBvcHRpb25zLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYSBncm91cCBpbiBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICAgICAgICAgICAgICBUaGUgZ3JvdXAgaWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMucXVlcnldICAgUXVlcnkgcGFyYW1ldGVycyB0byBwYXNzIGluXG4gICAqICAgICB0aGUgcmVxdWVzdC4gVGhpcyBtaWdodCBiZSB1c2VmdWwgZm9yIGZlYXR1cmVzIHRoYXQgYXJlbid0XG4gICAqICAgICB5ZXQgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeS5cbiAgICogQHBhcmFtICB7QXJyYXl9ICBbb3B0aW9ucy5maWVsZHNdICBMaW1pdCByZXNwb25zZSB0b1xuICAgKiAgICAganVzdCBzb21lIGZpZWxkcy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGdldEdyb3VwKGlkLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcGF0aCA9IGVuZHBvaW50KFwiZ3JvdXBcIiwgdGhpcy5uYW1lLCBpZCk7XG4gICAgcGF0aCA9IGFkZEVuZHBvaW50T3B0aW9ucyhwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHBhdGgsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0LCB7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGdyb3VwIGluIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8dW5kZWZpbmVkfSAgaWQgICAgICAgICAgICAgICAgICAgIFRoZSBncm91cCBpZC5cbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gICAgIFttZW1iZXJzPVtdXSAgICAgICAgICBUaGUgbGlzdCBvZiBwcmluY2lwYWxzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgW29wdGlvbnM9e31dICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgIFtvcHRpb25zLmRhdGFdICAgICAgICBUaGUgZGF0YSBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICBbb3B0aW9ucy5wZXJtaXNzaW9uc10gVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgICAgIFtvcHRpb25zLnNhZmVdICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgIFtvcHRpb25zLnJldHJ5PTBdICAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdyb3VwKGlkLCBtZW1iZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi5vcHRpb25zLmRhdGEsXG4gICAgICBpZCxcbiAgICAgIG1lbWJlcnMsXG4gICAgfTtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJncm91cFwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy5jcmVhdGVSZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHsgZGF0YSwgcGVybWlzc2lvbnMgfSxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgZ3JvdXAgaW4gY3VycmVudCBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIGdyb3VwICAgICAgICAgICAgICAgICAgIFRoZSBncm91cCBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuZGF0YV0gICAgICAgICAgVGhlIGRhdGEgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5wZXJtaXNzaW9uc10gICBUaGUgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyB1cGRhdGVHcm91cChncm91cCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc09iamVjdChncm91cCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgZ3JvdXAgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBncm91cCBpZCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi5vcHRpb25zLmRhdGEsXG4gICAgICAuLi5ncm91cCxcbiAgICB9O1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImdyb3VwXCIsIHRoaXMubmFtZSwgZ3JvdXAuaWQpO1xuICAgIGNvbnN0IHsgcGF0Y2gsIHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5kYXRhLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QoXG4gICAgICBwYXRoLFxuICAgICAgeyBkYXRhLCBwZXJtaXNzaW9ucyB9LFxuICAgICAge1xuICAgICAgICBsYXN0X21vZGlmaWVkLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBncm91cCBmcm9tIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gZ3JvdXAgICAgICAgICAgICAgICAgICAgVGhlIGdyb3VwIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgW29wdGlvbnM9e31dICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBkZWxldGVHcm91cChncm91cCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZ3JvdXBPYmogPSB0b0RhdGFCb2R5KGdyb3VwKTtcbiAgICBjb25zdCB7IGlkIH0gPSBncm91cE9iajtcbiAgICBjb25zdCB7IGxhc3RfbW9kaWZpZWQgfSA9IHsgLi4uZ3JvdXBPYmosIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJncm91cFwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCB7XG4gICAgICBsYXN0X21vZGlmaWVkLFxuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHBlcm1pc3Npb25zIGZvciB0aGlzIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5yZXRyeT0wXSBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGdldFBlcm1pc3Npb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgcGF0aDogZW5kcG9pbnQoXCJidWNrZXRcIiwgdGhpcy5uYW1lKSxcbiAgICB9O1xuICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwge1xuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICAgIHJldHVybiBwZXJtaXNzaW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgZXhpc3RpbmcgYnVja2V0IHBlcm1pc3Npb25zIHdpdGggdGhlIG9uZXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHBlcm1pc3Npb25zICAgICAgICAgICAgIFRoZSBwZXJtaXNzaW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnM9e31dICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc09iamVjdChwZXJtaXNzaW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcGVybWlzc2lvbnMgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiYnVja2V0XCIsIHRoaXMubmFtZSk7XG4gICAgY29uc3QgeyBsYXN0X21vZGlmaWVkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRhdGEgPSB7IGxhc3RfbW9kaWZpZWQgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMudXBkYXRlUmVxdWVzdChcbiAgICAgIHBhdGgsXG4gICAgICB7IGRhdGEsIHBlcm1pc3Npb25zIH0sXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0LCB7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgcHJpbmNpcGFscyB0byB0aGUgYnVja2V0IHBlcm1pc3Npb25zLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBwZXJtaXNzaW9ucyAgICAgICAgICAgICBUaGUgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgYWRkUGVybWlzc2lvbnMocGVybWlzc2lvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNPYmplY3QocGVybWlzc2lvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHBlcm1pc3Npb25zIG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuanNvblBhdGNoUGVybWlzc2lvbnNSZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgXCJhZGRcIixcbiAgICAgIHtcbiAgICAgICAgbGFzdF9tb2RpZmllZCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBwcmluY2lwYWxzIGZyb20gdGhlIGJ1Y2tldCBwZXJtaXNzaW9ucy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgcGVybWlzc2lvbnMgICAgICAgICAgICAgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF0gICAgICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIHJlbW92ZVBlcm1pc3Npb25zKHBlcm1pc3Npb25zLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHBlcm1pc3Npb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBwZXJtaXNzaW9ucyBvYmplY3QgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJidWNrZXRcIiwgdGhpcy5uYW1lKTtcbiAgICBjb25zdCB7IGxhc3RfbW9kaWZpZWQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLmpzb25QYXRjaFBlcm1pc3Npb25zUmVxdWVzdChcbiAgICAgIHBhdGgsXG4gICAgICBwZXJtaXNzaW9ucyxcbiAgICAgIFwicmVtb3ZlXCIsXG4gICAgICB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0LCB7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBiYXRjaCBvcGVyYXRpb25zIGF0IHRoZSBjdXJyZW50IGJ1Y2tldCBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgICAgICAgICAgICAgIFRoZSBiYXRjaCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucz17fV0gICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucy5oZWFkZXJzXSAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgW29wdGlvbnMuc2FmZV0gICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgW29wdGlvbnMucmV0cnk9MF0gICAgVGhlIHJldHJ5IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLmFnZ3JlZ2F0ZV0gIFByb2R1Y2VzIGEgZ3JvdXBlZCByZXN1bHQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgYmF0Y2goZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXRjaChmbiwge1xuICAgICAgYnVja2V0OiB0aGlzLm5hbWUsXG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIGFnZ3JlZ2F0ZTogISFvcHRpb25zLmFnZ3JlZ2F0ZSxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5cbmltcG9ydCB7IGNhcGFibGUsIHRvRGF0YUJvZHksIGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCAqIGFzIHJlcXVlc3RzIGZyb20gXCIuL3JlcXVlc3RzXCI7XG5pbXBvcnQgZW5kcG9pbnQgZnJvbSBcIi4vZW5kcG9pbnRcIjtcbmltcG9ydCB7IGFkZEVuZHBvaW50T3B0aW9ucyB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbi8qKlxuICogQWJzdHJhY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3RlZCBjb2xsZWN0aW9uLlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGVjdGlvbiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtICB7S2ludG9DbGllbnR9ICBjbGllbnQgICAgICAgICAgICBUaGUgY2xpZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtCdWNrZXR9ICAgICAgIGJ1Y2tldCAgICAgICAgICAgIFRoZSBidWNrZXQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgbmFtZSAgICAgICAgICAgICAgVGhlIGNvbGxlY3Rpb24gbmFtZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICBbb3B0aW9ucy5zYWZlXSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgW29wdGlvbnMucmV0cnldICAgVGhlIHJldHJ5IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICBbb3B0aW9ucy5iYXRjaF0gICAoUHJpdmF0ZSkgV2hldGhlciB0aGlzXG4gICAqICAgICBDb2xsZWN0aW9uIGlzIG9wZXJhdGluZyBhcyBwYXJ0IG9mIGEgYmF0Y2guXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGJ1Y2tldCwgbmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3JldHJ5ID0gb3B0aW9ucy5yZXRyeSB8fCAwO1xuICAgIHRoaXMuX3NhZmUgPSAhIW9wdGlvbnMuc2FmZTtcbiAgICAvLyBGSVhNRTogVGhpcyBpcyBraW5kIG9mIHVnbHk7IHNob3VsZG4ndCB0aGUgYnVja2V0IGJlIHJlc3BvbnNpYmxlXG4gICAgLy8gZm9yIGRvaW5nIHRoZSBtZXJnZT9cbiAgICB0aGlzLl9oZWFkZXJzID0ge1xuICAgICAgLi4udGhpcy5idWNrZXQuX2hlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIFwiaGVhZGVyc1wiIGZvciBhIGdpdmVuIHJlcXVlc3QsIG1lcmdpbmcgdGhlXG4gICAqIHBlci1yZXF1ZXN0IGhlYWRlcnMgd2l0aCBvdXIgb3duIFwiZGVmYXVsdFwiIGhlYWRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SGVhZGVycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuX2hlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIFwic2FmZVwiIGZvciBhIGdpdmVuIHJlcXVlc3QsIHVzaW5nIHRoZVxuICAgKiBwZXItcmVxdWVzdCBvcHRpb24gaWYgcHJlc2VudCBvciBmYWxsaW5nIGJhY2sgdG8gb3VyIGRlZmF1bHRcbiAgICogb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgYSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIF9nZXRTYWZlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4geyBzYWZlOiB0aGlzLl9zYWZlLCAuLi5vcHRpb25zIH0uc2FmZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyBfZ2V0U2FmZSwgYnV0IGZvciBcInJldHJ5XCIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmV0cnkob3B0aW9ucykge1xuICAgIHJldHVybiB7IHJldHJ5OiB0aGlzLl9yZXRyeSwgLi4ub3B0aW9ucyB9LnJldHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnJldHJ5PTBdIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE51bWJlciwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxSZWNvcmRzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgcGF0aCxcbiAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgfTtcbiAgICBjb25zdCB7IGhlYWRlcnMgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZUludChoZWFkZXJzLmdldChcIlRvdGFsLVJlY29yZHNcIiksIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIEVUYWcgb2YgdGhlIHJlY29yZHMgbGlzdCwgZm9yIHVzZSB3aXRoIHRoZSBgc2luY2VgIGZpbHRlcmluZyBvcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nLCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNvcmRzVGltZXN0YW1wKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgcGF0aCxcbiAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgfTtcbiAgICBjb25zdCB7IGhlYWRlcnMgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzLmdldChcIkVUYWdcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGNvbGxlY3Rpb24gZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5xdWVyeV0gICBRdWVyeSBwYXJhbWV0ZXJzIHRvIHBhc3MgaW5cbiAgICogICAgIHRoZSByZXF1ZXN0LiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBmb3IgZmVhdHVyZXMgdGhhdCBhcmVuJ3RcbiAgICogICAgIHlldCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAgKiBAcGFyYW0gIHtBcnJheX0gIFtvcHRpb25zLmZpZWxkc10gIExpbWl0IHJlc3BvbnNlIHRvXG4gICAqICAgICBqdXN0IHNvbWUgZmllbGRzLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnJldHJ5PTBdIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIHBhdGggPSBhZGRFbmRwb2ludE9wdGlvbnMocGF0aCwgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSwgcGF0aCB9O1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0LCB7XG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGNvbGxlY3Rpb24gZGF0YS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIGRhdGEgICAgICAgICAgICAgICAgICAgIFRoZSBjb2xsZWN0aW9uIGRhdGEgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnM9e31dICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgW29wdGlvbnMucGF0Y2hdICAgICAgICAgVGhlIHBhdGNoIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIHNldERhdGEoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBjb2xsZWN0aW9uIG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0Y2gsIHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5kYXRhLCAuLi5vcHRpb25zIH07XG5cbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJjb2xsZWN0aW9uXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QoXG4gICAgICBwYXRoLFxuICAgICAgeyBkYXRhLCBwZXJtaXNzaW9ucyB9LFxuICAgICAge1xuICAgICAgICBsYXN0X21vZGlmaWVkLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBwZXJtaXNzaW9ucyBmb3IgdGhpcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnJldHJ5PTBdIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGVybWlzc2lvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksIHBhdGggfTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHtcbiAgICAgIHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSxcbiAgICB9KTtcbiAgICByZXR1cm4gcGVybWlzc2lvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGV4aXN0aW5nIGNvbGxlY3Rpb24gcGVybWlzc2lvbnMgd2l0aCB0aGUgb25lcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIHBlcm1pc3Npb25zICAgICAgICAgICAgIFRoZSBwZXJtaXNzaW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgICBOdW1iZXIgb2YgcmV0cmllcyB0byBtYWtlXG4gICAqICAgICB3aGVuIGZhY2VkIHdpdGggdHJhbnNpZW50IGVycm9ycy5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHBlcm1pc3Npb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBwZXJtaXNzaW9ucyBvYmplY3QgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJjb2xsZWN0aW9uXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHsgbGFzdF9tb2RpZmllZDogb3B0aW9ucy5sYXN0X21vZGlmaWVkIH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QoXG4gICAgICBwYXRoLFxuICAgICAgeyBkYXRhLCBwZXJtaXNzaW9ucyB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHByaW5jaXBhbHMgdG8gdGhlIGNvbGxlY3Rpb24gcGVybWlzc2lvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHBlcm1pc3Npb25zICAgICAgICAgICAgIFRoZSBwZXJtaXNzaW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBhZGRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc09iamVjdChwZXJtaXNzaW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcGVybWlzc2lvbnMgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuanNvblBhdGNoUGVybWlzc2lvbnNSZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgXCJhZGRcIixcbiAgICAgIHtcbiAgICAgICAgbGFzdF9tb2RpZmllZCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBwcmluY2lwYWxzIGZyb20gdGhlIGNvbGxlY3Rpb24gcGVybWlzc2lvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHBlcm1pc3Npb25zICAgICAgICAgICAgIFRoZSBwZXJtaXNzaW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyByZW1vdmVQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc09iamVjdChwZXJtaXNzaW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcGVybWlzc2lvbnMgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuanNvblBhdGNoUGVybWlzc2lvbnNSZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgXCJyZW1vdmVcIixcbiAgICAgIHtcbiAgICAgICAgbGFzdF9tb2RpZmllZCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QsIHsgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZWNvcmQgaW4gY3VycmVudCBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICByZWNvcmQgICAgICAgICAgICAgICAgVGhlIHJlY29yZCB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLnBlcm1pc3Npb25zXSBUaGUgcGVybWlzc2lvbnMgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlUmVjb3JkKHJlY29yZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJyZWNvcmRcIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lLCByZWNvcmQuaWQpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy5jcmVhdGVSZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHsgZGF0YTogcmVjb3JkLCBwZXJtaXNzaW9ucyB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBhdHRhY2htZW50IHRvIGEgcmVjb3JkLCBjcmVhdGluZyB0aGUgcmVjb3JkIHdoZW4gaXQgZG9lc24ndCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgZGF0YVVSTCAgICAgICAgICAgICAgICAgVGhlIGRhdGEgdXJsLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbcmVjb3JkPXt9XSAgICAgICAgICAgICBUaGUgcmVjb3JkIGRhdGEuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF0gICAgICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5wZXJtaXNzaW9uc10gICBUaGUgcGVybWlzc2lvbnMgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbb3B0aW9ucy5maWxlbmFtZV0gICAgICBGb3JjZSB0aGUgYXR0YWNobWVudCBmaWxlbmFtZS5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW29wdGlvbnMuZ3ppcHBlZF0gICAgICAgRm9yY2UgdGhlIGF0dGFjaG1lbnQgdG8gYmUgZ3ppcHBlZCBvciBub3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBAY2FwYWJsZShbXCJhdHRhY2htZW50c1wiXSlcbiAgYXN5bmMgYWRkQXR0YWNobWVudChkYXRhVVJJLCByZWNvcmQgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpZCA9IHJlY29yZC5pZCB8fCB1dWlkLnY0KCk7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiYXR0YWNobWVudFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCB7IGxhc3RfbW9kaWZpZWQgfSA9IHsgLi4ucmVjb3JkLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgYWRkQXR0YWNobWVudFJlcXVlc3QgPSByZXF1ZXN0cy5hZGRBdHRhY2htZW50UmVxdWVzdChcbiAgICAgIHBhdGgsXG4gICAgICBkYXRhVVJJLFxuICAgICAgeyBkYXRhOiByZWNvcmQsIHBlcm1pc3Npb25zIH0sXG4gICAgICB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQsXG4gICAgICAgIGZpbGVuYW1lOiBvcHRpb25zLmZpbGVuYW1lLFxuICAgICAgICBnemlwcGVkOiBvcHRpb25zLmd6aXBwZWQsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgICB9XG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5leGVjdXRlKGFkZEF0dGFjaG1lbnRSZXF1ZXN0LCB7XG4gICAgICBzdHJpbmdpZnk6IGZhbHNlLFxuICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmdldFJlY29yZChpZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRhY2htZW50IGZyb20gYSBnaXZlbiByZWNvcmQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHJlY29yZElkICAgICAgICAgICAgICAgIFRoZSByZWNvcmQgaWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF0gICAgICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKi9cbiAgQGNhcGFibGUoW1wiYXR0YWNobWVudHNcIl0pXG4gIGFzeW5jIHJlbW92ZUF0dGFjaG1lbnQocmVjb3JkSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJhdHRhY2htZW50XCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSwgcmVjb3JkSWQpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy5kZWxldGVSZXF1ZXN0KHBhdGgsIHtcbiAgICAgIGxhc3RfbW9kaWZpZWQsXG4gICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgc2FmZTogdGhpcy5fZ2V0U2FmZShvcHRpb25zKSxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0LCB7IHJldHJ5OiB0aGlzLl9nZXRSZXRyeShvcHRpb25zKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgcmVjb3JkIGluIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgcmVjb3JkICAgICAgICAgICAgICAgICAgVGhlIHJlY29yZCB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMucmV0cnk9MF0gICAgICAgTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5wZXJtaXNzaW9uc10gICBUaGUgcGVybWlzc2lvbnMgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUmVjb3JkKHJlY29yZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc09iamVjdChyZWNvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHJlY29yZCBvYmplY3QgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXJlY29yZC5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWNvcmQgaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5yZWNvcmQsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJyZWNvcmRcIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lLCByZWNvcmQuaWQpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy51cGRhdGVSZXF1ZXN0KFxuICAgICAgcGF0aCxcbiAgICAgIHsgZGF0YTogcmVjb3JkLCBwZXJtaXNzaW9ucyB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLFxuICAgICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgICAgICBsYXN0X21vZGlmaWVkLFxuICAgICAgICBwYXRjaDogISFvcHRpb25zLnBhdGNoLFxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIHJlY29yZCBmcm9tIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdHxTdHJpbmd9IHJlY29yZCAgICAgICAgICAgICAgICAgIFRoZSByZWNvcmQgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgIFtvcHRpb25zLnJldHJ5PTBdICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVJlY29yZChyZWNvcmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlY29yZE9iaiA9IHRvRGF0YUJvZHkocmVjb3JkKTtcbiAgICBpZiAoIXJlY29yZE9iai5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWNvcmQgaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkIH0gPSByZWNvcmRPYmo7XG4gICAgY29uc3QgeyBsYXN0X21vZGlmaWVkIH0gPSB7IC4uLnJlY29yZE9iaiwgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCB7XG4gICAgICBsYXN0X21vZGlmaWVkLFxuICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIHNhZmU6IHRoaXMuX2dldFNhZmUob3B0aW9ucyksXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgcmVjb3JkIGZyb20gdGhlIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICAgICAgICAgICAgICBUaGUgcmVjb3JkIGlkIHRvIHJldHJpZXZlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLnF1ZXJ5XSAgIFF1ZXJ5IHBhcmFtZXRlcnMgdG8gcGFzcyBpblxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGZvciBmZWF0dXJlcyB0aGF0IGFyZW4ndFxuICAgKiAgICAgeWV0IHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gICAqIEBwYXJhbSAge0FycmF5fSAgW29wdGlvbnMuZmllbGRzXSAgTGltaXQgcmVzcG9uc2UgdG9cbiAgICogICAgIGp1c3Qgc29tZSBmaWVsZHMuXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnk9MF0gTnVtYmVyIG9mIHJldHJpZXMgdG8gbWFrZVxuICAgKiAgICAgd2hlbiBmYWNlZCB3aXRoIHRyYW5zaWVudCBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNvcmQoaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBwYXRoID0gZW5kcG9pbnQoXCJyZWNvcmRcIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lLCBpZCk7XG4gICAgcGF0aCA9IGFkZEVuZHBvaW50T3B0aW9ucyhwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB0aGlzLl9nZXRIZWFkZXJzKG9wdGlvbnMpLCBwYXRoIH07XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCwgeyByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucykgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgcmVjb3JkcyBmcm9tIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIFNvcnRpbmcgaXMgZG9uZSBieSBwYXNzaW5nIGEgYHNvcnRgIHN0cmluZyBvcHRpb246XG4gICAqXG4gICAqIC0gVGhlIGZpZWxkIHRvIG9yZGVyIHRoZSByZXN1bHRzIGJ5LCBwcmVmaXhlZCB3aXRoIGAtYCBmb3IgZGVzY2VuZGluZy5cbiAgICogRGVmYXVsdDogYC1sYXN0X21vZGlmaWVkYC5cbiAgICpcbiAgICogQHNlZSBodHRwOi8va2ludG8ucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL2FwaS8xLngvc29ydGluZy5odG1sXG4gICAqXG4gICAqIEZpbHRlcmluZyBpcyBkb25lIGJ5IHBhc3NpbmcgYSBgZmlsdGVyc2Agb3B0aW9uIG9iamVjdDpcbiAgICpcbiAgICogLSBge2ZpZWxkbmFtZTogXCJ2YWx1ZVwifWBcbiAgICogLSBge21pbl9maWVsZG5hbWU6IDQwMDB9YFxuICAgKiAtIGB7aW5fZmllbGRuYW1lOiBcIjEsMiwzXCJ9YFxuICAgKiAtIGB7bm90X2ZpZWxkbmFtZTogMH1gXG4gICAqIC0gYHtleGNsdWRlX2ZpZWxkbmFtZTogXCIwLDFcIn1gXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL2tpbnRvLnJlYWR0aGVkb2NzLmlvL2VuL3N0YWJsZS9hcGkvMS54L2ZpbHRlcmluZy5odG1sXG4gICAqXG4gICAqIFBhZ2luYXRpbmcgaXMgZG9uZSBieSBwYXNzaW5nIGEgYGxpbWl0YCBvcHRpb24sIHRoZW4gY2FsbGluZyB0aGUgYG5leHQoKWBcbiAgICogbWV0aG9kIGZyb20gdGhlIHJlc29sdmVkIHJlc3VsdCBvYmplY3QgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZSwgaWYgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnM9e31dICAgICAgICAgICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICAgICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICBbb3B0aW9ucy5yZXRyeT0wXSAgICAgICAgICAgICAgIE51bWJlciBvZiByZXRyaWVzIHRvIG1ha2VcbiAgICogICAgIHdoZW4gZmFjZWQgd2l0aCB0cmFuc2llbnQgZXJyb3JzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnMuZmlsdGVycz17fV0gICAgICAgICAgICBUaGUgZmlsdGVycyBvYmplY3QuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBbb3B0aW9ucy5zb3J0PVwiLWxhc3RfbW9kaWZpZWRcIl0gVGhlIHNvcnQgZmllbGQuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBbb3B0aW9ucy5hdF0gICAgICAgICAgICAgICAgICAgIFRoZSB0aW1lc3RhbXAgdG8gZ2V0IGEgc25hcHNob3QgYXQuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBbb3B0aW9ucy5saW1pdD1udWxsXSAgICAgICAgICAgIFRoZSBsaW1pdCBmaWVsZC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIFtvcHRpb25zLnBhZ2VzPTFdICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiByZXN1bHQgcGFnZXMgdG8gYWdncmVnYXRlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgW29wdGlvbnMuc2luY2U9bnVsbF0gICAgICAgICAgICBPbmx5IHJldHJpZXZlIHJlY29yZHMgbW9kaWZpZWQgc2luY2UgdGhlIHByb3ZpZGVkIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtICB7QXJyYXl9ICAgIFtvcHRpb25zLmZpZWxkc10gICAgICAgICAgICAgICAgTGltaXQgcmVzcG9uc2UgdG8ganVzdCBzb21lIGZpZWxkcy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGxpc3RSZWNvcmRzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJhdFwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U25hcHNob3Qob3B0aW9ucy5hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5wYWdpbmF0ZWRMaXN0KHBhdGgsIG9wdGlvbnMsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5fZ2V0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgICAgcmV0cnk6IHRoaXMuX2dldFJldHJ5KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBpc0hpc3RvcnlDb21wbGV0ZSgpIHtcbiAgICAvLyBXZSBjb25zaWRlciB0aGF0IGlmIHdlIGhhdmUgdGhlIGNvbGxlY3Rpb24gY3JlYXRpb24gZXZlbnQgcGFydCBvZiB0aGVcbiAgICAvLyBoaXN0b3J5LCB0aGVuIGFsbCByZWNvcmRzIGNoYW5nZSBldmVudHMgaGF2ZSBiZWVuIHRyYWNrZWQuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogW29sZGVzdEhpc3RvcnlFbnRyeV0sXG4gICAgfSA9IGF3YWl0IHRoaXMuYnVja2V0Lmxpc3RIaXN0b3J5KHtcbiAgICAgIGxpbWl0OiAxLFxuICAgICAgZmlsdGVyczoge1xuICAgICAgICBhY3Rpb246IFwiY3JlYXRlXCIsXG4gICAgICAgIHJlc291cmNlX25hbWU6IFwiY29sbGVjdGlvblwiLFxuICAgICAgICBjb2xsZWN0aW9uX2lkOiB0aGlzLm5hbWUsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiAhIW9sZGVzdEhpc3RvcnlFbnRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgbGlzdENoYW5nZXNCYWNrVG8oYXQpIHtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBlbm91Z2ggaGlzdG9yeSBkYXRhIHRvIHJldHJpZXZlIHRoZSBjb21wbGV0ZSBsaXN0IG9mXG4gICAgLy8gY2hhbmdlcy5cbiAgICBpZiAoIShhd2FpdCB0aGlzLmlzSGlzdG9yeUNvbXBsZXRlKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29tcHV0aW5nIGEgc25hcHNob3QgaXMgb25seSBwb3NzaWJsZSB3aGVuIHRoZSBmdWxsIGhpc3RvcnkgZm9yIGEgXCIgK1xuICAgICAgICAgIFwiY29sbGVjdGlvbiBpcyBhdmFpbGFibGUuIEhlcmUsIHRoZSBoaXN0b3J5IHBsdWdpbiBzZWVtcyB0byBoYXZlIFwiICtcbiAgICAgICAgICBcImJlZW4gZW5hYmxlZCBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIGNvbGxlY3Rpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YTogY2hhbmdlcyB9ID0gYXdhaXQgdGhpcy5idWNrZXQubGlzdEhpc3Rvcnkoe1xuICAgICAgcGFnZXM6IEluZmluaXR5LCAvLyBhbGwgcGFnZXMgdXAgdG8gdGFyZ2V0IHRpbWVzdGFtcCBhcmUgcmVxdWlyZWRcbiAgICAgIHNvcnQ6IFwiLXRhcmdldC5kYXRhLmxhc3RfbW9kaWZpZWRcIixcbiAgICAgIGZpbHRlcnM6IHtcbiAgICAgICAgcmVzb3VyY2VfbmFtZTogXCJyZWNvcmRcIixcbiAgICAgICAgY29sbGVjdGlvbl9pZDogdGhpcy5uYW1lLFxuICAgICAgICBcIm1heF90YXJnZXQuZGF0YS5sYXN0X21vZGlmaWVkXCI6IFN0cmluZyhhdCksIC8vIGVxLiB0byA8PVxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQGNhcGFibGUoW1wiaGlzdG9yeVwiXSlcbiAgYXN5bmMgZ2V0U25hcHNob3QoYXQpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXQpIHx8IGF0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQsIGV4cGVjdGVkIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7XG4gICAgfVxuICAgIC8vIFJldHJpZXZlIGhpc3RvcnkgYW5kIGNoZWNrIGl0IGNvdmVycyB0aGUgcmVxdWlyZWQgdGltZSByYW5nZS5cbiAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgdGhpcy5saXN0Q2hhbmdlc0JhY2tUbyhhdCk7XG4gICAgLy8gUmVwbGF5IGNoYW5nZXMgdG8gY29tcHV0ZSB0aGUgcmVxdWVzdGVkIHNuYXBzaG90LlxuICAgIGNvbnN0IHNlZW5JZHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHNuYXBzaG90ID0gW107XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICB0YXJnZXQ6IHsgZGF0YTogcmVjb3JkIH0sXG4gICAgfSBvZiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoYWN0aW9uID09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgc2Vlbklkcy5hZGQocmVjb3JkLmlkKTsgLy8gZW5zdXJlIG5vdCByZXByb2Nlc3NpbmcgZGVsZXRlZCBlbnRyaWVzXG4gICAgICAgIHNuYXBzaG90ID0gc25hcHNob3QuZmlsdGVyKHIgPT4gci5pZCAhPT0gcmVjb3JkLmlkKTtcbiAgICAgIH0gZWxzZSBpZiAoIXNlZW5JZHMuaGFzKHJlY29yZC5pZCkpIHtcbiAgICAgICAgc2Vlbklkcy5hZGQocmVjb3JkLmlkKTtcbiAgICAgICAgc25hcHNob3QucHVzaChyZWNvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGFzdF9tb2RpZmllZDogU3RyaW5nKGF0KSxcbiAgICAgIGRhdGE6IHNuYXBzaG90LnNvcnQoKGEsIGIpID0+IGIubGFzdF9tb2RpZmllZCAtIGEubGFzdF9tb2RpZmllZCksXG4gICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNuYXBzaG90cyBkb24ndCBzdXBwb3J0IHBhZ2luYXRpb25cIik7XG4gICAgICB9LFxuICAgICAgaGFzTmV4dFBhZ2U6IGZhbHNlLFxuICAgICAgdG90YWxSZWNvcmRzOiBzbmFwc2hvdC5sZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBiYXRjaCBvcGVyYXRpb25zIGF0IHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgICAgICAgICBUaGUgYmF0Y2ggb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnM9e31dICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnMuaGVhZGVyc10gICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLnNhZmVdICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLnJldHJ5XSAgICAgIFRoZSByZXRyeSBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5hZ2dyZWdhdGVdICBQcm9kdWNlcyBhIGdyb3VwZWQgcmVzdWx0IG9iamVjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGFzeW5jIGJhdGNoKGZuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYmF0Y2goZm4sIHtcbiAgICAgIGJ1Y2tldDogdGhpcy5idWNrZXQubmFtZSxcbiAgICAgIGNvbGxlY3Rpb246IHRoaXMubmFtZSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuX2dldEhlYWRlcnMob3B0aW9ucyksXG4gICAgICByZXRyeTogdGhpcy5fZ2V0UmV0cnkob3B0aW9ucyksXG4gICAgICBzYWZlOiB0aGlzLl9nZXRTYWZlKG9wdGlvbnMpLFxuICAgICAgYWdncmVnYXRlOiAhIW9wdGlvbnMuYWdncmVnYXRlLFxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEVuZHBvaW50cyB0ZW1wbGF0ZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBFTkRQT0lOVFMgPSB7XG4gIHJvb3Q6ICgpID0+IFwiL1wiLFxuICBiYXRjaDogKCkgPT4gXCIvYmF0Y2hcIixcbiAgcGVybWlzc2lvbnM6ICgpID0+IFwiL3Blcm1pc3Npb25zXCIsXG4gIGJ1Y2tldDogYnVja2V0ID0+IFwiL2J1Y2tldHNcIiArIChidWNrZXQgPyBgLyR7YnVja2V0fWAgOiBcIlwiKSxcbiAgaGlzdG9yeTogYnVja2V0ID0+IGAke0VORFBPSU5UUy5idWNrZXQoYnVja2V0KX0vaGlzdG9yeWAsXG4gIGNvbGxlY3Rpb246IChidWNrZXQsIGNvbGwpID0+XG4gICAgYCR7RU5EUE9JTlRTLmJ1Y2tldChidWNrZXQpfS9jb2xsZWN0aW9uc2AgKyAoY29sbCA/IGAvJHtjb2xsfWAgOiBcIlwiKSxcbiAgZ3JvdXA6IChidWNrZXQsIGdyb3VwKSA9PlxuICAgIGAke0VORFBPSU5UUy5idWNrZXQoYnVja2V0KX0vZ3JvdXBzYCArIChncm91cCA/IGAvJHtncm91cH1gIDogXCJcIiksXG4gIHJlY29yZDogKGJ1Y2tldCwgY29sbCwgaWQpID0+XG4gICAgYCR7RU5EUE9JTlRTLmNvbGxlY3Rpb24oYnVja2V0LCBjb2xsKX0vcmVjb3Jkc2AgKyAoaWQgPyBgLyR7aWR9YCA6IFwiXCIpLFxuICBhdHRhY2htZW50OiAoYnVja2V0LCBjb2xsLCBpZCkgPT5cbiAgICBgJHtFTkRQT0lOVFMucmVjb3JkKGJ1Y2tldCwgY29sbCwgaWQpfS9hdHRhY2htZW50YCxcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgc2VydmVyIGVucG9pbnQgYnkgaXRzIG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSBUaGUgZW5kcG9pbnQgbmFtZS5cbiAqIEBwYXJhbSAgey4uLnN0cmluZ30gYXJncyBUaGUgZW5kcG9pbnQgcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5kcG9pbnQobmFtZSwgLi4uYXJncykge1xuICByZXR1cm4gRU5EUE9JTlRTW25hbWVdKC4uLmFyZ3MpO1xufVxuIiwiLyoqXG4gKiBLaW50byBzZXJ2ZXIgZXJyb3IgY29kZSBkZXNjcmlwdG9ycy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IEVSUk9SX0NPREVTID0ge1xuICAxMDQ6IFwiTWlzc2luZyBBdXRob3JpemF0aW9uIFRva2VuXCIsXG4gIDEwNTogXCJJbnZhbGlkIEF1dGhvcml6YXRpb24gVG9rZW5cIixcbiAgMTA2OiBcIlJlcXVlc3QgYm9keSB3YXMgbm90IHZhbGlkIEpTT05cIixcbiAgMTA3OiBcIkludmFsaWQgcmVxdWVzdCBwYXJhbWV0ZXJcIixcbiAgMTA4OiBcIk1pc3NpbmcgcmVxdWVzdCBwYXJhbWV0ZXJcIixcbiAgMTA5OiBcIkludmFsaWQgcG9zdGVkIGRhdGFcIixcbiAgMTEwOiBcIkludmFsaWQgVG9rZW4gLyBpZFwiLFxuICAxMTE6IFwiTWlzc2luZyBUb2tlbiAvIGlkXCIsXG4gIDExMjogXCJDb250ZW50LUxlbmd0aCBoZWFkZXIgd2FzIG5vdCBwcm92aWRlZFwiLFxuICAxMTM6IFwiUmVxdWVzdCBib2R5IHRvbyBsYXJnZVwiLFxuICAxMTQ6IFwiUmVzb3VyY2Ugd2FzIGNyZWF0ZWQsIHVwZGF0ZWQgb3IgZGVsZXRlZCBtZWFud2hpbGVcIixcbiAgMTE1OiBcIk1ldGhvZCBub3QgYWxsb3dlZCBvbiB0aGlzIGVuZCBwb2ludCAoaGludDogc2VydmVyIG1heSBiZSByZWFkb25seSlcIixcbiAgMTE2OiBcIlJlcXVlc3RlZCB2ZXJzaW9uIG5vdCBhdmFpbGFibGUgb24gdGhpcyBzZXJ2ZXJcIixcbiAgMTE3OiBcIkNsaWVudCBoYXMgc2VudCB0b28gbWFueSByZXF1ZXN0c1wiLFxuICAxMjE6IFwiUmVzb3VyY2UgYWNjZXNzIGlzIGZvcmJpZGRlbiBmb3IgdGhpcyB1c2VyXCIsXG4gIDEyMjogXCJBbm90aGVyIHJlc291cmNlIHZpb2xhdGVzIGNvbnN0cmFpbnRcIixcbiAgMjAxOiBcIlNlcnZpY2UgVGVtcG9yYXJ5IHVuYXZhaWxhYmxlIGR1ZSB0byBoaWdoIGxvYWRcIixcbiAgMjAyOiBcIlNlcnZpY2UgZGVwcmVjYXRlZFwiLFxuICA5OTk6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFUlJPUl9DT0RFUztcblxuY2xhc3MgTmV0d29ya1RpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVGltZW91dCB3aGlsZSB0cnlpbmcgdG8gYWNjZXNzICR7dXJsfSB3aXRoICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9YFxuICAgICk7XG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5ldHdvcmtUaW1lb3V0RXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbn1cblxuY2xhc3MgVW5wYXJzZWFibGVSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgYm9keSwgZXJyb3IpIHtcbiAgICBjb25zdCB7IHN0YXR1cyB9ID0gcmVzcG9uc2U7XG5cbiAgICBzdXBlcihcbiAgICAgIGBSZXNwb25zZSBmcm9tIHNlcnZlciB1bnBhcnNlYWJsZSAoSFRUUCAke3N0YXR1cyB8fFxuICAgICAgICAwfTsgJHtlcnJvcn0pOiAke2JvZHl9YFxuICAgICk7XG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFVucGFyc2VhYmxlUmVzcG9uc2VFcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBcIkVycm9yXCIgc3ViY2xhc3MgcmVwcmVzZW50aW5nIGEgPj00MDAgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICpcbiAqIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYW4gZXJyb3IgZGVwZW5kcyBvbiB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIFRoZSBganNvbmAgZmllbGQgY2FuIGJlIHVuZGVmaW5lZCBpZiB0aGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGFuXG4gKiBlbXB0eSByZXNwb25zZSBib2R5LiBUaGlzIHNob3VsZG4ndCBnZW5lcmFsbHkgaGFwcGVuLiBNb3N0IFwiYmFkXCJcbiAqIHJlc3BvbnNlcyBjb21lIHdpdGggYSBKU09OIGVycm9yIGRlc2NyaXB0aW9uLCBvciAoaWYgdGhleSdyZVxuICogZnJvbnRlZCBieSBhIENETiBvciBuZ2lueCBvciBzb21ldGhpbmcpIG9jY2FzaW9uYWxseSBub24tSlNPTlxuICogcmVzcG9uc2VzICh3aGljaCBiZWNvbWUgVW5wYXJzZWFibGVSZXNwb25zZUVycm9ycywgYWJvdmUpLlxuICovXG5jbGFzcyBTZXJ2ZXJSZXNwb25zZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzcG9uc2UsIGpzb24pIHtcbiAgICBjb25zdCB7IHN0YXR1cyB9ID0gcmVzcG9uc2U7XG4gICAgbGV0IHsgc3RhdHVzVGV4dCB9ID0gcmVzcG9uc2U7XG4gICAgbGV0IGVycm5vTXNnO1xuXG4gICAgaWYgKGpzb24pIHtcbiAgICAgIC8vIFRyeSB0byBmaWxsIGluIGluZm9ybWF0aW9uIGZyb20gdGhlIEpTT04gZXJyb3IuXG4gICAgICBzdGF0dXNUZXh0ID0ganNvbi5lcnJvciB8fCBzdGF0dXNUZXh0O1xuXG4gICAgICAvLyBUYWtlIGVycm5vTXNnIGZyb20gZWl0aGVyIEVSUk9SX0NPREVTIG9yIGpzb24ubWVzc2FnZS5cbiAgICAgIGlmIChqc29uLmVycm5vICYmIGpzb24uZXJybm8gaW4gRVJST1JfQ09ERVMpIHtcbiAgICAgICAgZXJybm9Nc2cgPSBFUlJPUl9DT0RFU1tqc29uLmVycm5vXTtcbiAgICAgIH0gZWxzZSBpZiAoanNvbi5tZXNzYWdlKSB7XG4gICAgICAgIGVycm5vTXNnID0ganNvbi5tZXNzYWdlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBoYWQgYm90aCBFUlJPUl9DT0RFUyBhbmQganNvbi5tZXNzYWdlLCBhbmQgdGhleSBkaWZmZXIsXG4gICAgICAvLyBjb21iaW5lIHRoZW0uXG4gICAgICBpZiAoZXJybm9Nc2cgJiYganNvbi5tZXNzYWdlICYmIGpzb24ubWVzc2FnZSAhPT0gZXJybm9Nc2cpIHtcbiAgICAgICAgZXJybm9Nc2cgKz0gYCAoJHtqc29uLm1lc3NhZ2V9KWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2UgPSBgSFRUUCAke3N0YXR1c30gJHtzdGF0dXNUZXh0fWA7XG4gICAgaWYgKGVycm5vTXNnKSB7XG4gICAgICBtZXNzYWdlICs9IGA6ICR7ZXJybm9Nc2d9YDtcbiAgICB9XG5cbiAgICBzdXBlcihtZXNzYWdlLnRyaW0oKSk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTZXJ2ZXJSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZGF0YSA9IGpzb247XG4gIH1cbn1cblxuZXhwb3J0IHsgTmV0d29ya1RpbWVvdXRFcnJvciwgU2VydmVyUmVzcG9uc2UsIFVucGFyc2VhYmxlUmVzcG9uc2VFcnJvciB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGRlbGF5LCByZXBsYWNlS2V5IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIE5ldHdvcmtUaW1lb3V0RXJyb3IsXG4gIFNlcnZlclJlc3BvbnNlLFxuICBVbnBhcnNlYWJsZVJlc3BvbnNlRXJyb3IsXG59IGZyb20gXCIuL2Vycm9yc1wiO1xuXG4vKipcbiAqIEVuaGFuY2VkIEhUVFAgY2xpZW50IGZvciB0aGUgS2ludG8gcHJvdG9jb2wuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVFRQIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgSFRUUCByZXF1ZXN0IGhlYWRlcnMgYXBwbGllZCB0byBlYWNoIG91dGdvaW5nIHJlcXVlc3QuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUkVRVUVTVF9IRUFERVJTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IG9wdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPcHRpb25zKCkge1xuICAgIHJldHVybiB7IHRpbWVvdXQ6IG51bGwsIHJlcXVlc3RNb2RlOiBcImNvcnNcIiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZXZlbnRzICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgIFtvcHRpb25zPXt9fSAgICAgICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgW29wdGlvbnMudGltZW91dD1udWxsXSAgICAgICBUaGUgcmVxdWVzdCB0aW1lb3V0IGluIG1zLCBpZiBhbnkgKGRlZmF1bHQ6IGBudWxsYCkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICBbb3B0aW9ucy5yZXF1ZXN0TW9kZT1cImNvcnNcIl0gVGhlIEhUVFAgcmVxdWVzdCBtb2RlIChkZWZhdWx0OiBgXCJjb3JzXCJgKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV2ZW50cywgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gcHVibGljIHByb3BlcnRpZXNcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyfVxuICAgICAqL1xuICAgIGlmICghZXZlbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBldmVudHMgaGFuZGxlciBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBtb2RlLlxuICAgICAqIEBzZWUgIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0bW9kZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0TW9kZSA9IG9wdGlvbnMucmVxdWVzdE1vZGUgfHwgSFRUUC5kZWZhdWx0T3B0aW9ucy5yZXF1ZXN0TW9kZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IHRpbWVvdXQuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgSFRUUC5kZWZhdWx0T3B0aW9ucy50aW1lb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aW1lZEZldGNoKHVybCwgb3B0aW9ucykge1xuICAgIGxldCBoYXNUaW1lZG91dCA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBEZXRlY3QgaWYgYSByZXF1ZXN0IGhhcyB0aW1lZCBvdXQuXG4gICAgICBsZXQgX3RpbWVvdXRJZDtcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGhhc1RpbWVkb3V0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHJlcGxhY2VLZXkoXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiYXV0aG9yaXphdGlvblwiLFxuICAgICAgICAgICAgICAgIFwiKioqKiAoc3VwcHJlc3NlZClcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVqZWN0KG5ldyBOZXR3b3JrVGltZW91dEVycm9yKHVybCwgb3B0aW9ucykpO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcHJvY2VlZFdpdGhIYW5kbGVyKGZuKSB7XG4gICAgICAgIHJldHVybiBhcmcgPT4ge1xuICAgICAgICAgIGlmICghaGFzVGltZWRvdXQpIHtcbiAgICAgICAgICAgIGlmIChfdGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZmV0Y2godXJsLCBvcHRpb25zKVxuICAgICAgICAudGhlbihwcm9jZWVkV2l0aEhhbmRsZXIocmVzb2x2ZSkpXG4gICAgICAgIC5jYXRjaChwcm9jZWVkV2l0aEhhbmRsZXIocmVqZWN0KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBoZWFkZXJzIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBib2R5OyBpZiBzbyBwYXJzZSBpdCBhcyBKU09OLlxuICAgIGxldCBqc29uO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVucGFyc2VhYmxlUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgdGV4dCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXR1cyA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBTZXJ2ZXJSZXNwb25zZShyZXNwb25zZSwganNvbik7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1cywganNvbiwgaGVhZGVycyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyByZXRyeSh1cmwsIHJldHJ5QWZ0ZXIsIHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCBkZWxheShyZXRyeUFmdGVyKTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwgcmVxdWVzdCwgeyAuLi5vcHRpb25zLCByZXRyeTogb3B0aW9ucy5yZXRyeSAtIDEgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYW4gSFRUUCByZXF1ZXN0IHRvIHRoZSBLaW50byBzZXJ2ZXIuXG4gICAqXG4gICAqIFJlc29sdmVzIHdpdGggYW4gb2JqZXQgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIEhUVFAgcmVzcG9uc2UgcHJvcGVydGllczpcbiAgICogLSBge051bWJlcn0gIHN0YXR1c2AgIFRoZSBIVFRQIHN0YXR1cyBjb2RlLlxuICAgKiAtIGB7T2JqZWN0fSAganNvbmAgICAgVGhlIEpTT04gcmVzcG9uc2UgYm9keS5cbiAgICogLSBge0hlYWRlcnN9IGhlYWRlcnNgIFRoZSByZXNwb25zZSBoZWFkZXJzIG9iamVjdDsgc2VlIHRoZSBFUzYgZmV0Y2goKSBzcGVjLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCAgICAgICAgICAgICAgIFRoZSBVUkwuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW3JlcXVlc3Q9e31dICAgICAgVGhlIHJlcXVlc3Qgb2JqZWN0LCBwYXNzZWQgdG9cbiAgICogICAgIGZldGNoKCkgYXMgaXRzIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtyZXF1ZXN0LmhlYWRlcnNdIFRoZSByZXF1ZXN0IGhlYWRlcnMgb2JqZWN0IChkZWZhdWx0OiB7fSlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBPcHRpb25zIGZvciBtYWtpbmcgdGhlXG4gICAqICAgICByZXF1ZXN0XG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucmV0cnldICAgTnVtYmVyIG9mIHJldHJpZXMgKGRlZmF1bHQ6IDApXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZXF1ZXN0KHVybCwgcmVxdWVzdCA9IHsgaGVhZGVyczoge30gfSwgb3B0aW9ucyA9IHsgcmV0cnk6IDAgfSkge1xuICAgIC8vIEVuc3VyZSBkZWZhdWx0IHJlcXVlc3QgaGVhZGVycyBhcmUgYWx3YXlzIHNldFxuICAgIHJlcXVlc3QuaGVhZGVycyA9IHsgLi4uSFRUUC5ERUZBVUxUX1JFUVVFU1RfSEVBREVSUywgLi4ucmVxdWVzdC5oZWFkZXJzIH07XG4gICAgLy8gSWYgYSBtdWx0aXBhcnQgYm9keSBpcyBwcm92aWRlZCwgcmVtb3ZlIGFueSBjdXN0b20gQ29udGVudC1UeXBlIGhlYWRlciBhc1xuICAgIC8vIHRoZSBmZXRjaCgpIGltcGxlbWVudGF0aW9uIHdpbGwgYWRkIHRoZSBjb3JyZWN0IG9uZSBmb3IgdXMuXG4gICAgaWYgKHJlcXVlc3QuYm9keSAmJiB0eXBlb2YgcmVxdWVzdC5ib2R5LmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdC5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICAgIH1cbiAgICByZXF1ZXN0Lm1vZGUgPSB0aGlzLnJlcXVlc3RNb2RlO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRpbWVkRmV0Y2godXJsLCByZXF1ZXN0KTtcbiAgICBjb25zdCB7IHN0YXR1cywgaGVhZGVycyB9ID0gcmVzcG9uc2U7XG5cbiAgICB0aGlzLl9jaGVja0ZvckRlcHJlY2F0aW9uSGVhZGVyKGhlYWRlcnMpO1xuICAgIHRoaXMuX2NoZWNrRm9yQmFja29mZkhlYWRlcihzdGF0dXMsIGhlYWRlcnMpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNlcnZlciBzdW1tb25zIHRoZSBjbGllbnQgdG8gcmV0cnkgYWZ0ZXIgYSB3aGlsZS5cbiAgICBjb25zdCByZXRyeUFmdGVyID0gdGhpcy5fY2hlY2tGb3JSZXRyeUFmdGVySGVhZGVyKHN0YXR1cywgaGVhZGVycyk7XG4gICAgLy8gSWYgbnVtYmVyIG9mIGFsbG93ZWQgb2YgcmV0cmllcyBpcyBub3QgZXhoYXVzdGVkLCByZXRyeSB0aGUgc2FtZSByZXF1ZXN0LlxuICAgIGlmIChyZXRyeUFmdGVyICYmIG9wdGlvbnMucmV0cnkgPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXRyeSh1cmwsIHJldHJ5QWZ0ZXIsIHJlcXVlc3QsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9jaGVja0ZvckRlcHJlY2F0aW9uSGVhZGVyKGhlYWRlcnMpIHtcbiAgICBjb25zdCBhbGVydEhlYWRlciA9IGhlYWRlcnMuZ2V0KFwiQWxlcnRcIik7XG4gICAgaWYgKCFhbGVydEhlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYWxlcnQ7XG4gICAgdHJ5IHtcbiAgICAgIGFsZXJ0ID0gSlNPTi5wYXJzZShhbGVydEhlYWRlcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gcGFyc2UgQWxlcnQgaGVhZGVyIG1lc3NhZ2VcIiwgYWxlcnRIZWFkZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oYWxlcnQubWVzc2FnZSwgYWxlcnQudXJsKTtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwiZGVwcmVjYXRlZFwiLCBhbGVydCk7XG4gIH1cblxuICBfY2hlY2tGb3JCYWNrb2ZmSGVhZGVyKHN0YXR1cywgaGVhZGVycykge1xuICAgIGxldCBiYWNrb2ZmTXM7XG4gICAgY29uc3QgYmFja29mZlNlY29uZHMgPSBwYXJzZUludChoZWFkZXJzLmdldChcIkJhY2tvZmZcIiksIDEwKTtcbiAgICBpZiAoYmFja29mZlNlY29uZHMgPiAwKSB7XG4gICAgICBiYWNrb2ZmTXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGJhY2tvZmZTZWNvbmRzICogMTAwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja29mZk1zID0gMDtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZW1pdChcImJhY2tvZmZcIiwgYmFja29mZk1zKTtcbiAgfVxuXG4gIF9jaGVja0ZvclJldHJ5QWZ0ZXJIZWFkZXIoc3RhdHVzLCBoZWFkZXJzKSB7XG4gICAgbGV0IHJldHJ5QWZ0ZXIgPSBoZWFkZXJzLmdldChcIlJldHJ5LUFmdGVyXCIpO1xuICAgIGlmICghcmV0cnlBZnRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKSAqIDEwMDA7XG4gICAgcmV0cnlBZnRlciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZGVsYXk7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInJldHJ5LWFmdGVyXCIsIHJldHJ5QWZ0ZXIpO1xuICAgIHJldHVybiBkZWxheTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcblxuaW1wb3J0IEtpbnRvQ2xpZW50QmFzZSBmcm9tIFwiLi9iYXNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbnRvQ2xpZW50IGV4dGVuZHMgS2ludG9DbGllbnRCYXNlIHtcbiAgY29uc3RydWN0b3IocmVtb3RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBzdXBlcihyZW1vdGUsIE9iamVjdC5hc3NpZ24oeyBldmVudHMgfSwgb3B0aW9ucykpO1xuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBoYWNrIHRvIGF2b2lkIEJyb3dzZXJpZnkgdG8gZXhwb3NlIHRoZSBhYm92ZSBjbGFzc1xuLy8gYXQgYG5ldyBLaW50b0NsaWVudCgpYCBpbnN0ZWFkIG9mIGBuZXcgS2ludG9DbGllbnQuZGVmYXVsdCgpYC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2ludG8va2ludG8taHR0cC5qcy9pc3N1ZXMvNzdcbmlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gS2ludG9DbGllbnQ7XG59XG4iLCJpbXBvcnQgeyBvbWl0LCBjcmVhdGVGb3JtRGF0YSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgc2FmZTogZmFsc2UsXG4gIC8vIGNoZWNrIGlmIHdlIHNob3VsZCBzZXQgZGVmYXVsdCBjb250ZW50IHR5cGUgaGVyZVxuICBoZWFkZXJzOiB7fSxcbiAgcGVybWlzc2lvbnM6IHVuZGVmaW5lZCxcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBwYXRjaDogZmFsc2UsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhZmVIZWFkZXIoc2FmZSwgbGFzdF9tb2RpZmllZCkge1xuICBpZiAoIXNhZmUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKGxhc3RfbW9kaWZpZWQpIHtcbiAgICByZXR1cm4geyBcIklmLU1hdGNoXCI6IGBcIiR7bGFzdF9tb2RpZmllZH1cImAgfTtcbiAgfVxuICByZXR1cm4geyBcIklmLU5vbmUtTWF0Y2hcIjogXCIqXCIgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChwYXRoLCB7IGRhdGEsIHBlcm1pc3Npb25zIH0sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGhlYWRlcnMsIHNhZmUgfSA9IHtcbiAgICAuLi5yZXF1ZXN0RGVmYXVsdHMsXG4gICAgLi4ub3B0aW9ucyxcbiAgfTtcbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgKGRhdGEgJiYgZGF0YS5pZCkgPyBcIlBVVFwiIDogXCJQT1NUXCI7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIHBhdGgsXG4gICAgaGVhZGVyczogeyAuLi5oZWFkZXJzLCAuLi5zYWZlSGVhZGVyKHNhZmUpIH0sXG4gICAgYm9keTogeyBkYXRhLCBwZXJtaXNzaW9ucyB9LFxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSZXF1ZXN0KHBhdGgsIHsgZGF0YSwgcGVybWlzc2lvbnMgfSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgaGVhZGVycywgc2FmZSwgcGF0Y2ggfSA9IHsgLi4ucmVxdWVzdERlZmF1bHRzLCAuLi5vcHRpb25zIH07XG4gIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5kYXRhLCAuLi5vcHRpb25zIH07XG5cbiAgaWYgKE9iamVjdC5rZXlzKG9taXQoZGF0YSwgXCJpZFwiLCBcImxhc3RfbW9kaWZpZWRcIikpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1ldGhvZDogcGF0Y2ggPyBcIlBBVENIXCIgOiBcIlBVVFwiLFxuICAgIHBhdGgsXG4gICAgaGVhZGVyczogeyAuLi5oZWFkZXJzLCAuLi5zYWZlSGVhZGVyKHNhZmUsIGxhc3RfbW9kaWZpZWQpIH0sXG4gICAgYm9keTogeyBkYXRhLCBwZXJtaXNzaW9ucyB9LFxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uUGF0Y2hQZXJtaXNzaW9uc1JlcXVlc3QoXG4gIHBhdGgsXG4gIHBlcm1pc3Npb25zLFxuICBvcFR5cGUsXG4gIG9wdGlvbnMgPSB7fVxuKSB7XG4gIGNvbnN0IHsgaGVhZGVycywgc2FmZSwgbGFzdF9tb2RpZmllZCB9ID0geyAuLi5yZXF1ZXN0RGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcblxuICBjb25zdCBvcHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IFt0eXBlLCBwcmluY2lwYWxzXSBvZiBPYmplY3QuZW50cmllcyhwZXJtaXNzaW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IHByaW5jaXBhbCBvZiBwcmluY2lwYWxzKSB7XG4gICAgICBvcHMucHVzaCh7XG4gICAgICAgIG9wOiBvcFR5cGUsXG4gICAgICAgIHBhdGg6IGAvcGVybWlzc2lvbnMvJHt0eXBlfS8ke3ByaW5jaXBhbH1gLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICBwYXRoLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAuLi5zYWZlSGVhZGVyKHNhZmUsIGxhc3RfbW9kaWZpZWQpLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uLXBhdGNoK2pzb25cIixcbiAgICB9LFxuICAgIGJvZHk6IG9wcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUmVxdWVzdChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBoZWFkZXJzLCBzYWZlLCBsYXN0X21vZGlmaWVkIH0gPSB7XG4gICAgLi4ucmVxdWVzdERlZmF1bHRzLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIGlmIChzYWZlICYmICFsYXN0X21vZGlmaWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2FmZSBjb25jdXJyZW5jeSBjaGVjayByZXF1aXJlcyBhIGxhc3RfbW9kaWZpZWQgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIHBhdGgsXG4gICAgaGVhZGVyczogeyAuLi5oZWFkZXJzLCAuLi5zYWZlSGVhZGVyKHNhZmUsIGxhc3RfbW9kaWZpZWQpIH0sXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEF0dGFjaG1lbnRSZXF1ZXN0KFxuICBwYXRoLFxuICBkYXRhVVJJLFxuICB7IGRhdGEsIHBlcm1pc3Npb25zIH0gPSB7fSxcbiAgb3B0aW9ucyA9IHt9XG4pIHtcbiAgY29uc3QgeyBoZWFkZXJzLCBzYWZlLCBnemlwcGVkIH0gPSB7IC4uLnJlcXVlc3REZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICBjb25zdCB7IGxhc3RfbW9kaWZpZWQgfSA9IHsgLi4uZGF0YSwgLi4ub3B0aW9ucyB9O1xuXG4gIGNvbnN0IGJvZHkgPSB7IGRhdGEsIHBlcm1pc3Npb25zIH07XG4gIGNvbnN0IGZvcm1EYXRhID0gY3JlYXRlRm9ybURhdGEoZGF0YVVSSSwgYm9keSwgb3B0aW9ucyk7XG5cbiAgbGV0IGN1c3RvbVBhdGggPVxuICAgIGd6aXBwZWQgIT0gbnVsbFxuICAgICAgPyAoY3VzdG9tUGF0aCA9IHBhdGggKyBcIj9nemlwcGVkPVwiICsgKGd6aXBwZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIikpXG4gICAgICA6IHBhdGg7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHBhdGg6IGN1c3RvbVBhdGgsXG4gICAgaGVhZGVyczogeyAuLi5oZWFkZXJzLCAuLi5zYWZlSGVhZGVyKHNhZmUsIGxhc3RfbW9kaWZpZWQpIH0sXG4gICAgYm9keTogZm9ybURhdGEsXG4gIH07XG59XG4iLCIvKipcbiAqIENodW5rcyBhbiBhcnJheSBpbnRvIG4gcGllY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGl0aW9uKGFycmF5LCBuKSB7XG4gIGlmIChuIDw9IDApIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjLCB4LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IDAgfHwgaSAlIG4gPT09IDApIHtcbiAgICAgIGFjYy5wdXNoKFt4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0ucHVzaCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIGFsd2F5cyByZXNvbHZpbmcgYWZ0ZXIgdGhlIHNwZWNpZmllZCBhbW91bnQgaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEByZXR1cm4gUHJvbWlzZTx2b2lkPlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsYXkobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIE1hcHMgYSBsaXN0IHRvIHByb21pc2VzIHVzaW5nIHRoZSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uLCBleGVjdXRlcyB0aGVtXG4gKiBzZXF1ZW50aWFsbHkgdGhlbiByZXR1cm5zIGEgUHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcmRlcmVkIHJlc3VsdHMgb2J0YWluZWQuXG4gKiBUaGluayBvZiB0aGlzIGFzIGEgc2VxdWVudGlhbCBQcm9taXNlLmFsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7QXJyYXl9ICAgIGxpc3QgVGhlIGxpc3QgdG8gbWFwLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcE1hcChsaXN0LCBmbikge1xuICBsZXQgcmVzdWx0cyA9IFtdO1xuICBhd2FpdCBsaXN0LnJlZHVjZShhc3luYyBmdW5jdGlvbihwcm9taXNlLCBlbnRyeSkge1xuICAgIGF3YWl0IHByb21pc2U7XG4gICAgY29uc3Qgb3V0ID0gYXdhaXQgZm4oZW50cnkpO1xuICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChvdXQpO1xuICB9LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCBhbmQgcmV0dXJucyBhIGNvcHkgb2YgaXQgd2l0aCB0aGUgcHJvdmlkZWQga2V5cyBvbWl0dGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgIG9iaiAgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gIHsuLi5TdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gb21pdC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgYWNjW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgYW4gb2JqZWN0IGtleSAoY2FzZSBpbnNlbnNpdGl2ZSkgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlS2V5KG9iaiwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKGFjYywgaykgPT4ge1xuICAgIGFjY1trXSA9IGsudG9Mb3dlckNhc2UoKSA9PSBrZXkudG9Mb3dlckNhc2UoKSA/IHZhbHVlIDogb2JqW2tdO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyBhIHJlc291cmNlIGRhdGEgb2JqZWN0IGZyb20gdGhlIHByb3ZpZGVkIGFyZ3VtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R8U3RyaW5nfSByZXNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRhQm9keShyZXNvdXJjZSkge1xuICBpZiAoaXNPYmplY3QocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4geyBpZDogcmVzb3VyY2UgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50LlwiKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIG9iamVjdCBpbnRvIGFuIFVSTCBxdWVyeSBzdHJpbmcsIHN0cmlwcGluZyBvdXQgYW55IHVuZGVmaW5lZFxuICogdmFsdWVzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxc2lmeShvYmopIHtcbiAgY29uc3QgZW5jb2RlID0gdiA9PlxuICAgIGVuY29kZVVSSUNvbXBvbmVudCh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIgPyBTdHJpbmcodikgOiB2KTtcbiAgY29uc3Qgc3RyaXBVbmRlZmluZWQgPSBvID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xuICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwVW5kZWZpbmVkKG9iaik7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdHJpcHBlZClcbiAgICAubWFwKGsgPT4ge1xuICAgICAgY29uc3Qga3MgPSBlbmNvZGUoaykgKyBcIj1cIjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0cmlwcGVkW2tdKSkge1xuICAgICAgICByZXR1cm4ga3MgKyBzdHJpcHBlZFtrXS5tYXAodiA9PiBlbmNvZGUodikpLmpvaW4oXCIsXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlKHN0cmlwcGVkW2tdKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKFwiJlwiKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSB2ZXJzaW9uIGlzIHdpdGhpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB2ZXJzaW9uICAgIFRoZSB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtICB7U3RyaW5nfSBtaW5WZXJzaW9uIFRoZSBtaW5pbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIChpbmNsdXNpdmUpLlxuICogQHBhcmFtICB7U3RyaW5nfSBtYXhWZXJzaW9uIFRoZSBtaW5pbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIChleGNsdXNpdmUpLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2ZXJzaW9uIGlzIG91dHNpZGUgb2YgdGhlIHByb3ZpZGVkIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tWZXJzaW9uKHZlcnNpb24sIG1pblZlcnNpb24sIG1heFZlcnNpb24pIHtcbiAgY29uc3QgZXh0cmFjdCA9IHN0ciA9PiBzdHIuc3BsaXQoXCIuXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSk7XG4gIGNvbnN0IFt2ZXJNYWpvciwgdmVyTWlub3JdID0gZXh0cmFjdCh2ZXJzaW9uKTtcbiAgY29uc3QgW21pbk1ham9yLCBtaW5NaW5vcl0gPSBleHRyYWN0KG1pblZlcnNpb24pO1xuICBjb25zdCBbbWF4TWFqb3IsIG1heE1pbm9yXSA9IGV4dHJhY3QobWF4VmVyc2lvbik7XG4gIGNvbnN0IGNoZWNrcyA9IFtcbiAgICB2ZXJNYWpvciA8IG1pbk1ham9yLFxuICAgIHZlck1ham9yID09PSBtaW5NYWpvciAmJiB2ZXJNaW5vciA8IG1pbk1pbm9yLFxuICAgIHZlck1ham9yID4gbWF4TWFqb3IsXG4gICAgdmVyTWFqb3IgPT09IG1heE1ham9yICYmIHZlck1pbm9yID49IG1heE1pbm9yLFxuICBdO1xuICBpZiAoY2hlY2tzLnNvbWUoeCA9PiB4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWZXJzaW9uICR7dmVyc2lvbn0gZG9lc24ndCBzYXRpc2Z5ICR7bWluVmVyc2lvbn0gPD0geCA8ICR7bWF4VmVyc2lvbn1gXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29yYXRvciBmdW5jdGlvbiBlbnN1cmluZyBhIHZlcnNpb24gY2hlY2sgaXMgcGVyZm9ybWVkIGFnYWluc3RcbiAqIHRoZSBwcm92aWRlZCByZXF1aXJlbWVudHMgYmVmb3JlIGV4ZWN1dGluZyBpdC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1pbiBUaGUgcmVxdWlyZWQgbWluIHZlcnNpb24gKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1heCBUaGUgcmVxdWlyZWQgbWF4IHZlcnNpb24gKGluY2x1c2l2ZSkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnQobWluLCBtYXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgY29uc3QgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRNZXRob2QgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIC8vIFwidGhpc1wiIGlzIHRoZSBjdXJyZW50IGluc3RhbmNlIHdoaWNoIGl0cyBtZXRob2QgaXMgZGVjb3JhdGVkLlxuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IFwiY2xpZW50XCIgaW4gdGhpcyA/IHRoaXMuY2xpZW50IDogdGhpcztcbiAgICAgICAgICByZXR1cm4gY2xpZW50XG4gICAgICAgICAgICAuZmV0Y2hIVFRQQXBpVmVyc2lvbigpXG4gICAgICAgICAgICAudGhlbih2ZXJzaW9uID0+IGNoZWNrVmVyc2lvbih2ZXJzaW9uLCBtaW4sIG1heCkpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogd3JhcHBlZE1ldGhvZCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JhcHBlZE1ldGhvZDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBkZWNvcmF0b3IgZnVuY3Rpb24gZW5zdXJpbmcgdGhhdCB0aGUgc3BlY2lmaWVkIGNhcGFiaWxpdGllcyBhcmVcbiAqIGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyIGJlZm9yZSBleGVjdXRpbmcgaXQuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gY2FwYWJpbGl0aWVzIFRoZSByZXF1aXJlZCBjYXBhYmlsaXRpZXMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcGFibGUoY2FwYWJpbGl0aWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgY3VycmVudCBpbnN0YW5jZSB3aGljaCBpdHMgbWV0aG9kIGlzIGRlY29yYXRlZC5cbiAgICAgICAgICBjb25zdCBjbGllbnQgPSBcImNsaWVudFwiIGluIHRoaXMgPyB0aGlzLmNsaWVudCA6IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgICAgICAgLmZldGNoU2VydmVyQ2FwYWJpbGl0aWVzKClcbiAgICAgICAgICAgIC50aGVuKGF2YWlsYWJsZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBjYXBhYmlsaXRpZXMuZmlsdGVyKGMgPT4gIShjIGluIGF2YWlsYWJsZSkpO1xuICAgICAgICAgICAgICBpZiAobWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1N0ciA9IG1pc3Npbmcuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBSZXF1aXJlZCBjYXBhYmlsaXRpZXMgJHttaXNzaW5nU3RyfSBub3QgcHJlc2VudCBvbiBzZXJ2ZXJgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIHZhbHVlOiB3cmFwcGVkTWV0aG9kLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkTWV0aG9kO1xuICAgICAgfSxcbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29yYXRvciBmdW5jdGlvbiBlbnN1cmluZyBhbiBvcGVyYXRpb24gaXMgbm90IHBlcmZvcm1lZCBmcm9tXG4gKiB3aXRoaW4gYSBiYXRjaCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZSB0byB0aHJvdy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9iYXRjaChtZXNzYWdlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgY3VycmVudCBpbnN0YW5jZSB3aGljaCBpdHMgbWV0aG9kIGlzIGRlY29yYXRlZC5cbiAgICAgICAgICBpZiAodGhpcy5faXNCYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogd3JhcHBlZE1ldGhvZCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JhcHBlZE1ldGhvZDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QgKGkuZS4gbm90IGFuIGFycmF5IG5vciBudWxsKS5cbiAqIEBwYXJhbSAge09iamVjdH0gdGhpbmcgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiB0aGluZyAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgZGF0YSB1cmwuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFVUkwgVGhlIGRhdGEgdXJsLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRhVVJMKGRhdGFVUkwpIHtcbiAgY29uc3QgcmVnZXggPSAvXmRhdGE6KC4qKTtiYXNlNjQsKC4qKS87XG4gIGNvbnN0IG1hdGNoID0gZGF0YVVSTC5tYXRjaChyZWdleCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YS11cmw6ICR7U3RyaW5nKGRhdGFVUkwpLnN1YnN0cigwLCAzMil9Li4uYCk7XG4gIH1cbiAgY29uc3QgcHJvcHMgPSBtYXRjaFsxXTtcbiAgY29uc3QgYmFzZTY0ID0gbWF0Y2hbMl07XG4gIGNvbnN0IFt0eXBlLCAuLi5yYXdQYXJhbXNdID0gcHJvcHMuc3BsaXQoXCI7XCIpO1xuICBjb25zdCBwYXJhbXMgPSByYXdQYXJhbXMucmVkdWNlKChhY2MsIHBhcmFtKSA9PiB7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQoXCI9XCIpO1xuICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IHZhbHVlIH07XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHsgLi4ucGFyYW1zLCB0eXBlLCBiYXNlNjQgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBmaWxlIGluZm9ybWF0aW9uIGZyb20gYSBkYXRhIHVybC5cbiAqIEBwYXJhbSAge1N0cmluZ30gZGF0YVVSTCBUaGUgZGF0YSB1cmwuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RmlsZUluZm8oZGF0YVVSTCkge1xuICBjb25zdCB7IG5hbWUsIHR5cGUsIGJhc2U2NCB9ID0gcGFyc2VEYXRhVVJMKGRhdGFVUkwpO1xuICBjb25zdCBiaW5hcnkgPSBhdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaChiaW5hcnkuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgbGV0IGJsb2I7XG4gIGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIFJ1bm5pbmcgaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICAgIGJsb2IgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXSwgeyB0eXBlIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIE5vZGVKUy4gQmxvYiBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGJsb2IgPSBCdWZmZXIuZnJvbShhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHsgYmxvYiwgbmFtZSB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBGb3JtRGF0YSBpbnN0YW5jZSBmcm9tIGEgZGF0YSB1cmwgYW5kIGFuIGV4aXN0aW5nIEpTT04gcmVzcG9uc2VcbiAqIGJvZHkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFVUkwgICAgICAgICAgICBUaGUgZGF0YSB1cmwuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJvZHkgICAgICAgICAgICAgICBUaGUgcmVzcG9uc2UgYm9keS5cbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuZmlsZW5hbWVdIEZvcmNlIGF0dGFjaG1lbnQgZmlsZSBuYW1lLlxuICogQHJldHVybiB7Rm9ybURhdGF9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JtRGF0YShkYXRhVVJMLCBib2R5LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBmaWxlbmFtZSA9IFwidW50aXRsZWRcIiB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBibG9iLCBuYW1lIH0gPSBleHRyYWN0RmlsZUluZm8oZGF0YVVSTCk7XG4gIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGZvcm1EYXRhLmFwcGVuZChcImF0dGFjaG1lbnRcIiwgYmxvYiwgbmFtZSB8fCBmaWxlbmFtZSk7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gYm9keSkge1xuICAgIGlmICh0eXBlb2YgYm9keVtwcm9wZXJ0eV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChwcm9wZXJ0eSwgSlNPTi5zdHJpbmdpZnkoYm9keVtwcm9wZXJ0eV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG4vKipcbiAqIENsb25lcyBhbiBvYmplY3Qgd2l0aCBhbGwgaXRzIHVuZGVmaW5lZCBrZXlzIHJlbW92ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5VbmRlZmluZWRQcm9wZXJ0aWVzKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBIYW5kbGUgY29tbW9uIHF1ZXJ5IHBhcmFtZXRlcnMgZm9yIEtpbnRvIHJlcXVlc3RzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIFtwYXRoXSAgVGhlIGVuZHBvaW50IGJhc2UgcGF0aC5cbiAqIEBwYXJhbSAge0FycmF5fSAgIFtvcHRpb25zLmZpZWxkc10gICAgRmllbGRzIHRvIGxpbWl0IHRoZVxuICogICByZXF1ZXN0IHRvLlxuICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMucXVlcnk9e31dICBBZGRpdGlvbmFsIHF1ZXJ5IGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVuZHBvaW50T3B0aW9ucyhwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcXVlcnkgPSB7IC4uLm9wdGlvbnMucXVlcnkgfTtcbiAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgcXVlcnkuX2ZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICB9XG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXNpZnkocXVlcnkpO1xuICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICByZXR1cm4gcGF0aCArIFwiP1wiICsgcXVlcnlTdHJpbmc7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG4iXX0=
