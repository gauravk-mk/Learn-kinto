"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var http_1 = __importDefault(require("./http"));
var endpoint_1 = __importDefault(require("./endpoint"));
var requests = __importStar(require("./requests"));
var batch_1 = require("./batch");
var bucket_1 = __importDefault(require("./bucket"));
var utils_2 = require("./utils");
/**
 * Currently supported protocol version.
 * @type {String}
 */
exports.SUPPORTED_PROTOCOL_VERSION = "v1";
/**
 * High level HTTP client for the Kinto API.
 *
 * @example
 * const client = new KintoClient("https://kinto.dev.mozaws.net/v1");
 * client.bucket("default")
 *    .collection("my-blog")
 *    .createRecord({title: "First article"})
 *   .then(console.log.bind(console))
 *   .catch(console.error.bind(console));
 */
var KintoClientBase = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param  {String}       remote  The remote URL.
     * @param  {Object}       [options={}]                  The options object.
     * @param  {Boolean}      [options.safe=true]           Adds concurrency headers to every requests.
     * @param  {EventEmitter} [options.events=EventEmitter] The events handler instance.
     * @param  {Object}       [options.headers={}]          The key-value headers to pass to each request.
     * @param  {Object}       [options.retry=0]             Number of retries when request fails (default: 0)
     * @param  {String}       [options.bucket="default"]    The default bucket to use.
     * @param  {String}       [options.requestMode="cors"]  The HTTP request mode (from ES6 fetch spec).
     * @param  {Number}       [options.timeout=null]        The request timeout in ms, if any.
     */
    function KintoClientBase(remote, options) {
        if (typeof remote !== "string" || !remote.length) {
            throw new Error("Invalid remote URL: " + remote);
        }
        if (remote[remote.length - 1] === "/") {
            remote = remote.slice(0, -1);
        }
        this._backoffReleaseTime = null;
        this._requests = [];
        this._isBatch = !!options.batch;
        this._retry = options.retry || 0;
        this._safe = !!options.safe;
        this._headers = options.headers || {};
        // public properties
        /**
         * The remote server base URL.
         * @type {String}
         */
        this.remote = remote;
        /**
         * Current server information.
         * @ignore
         * @type {Object|null}
         */
        this.serverInfo = null;
        /**
         * The event emitter instance. Should comply with the `EventEmitter`
         * interface.
         * @ignore
         * @type {Class}
         */
        this.events = options.events;
        var requestMode = options.requestMode, timeout = options.timeout;
        /**
         * The HTTP instance.
         * @ignore
         * @type {HTTP}
         */
        this.http = new http_1.default(this.events, { requestMode: requestMode, timeout: timeout });
        this._registerHTTPEvents();
    }
    Object.defineProperty(KintoClientBase.prototype, "remote", {
        /**
         * The remote endpoint base URL. Setting the value will also extract and
         * validate the version.
         * @type {String}
         */
        get: function () {
            return this._remote;
        },
        /**
         * @ignore
         */
        set: function (url) {
            var version;
            try {
                version = url.match(/\/(v\d+)\/?$/)[1];
            }
            catch (err) {
                throw new Error("The remote URL must contain the version: " + url);
            }
            if (version !== exports.SUPPORTED_PROTOCOL_VERSION) {
                throw new Error("Unsupported protocol version: " + version);
            }
            this._remote = url;
            this._version = version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KintoClientBase.prototype, "version", {
        /**
         * The current server protocol version, eg. `v1`.
         * @type {String}
         */
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KintoClientBase.prototype, "backoff", {
        /**
         * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is
         * ongoing.
         *
         * @type {Number}
         */
        get: function () {
            var currentTime = new Date().getTime();
            if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {
                return this._backoffReleaseTime - currentTime;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers HTTP events.
     * @private
     */
    KintoClientBase.prototype._registerHTTPEvents = function () {
        var _this = this;
        // Prevent registering event from a batch client instance
        if (!this._isBatch) {
            this.events.on("backoff", function (backoffMs) {
                _this._backoffReleaseTime = backoffMs;
            });
        }
    };
    /**
     * Retrieve a bucket object to perform operations on it.
     *
     * @param  {String}  name              The bucket name.
     * @param  {Object}  [options={}]      The request options.
     * @param  {Boolean} [options.safe]    The resulting safe option.
     * @param  {Number}  [options.retry]   The resulting retry option.
     * @param  {Object}  [options.headers] The extended headers object option.
     * @return {Bucket}
     */
    KintoClientBase.prototype.bucket = function (name, options) {
        if (options === void 0) { options = {}; }
        return new bucket_1.default(this, name, {
            batch: this._isBatch,
            headers: this._getHeaders(options),
            safe: this._getSafe(options),
            retry: this._getRetry(options),
        });
    };
    /**
     * Set client "headers" for every request, updating previous headers (if any).
     *
     * @param {Object} headers The headers to merge with existing ones.
     */
    KintoClientBase.prototype.setHeaders = function (headers) {
        this._headers = __assign({}, this._headers, headers);
        this.serverInfo = null;
    };
    /**
     * Get the value of "headers" for a given request, merging the
     * per-request headers with our own "default" headers.
     *
     * Note that unlike other options, headers aren't overridden, but
     * merged instead.
     *
     * @private
     * @param {Object} options The options for a request.
     * @returns {Object}
     */
    KintoClientBase.prototype._getHeaders = function (options) {
        return __assign({}, this._headers, options.headers);
    };
    /**
     * Get the value of "safe" for a given request, using the
     * per-request option if present or falling back to our default
     * otherwise.
     *
     * @private
     * @param {Object} options The options for a request.
     * @returns {Boolean}
     */
    KintoClientBase.prototype._getSafe = function (options) {
        return __assign({ safe: this._safe }, options).safe;
    };
    /**
     * As _getSafe, but for "retry".
     *
     * @private
     */
    KintoClientBase.prototype._getRetry = function (options) {
        return __assign({ retry: this._retry }, options).retry;
    };
    /**
     * Retrieves the server's "hello" endpoint. This endpoint reveals
     * server capabilities and settings as well as telling the client
     * "who they are" according to their given authorization headers.
     *
     * @private
     * @param  {Object}  [options={}] The request options.
     * @param  {Object}  [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype._getHello = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var path, json;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = this.remote + endpoint_1.default.root();
                        return [4 /*yield*/, this.http.request(path, { headers: this._getHeaders(options) }, { retry: this._getRetry(options) })];
                    case 1:
                        json = (_a.sent()).json;
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * Retrieves server information and persist them locally. This operation is
     * usually performed a single time during the instance lifecycle.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.fetchServerInfo = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.serverInfo) {
                            return [2 /*return*/, this.serverInfo];
                        }
                        _a = this;
                        return [4 /*yield*/, this._getHello({ retry: this._getRetry(options) })];
                    case 1:
                        _a.serverInfo = _b.sent();
                        return [2 /*return*/, this.serverInfo];
                }
            });
        });
    };
    /**
     * Retrieves Kinto server settings.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.fetchServerSettings = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var settings;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetchServerInfo(options)];
                    case 1:
                        settings = (_a.sent()).settings;
                        return [2 /*return*/, settings];
                }
            });
        });
    };
    /**
     * Retrieve server capabilities information.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.fetchServerCapabilities = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var capabilities;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetchServerInfo(options)];
                    case 1:
                        capabilities = (_a.sent()).capabilities;
                        return [2 /*return*/, capabilities];
                }
            });
        });
    };
    /**
     * Retrieve authenticated user information.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Object}  [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.fetchUser = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var user;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getHello(options)];
                    case 1:
                        user = (_a.sent()).user;
                        return [2 /*return*/, user];
                }
            });
        });
    };
    /**
     * Retrieve authenticated user information.
     *
     * @param  {Object}  [options={}] The request options.
     * @param  {Number}  [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.fetchHTTPApiVersion = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var http_api_version;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetchServerInfo(options)];
                    case 1:
                        http_api_version = (_a.sent()).http_api_version;
                        return [2 /*return*/, http_api_version];
                }
            });
        });
    };
    /**
     * Process batch requests, chunking them according to the batch_max_requests
     * server setting when needed.
     *
     * @param  {Array}  requests     The list of batch subrequests to perform.
     * @param  {Object} [options={}] The options object.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype._batchRequests = function (requests, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var headers, serverSettings, maxRequests, chunks, results, chunks_1, chunks_1_1, chunk, result, e_1_1, responses;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        headers = this._getHeaders(options);
                        if (!requests.length) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this.fetchServerSettings({
                                retry: this._getRetry(options),
                            })];
                    case 1:
                        serverSettings = _b.sent();
                        maxRequests = serverSettings["batch_max_requests"];
                        if (!(maxRequests && requests.length > maxRequests)) return [3 /*break*/, 10];
                        chunks = utils_1.partition(requests, maxRequests);
                        results = [];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 7, 8, 9]);
                        chunks_1 = __values(chunks), chunks_1_1 = chunks_1.next();
                        _b.label = 3;
                    case 3:
                        if (!!chunks_1_1.done) return [3 /*break*/, 6];
                        chunk = chunks_1_1.value;
                        return [4 /*yield*/, this._batchRequests(chunk, options)];
                    case 4:
                        result = _b.sent();
                        results.push.apply(results, __spread(result));
                        _b.label = 5;
                    case 5:
                        chunks_1_1 = chunks_1.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (chunks_1_1 && !chunks_1_1.done && (_a = chunks_1.return)) _a.call(chunks_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/, results];
                    case 10: return [4 /*yield*/, this.execute({
                            // FIXME: is this really necessary, since it's also present in
                            // the "defaults"?
                            headers: headers,
                            path: endpoint_1.default.batch(),
                            method: "POST",
                            body: {
                                defaults: { headers: headers },
                                requests: requests,
                            },
                        }, { retry: this._getRetry(options) })];
                    case 11:
                        responses = (_b.sent()).responses;
                        return [2 /*return*/, responses];
                }
            });
        });
    };
    /**
     * Sends batch requests to the remote server.
     *
     * Note: Reserved for internal use only.
     *
     * @ignore
     * @param  {Function} fn                        The function to use for describing batch ops.
     * @param  {Object}   [options={}]              The options object.
     * @param  {Boolean}  [options.safe]            The safe option.
     * @param  {Number}   [options.retry]           The retry option.
     * @param  {String}   [options.bucket]          The bucket name option.
     * @param  {String}   [options.collection]      The collection name option.
     * @param  {Object}   [options.headers]         The headers object option.
     * @param  {Boolean}  [options.aggregate=false] Produces an aggregated result object.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.batch = function (fn, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var rootBatch, bucketBatch, collBatch, batchClient, responses;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rootBatch = new KintoClientBase(this.remote, {
                            events: this.events,
                            batch: true,
                            safe: this._getSafe(options),
                            retry: this._getRetry(options),
                        });
                        if (options.bucket) {
                            bucketBatch = rootBatch.bucket(options.bucket);
                            if (options.collection) {
                                collBatch = bucketBatch.collection(options.collection);
                            }
                        }
                        batchClient = collBatch || bucketBatch || rootBatch;
                        fn(batchClient);
                        return [4 /*yield*/, this._batchRequests(rootBatch._requests, options)];
                    case 1:
                        responses = _a.sent();
                        if (options.aggregate) {
                            return [2 /*return*/, batch_1.aggregate(responses, rootBatch._requests)];
                        }
                        else {
                            return [2 /*return*/, responses];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Executes an atomic HTTP request.
     *
     * @private
     * @param  {Object}  request             The request object.
     * @param  {String}  request.path        The path to fetch, relative
     *     to the Kinto server root.
     * @param  {String}  [request.method="GET"] The method to use in the
     *     request.
     * @param  {Body}    [request.body]      The request body.
     * @param  {Object}  [request.headers={}] The request headers.
     * @param  {Object}  [options={}]        The options object.
     * @param  {Boolean} [options.raw=false] If true, resolve with full response
     * @param  {Boolean} [options.stringify=true] If true, serialize body data to
     * @param  {Number}  [options.retry=0]   The number of times to
     *     retry a request if the server responds with Retry-After.
     * JSON.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.execute = function (request, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, raw, _b, stringify, msg, result;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = options.raw, raw = _a === void 0 ? false : _a, _b = options.stringify, stringify = _b === void 0 ? true : _b;
                        // If we're within a batch, add the request to the stack to send at once.
                        if (this._isBatch) {
                            this._requests.push(request);
                            msg = ("This result is generated from within a batch " +
                                "operation and should not be consumed.");
                            return [2 /*return*/, raw
                                    ? { status: 0, json: msg, headers: new Headers() }
                                    : msg];
                        }
                        return [4 /*yield*/, this.http.request(this.remote + request.path, utils_1.cleanUndefinedProperties({
                                // Limit requests to only those parts that would be allowed in
                                // a batch request -- don't pass through other fancy fetch()
                                // options like integrity, redirect, mode because they will
                                // break on a batch request.  A batch request only allows
                                // headers, method, path (above), and body.
                                method: request.method,
                                headers: request.headers,
                                body: stringify ? JSON.stringify(request.body) : request.body,
                            }), { retry: this._getRetry(options) })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, raw ? result : result.json];
                }
            });
        });
    };
    /**
     * Fetch some pages from a paginated list, following the `next-page`
     * header automatically until we have fetched the requested number
     * of pages. Return a response with a `.next()` method that can be
     * called to fetch more results.
     *
     * @private
     * @param  {String}  path
     *     The path to make the request to.
     * @param  {Object}  params
     *     The parameters to use when making the request.
     * @param  {String}  [params.sort="-last_modified"]
     *     The sorting order to use when fetching.
     * @param  {Object}  [params.filters={}]
     *     The filters to send in the request.
     * @param  {Number}  [params.limit=undefined]
     *     The limit to send in the request. Undefined means no limit.
     * @param  {Number}  [params.pages=undefined]
     *     The number of pages to fetch. Undefined means one page. Pass
     *     Infinity to fetch everything.
     * @param  {String}  [params.since=undefined]
     *     The ETag from which to start fetching.
     * @param  {Array}   [params.fields]
     *     Limit response to just some fields.
     * @param  {Object}  [options={}]
     *     Additional request-level parameters to use in all requests.
     * @param  {Object}  [options.headers={}]
     *     Headers to use during all requests.
     * @param  {Number}  [options.retry=0]
     *     Number of times to retry each request if the server responds
     *     with Retry-After.
     */
    KintoClientBase.prototype.paginatedList = function (path, params, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, sort, filters, limit, pages, since, fields, query, querystring, results, current, next, processNextPage, pageResults, handleResponse, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = __assign({ sort: "-last_modified" }, params), sort = _a.sort, filters = _a.filters, limit = _a.limit, pages = _a.pages, since = _a.since, fields = _a.fields;
                        // Safety/Consistency check on ETag value.
                        if (since && typeof since !== "string") {
                            throw new Error("Invalid value for since (" + since + "), should be ETag value.");
                        }
                        query = __assign({}, filters, { _sort: sort, _limit: limit, _since: since });
                        if (fields) {
                            query._fields = fields;
                        }
                        querystring = utils_1.qsify(query);
                        results = [], current = 0;
                        next = function (nextPage) {
                            return __awaiter(this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    if (!nextPage) {
                                        throw new Error("Pagination exhausted.");
                                    }
                                    return [2 /*return*/, processNextPage(nextPage)];
                                });
                            });
                        };
                        processNextPage = function (nextPage) { return __awaiter(_this, void 0, void 0, function () {
                            var headers, _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        headers = options.headers;
                                        _a = handleResponse;
                                        return [4 /*yield*/, this.http.request(nextPage, { headers: headers })];
                                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                                }
                            });
                        }); };
                        pageResults = function (results, nextPage, etag) {
                            // ETag string is supposed to be opaque and stored «as-is».
                            // ETag header values are quoted (because of * and W/"foo").
                            return {
                                last_modified: etag ? etag.replace(/"/g, "") : etag,
                                data: results,
                                next: next.bind(null, nextPage),
                                hasNextPage: !!nextPage,
                            };
                        };
                        handleResponse = function (_a) {
                            var headers = _a.headers, json = _a.json;
                            return __awaiter(this, void 0, void 0, function () {
                                var nextPage, etag;
                                return __generator(this, function (_b) {
                                    nextPage = headers.get("Next-Page");
                                    etag = headers.get("ETag");
                                    if (!pages) {
                                        return [2 /*return*/, pageResults(json.data, nextPage, etag)];
                                    }
                                    // Aggregate new results with previous ones
                                    results = results.concat(json.data);
                                    current += 1;
                                    if (current >= pages || !nextPage) {
                                        // Pagination exhausted
                                        return [2 /*return*/, pageResults(results, nextPage, etag)];
                                    }
                                    // Follow next page
                                    return [2 /*return*/, processNextPage(nextPage)];
                                });
                            });
                        };
                        _b = handleResponse;
                        return [4 /*yield*/, this.execute(
                            // N.B.: This doesn't use _getHeaders, because all calls to
                            // `paginatedList` are assumed to come from calls that already
                            // have headers merged at e.g. the bucket or collection level.
                            {
                                headers: options.headers ? options.headers : {},
                                path: path + "?" + querystring,
                            }, 
                            // N.B. This doesn't use _getRetry, because all calls to
                            // `paginatedList` are assumed to come from calls that already
                            // used `_getRetry` at e.g. the bucket or collection level.
                            { raw: true, retry: options.retry || 0 })];
                    case 1: return [2 /*return*/, _b.apply(void 0, [(_c.sent())])];
                }
            });
        });
    };
    /**
     * Lists all permissions.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number} [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object[], Error>}
     */
    KintoClientBase.prototype.listPermissions = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var path, paginationOptions;
            return __generator(this, function (_a) {
                path = endpoint_1.default.permissions();
                paginationOptions = __assign({ sort: "id" }, options);
                return [2 /*return*/, this.paginatedList(path, paginationOptions, {
                        headers: this._getHeaders(options),
                        retry: this._getRetry(options),
                    })];
            });
        });
    };
    /**
     * Retrieves the list of buckets.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers={}] Headers to use when making
     *     this request.
     * @param  {Number} [options.retry=0]    Number of retries to make
     *     when faced with transient errors.
     * @param  {Object} [options.filters={}] The filters object.
     * @param  {Array}  [options.fields]     Limit response to
     *     just some fields.
     * @return {Promise<Object[], Error>}
     */
    KintoClientBase.prototype.listBuckets = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var path;
            return __generator(this, function (_a) {
                path = endpoint_1.default.bucket();
                return [2 /*return*/, this.paginatedList(path, options, {
                        headers: this._getHeaders(options),
                        retry: this._getRetry(options),
                    })];
            });
        });
    };
    /**
     * Creates a new bucket on the server.
     *
     * @param  {String|null}  id                The bucket name (optional).
     * @param  {Object}       [options={}]      The options object.
     * @param  {Boolean}      [options.data]    The bucket data option.
     * @param  {Boolean}      [options.safe]    The safe option.
     * @param  {Object}       [options.headers] The headers object option.
     * @param  {Number}       [options.retry=0] Number of retries to make
     *     when faced with transient errors.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.createBucket = function (id, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, data, permissions, path;
            return __generator(this, function (_b) {
                _a = options.data, data = _a === void 0 ? {} : _a, permissions = options.permissions;
                if (id != null) {
                    data.id = id;
                }
                path = data.id ? endpoint_1.default.bucket(data.id) : endpoint_1.default.bucket();
                return [2 /*return*/, this.execute(requests.createRequest(path, { data: data, permissions: permissions }, {
                        headers: this._getHeaders(options),
                        safe: this._getSafe(options),
                    }), { retry: this._getRetry(options) })];
            });
        });
    };
    /**
     * Deletes a bucket from the server.
     *
     * @ignore
     * @param  {Object|String} bucket                  The bucket to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Number}        [options.retry=0]       Number of retries to make
     *     when faced with transient errors.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.deleteBucket = function (bucket, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var bucketObj, path, last_modified;
            return __generator(this, function (_a) {
                bucketObj = utils_1.toDataBody(bucket);
                if (!bucketObj.id) {
                    throw new Error("A bucket id is required.");
                }
                path = endpoint_1.default.bucket(bucketObj.id);
                last_modified = __assign({}, bucketObj, options).last_modified;
                return [2 /*return*/, this.execute(requests.deleteRequest(path, {
                        last_modified: last_modified,
                        headers: this._getHeaders(options),
                        safe: this._getSafe(options),
                    }), { retry: this._getRetry(options) })];
            });
        });
    };
    /**
     * Deletes all buckets on the server.
     *
     * @ignore
     * @param  {Object}  [options={}]            The options object.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */
    KintoClientBase.prototype.deleteBuckets = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var path;
            return __generator(this, function (_a) {
                path = endpoint_1.default.bucket();
                return [2 /*return*/, this.execute(requests.deleteRequest(path, {
                        last_modified: options.last_modified,
                        headers: this._getHeaders(options),
                        safe: this._getSafe(options),
                    }), { retry: this._getRetry(options) })];
            });
        });
    };
    KintoClientBase.prototype.createAccount = function (username, password) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.execute(requests.createRequest("/accounts/" + username, { data: { password: password } }, { method: "PUT" }))];
            });
        });
    };
    __decorate([
        utils_1.nobatch("This operation is not supported within a batch operation.")
    ], KintoClientBase.prototype, "fetchServerSettings", null);
    __decorate([
        utils_1.nobatch("This operation is not supported within a batch operation.")
    ], KintoClientBase.prototype, "fetchServerCapabilities", null);
    __decorate([
        utils_1.nobatch("This operation is not supported within a batch operation.")
    ], KintoClientBase.prototype, "fetchUser", null);
    __decorate([
        utils_1.nobatch("This operation is not supported within a batch operation.")
    ], KintoClientBase.prototype, "fetchHTTPApiVersion", null);
    __decorate([
        utils_1.nobatch("Can't use batch within a batch!")
    ], KintoClientBase.prototype, "batch", null);
    __decorate([
        utils_2.capable(["permissions_endpoint"])
    ], KintoClientBase.prototype, "listPermissions", null);
    __decorate([
        utils_1.support("1.4", "2.0")
    ], KintoClientBase.prototype, "deleteBuckets", null);
    __decorate([
        utils_2.capable(["accounts"])
    ], KintoClientBase.prototype, "createAccount", null);
    return KintoClientBase;
}());
exports.default = KintoClientBase;
