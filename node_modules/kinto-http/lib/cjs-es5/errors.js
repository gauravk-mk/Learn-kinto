"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Kinto server error code descriptors.
 */
var ERROR_CODES = {
    104: "Missing Authorization Token",
    105: "Invalid Authorization Token",
    106: "Request body was not valid JSON",
    107: "Invalid request parameter",
    108: "Missing request parameter",
    109: "Invalid posted data",
    110: "Invalid Token / id",
    111: "Missing Token / id",
    112: "Content-Length header was not provided",
    113: "Request body too large",
    114: "Resource was created, updated or deleted meanwhile",
    115: "Method not allowed on this end point (hint: server may be readonly)",
    116: "Requested version not available on this server",
    117: "Client has sent too many requests",
    121: "Resource access is forbidden for this user",
    122: "Another resource violates constraint",
    201: "Service Temporary unavailable due to high load",
    202: "Service deprecated",
    999: "Internal Server Error",
};
exports.default = ERROR_CODES;
var NetworkTimeoutError = /** @class */ (function (_super) {
    __extends(NetworkTimeoutError, _super);
    function NetworkTimeoutError(url, options) {
        var _this = _super.call(this, "Timeout while trying to access " + url + " with " + JSON.stringify(options)) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NetworkTimeoutError);
        }
        _this.url = url;
        _this.options = options;
        return _this;
    }
    return NetworkTimeoutError;
}(Error));
exports.NetworkTimeoutError = NetworkTimeoutError;
var UnparseableResponseError = /** @class */ (function (_super) {
    __extends(UnparseableResponseError, _super);
    function UnparseableResponseError(response, body, error) {
        var _this = this;
        var status = response.status;
        _this = _super.call(this, "Response from server unparseable (HTTP " + (status ||
            0) + "; " + error + "): " + body) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, UnparseableResponseError);
        }
        _this.status = status;
        _this.response = response;
        _this.stack = error.stack;
        _this.error = error;
        return _this;
    }
    return UnparseableResponseError;
}(Error));
exports.UnparseableResponseError = UnparseableResponseError;
/**
 * "Error" subclass representing a >=400 response from the server.
 *
 * Whether or not this is an error depends on your application.
 *
 * The `json` field can be undefined if the server responded with an
 * empty response body. This shouldn't generally happen. Most "bad"
 * responses come with a JSON error description, or (if they're
 * fronted by a CDN or nginx or something) occasionally non-JSON
 * responses (which become UnparseableResponseErrors, above).
 */
var ServerResponse = /** @class */ (function (_super) {
    __extends(ServerResponse, _super);
    function ServerResponse(response, json) {
        var _this = this;
        var status = response.status;
        var statusText = response.statusText;
        var errnoMsg;
        if (json) {
            // Try to fill in information from the JSON error.
            statusText = json.error || statusText;
            // Take errnoMsg from either ERROR_CODES or json.message.
            if (json.errno && json.errno in ERROR_CODES) {
                errnoMsg = ERROR_CODES[json.errno];
            }
            else if (json.message) {
                errnoMsg = json.message;
            }
            // If we had both ERROR_CODES and json.message, and they differ,
            // combine them.
            if (errnoMsg && json.message && json.message !== errnoMsg) {
                errnoMsg += " (" + json.message + ")";
            }
        }
        var message = "HTTP " + status + " " + statusText;
        if (errnoMsg) {
            message += ": " + errnoMsg;
        }
        _this = _super.call(this, message.trim()) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ServerResponse);
        }
        _this.response = response;
        _this.data = json;
        return _this;
    }
    return ServerResponse;
}(Error));
exports.ServerResponse = ServerResponse;
