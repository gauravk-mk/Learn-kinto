"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Chunks an array into n pieces.
 *
 * @private
 * @param  {Array}  array
 * @param  {Number} n
 * @return {Array}
 */
function partition(array, n) {
    if (n <= 0) {
        return [array];
    }
    return array.reduce(function (acc, x, i) {
        if (i === 0 || i % n === 0) {
            acc.push([x]);
        }
        else {
            acc[acc.length - 1].push(x);
        }
        return acc;
    }, []);
}
exports.partition = partition;
/**
 * Returns a Promise always resolving after the specified amount in milliseconds.
 *
 * @return Promise<void>
 */
function delay(ms) {
    return new Promise(function (resolve) { return setTimeout(resolve, ms); });
}
exports.delay = delay;
/**
 * Always returns a resource data object from the provided argument.
 *
 * @private
 * @param  {Object|String} resource
 * @return {Object}
 */
function toDataBody(resource) {
    if (isObject(resource)) {
        return resource;
    }
    if (typeof resource === "string") {
        return { id: resource };
    }
    throw new Error("Invalid argument.");
}
exports.toDataBody = toDataBody;
/**
 * Transforms an object into an URL query string, stripping out any undefined
 * values.
 *
 * @param  {Object} obj
 * @return {String}
 */
function qsify(obj) {
    var encode = function (v) {
        return encodeURIComponent(typeof v === "boolean" ? String(v) : v);
    };
    var stripUndefined = function (o) {
        return JSON.parse(JSON.stringify(o));
    };
    var stripped = stripUndefined(obj);
    return Object.keys(stripped)
        .map(function (k) {
        var ks = encode(k) + "=";
        if (Array.isArray(stripped[k])) {
            return ks + stripped[k].map(function (v) { return encode(v); }).join(",");
        }
        else {
            return ks + encode(stripped[k]);
        }
    })
        .join("&");
}
exports.qsify = qsify;
/**
 * Checks if a version is within the provided range.
 *
 * @param  {String} version    The version to check.
 * @param  {String} minVersion The minimum supported version (inclusive).
 * @param  {String} maxVersion The minimum supported version (exclusive).
 * @throws {Error} If the version is outside of the provided range.
 */
function checkVersion(version, minVersion, maxVersion) {
    var extract = function (str) { return str.split(".").map(function (x) { return parseInt(x, 10); }); };
    var _a = __read(extract(version), 2), verMajor = _a[0], verMinor = _a[1];
    var _b = __read(extract(minVersion), 2), minMajor = _b[0], minMinor = _b[1];
    var _c = __read(extract(maxVersion), 2), maxMajor = _c[0], maxMinor = _c[1];
    var checks = [
        verMajor < minMajor,
        verMajor === minMajor && verMinor < minMinor,
        verMajor > maxMajor,
        verMajor === maxMajor && verMinor >= maxMinor,
    ];
    if (checks.some(function (x) { return x; })) {
        throw new Error("Version " + version + " doesn't satisfy " + minVersion + " <= x < " + maxVersion);
    }
}
exports.checkVersion = checkVersion;
/**
 * Generates a decorator function ensuring a version check is performed against
 * the provided requirements before executing it.
 *
 * @param  {String} min The required min version (inclusive).
 * @param  {String} max The required max version (inclusive).
 * @return {Function}
 */
function support(min, max) {
    return function (target, key, descriptor) {
        var fn = descriptor.value;
        return {
            configurable: true,
            get: function () {
                var _this = this;
                var wrappedMethod = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    // "this" is the current instance which its method is decorated.
                    var client = _this.client ? _this.client : _this;
                    return client
                        .fetchHTTPApiVersion()
                        .then(function (version) { return checkVersion(version, min, max); })
                        .then(function () { return fn.apply(_this, args); });
                };
                Object.defineProperty(this, key, {
                    value: wrappedMethod,
                    configurable: true,
                    writable: true,
                });
                return wrappedMethod;
            },
        };
    };
}
exports.support = support;
/**
 * Generates a decorator function ensuring that the specified capabilities are
 * available on the server before executing it.
 *
 * @param  {Array<String>} capabilities The required capabilities.
 * @return {Function}
 */
function capable(capabilities) {
    return function (target, key, descriptor) {
        var fn = descriptor.value;
        return {
            configurable: true,
            get: function () {
                var _this = this;
                var wrappedMethod = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    // "this" is the current instance which its method is decorated.
                    var client = _this.client ? _this.client : _this;
                    return client
                        .fetchServerCapabilities()
                        .then(function (available) {
                        var missing = capabilities.filter(function (c) { return !(c in available); });
                        if (missing.length > 0) {
                            var missingStr = missing.join(", ");
                            throw new Error("Required capabilities " + missingStr + " not present on server");
                        }
                    })
                        .then(function () { return fn.apply(_this, args); });
                };
                Object.defineProperty(this, key, {
                    value: wrappedMethod,
                    configurable: true,
                    writable: true,
                });
                return wrappedMethod;
            },
        };
    };
}
exports.capable = capable;
/**
 * Generates a decorator function ensuring an operation is not performed from
 * within a batch request.
 *
 * @param  {String} message The error message to throw.
 * @return {Function}
 */
function nobatch(message) {
    return function (target, key, descriptor) {
        var fn = descriptor.value;
        return {
            configurable: true,
            get: function () {
                var _this = this;
                var wrappedMethod = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    // "this" is the current instance which its method is decorated.
                    if (_this._isBatch) {
                        throw new Error(message);
                    }
                    return fn.apply(_this, args);
                };
                Object.defineProperty(this, key, {
                    value: wrappedMethod,
                    configurable: true,
                    writable: true,
                });
                return wrappedMethod;
            },
        };
    };
}
exports.nobatch = nobatch;
/**
 * Returns true if the specified value is an object (i.e. not an array nor null).
 * @param  {Object} thing The value to inspect.
 * @return {bool}
 */
function isObject(thing) {
    return typeof thing === "object" && thing !== null && !Array.isArray(thing);
}
exports.isObject = isObject;
/**
 * Parses a data url.
 * @param  {String} dataURL The data url.
 * @return {Object}
 */
function parseDataURL(dataURL) {
    var regex = /^data:(.*);base64,(.*)/;
    var match = dataURL.match(regex);
    if (!match) {
        throw new Error("Invalid data-url: " + String(dataURL).substr(0, 32) + "...");
    }
    var props = match[1];
    var base64 = match[2];
    var _a = __read(props.split(";")), type = _a[0], rawParams = _a.slice(1);
    var params = rawParams.reduce(function (acc, param) {
        var _a;
        var _b = __read(param.split("="), 2), key = _b[0], value = _b[1];
        return __assign({}, acc, (_a = {}, _a[key] = value, _a));
    }, {});
    return __assign({}, params, { type: type, base64: base64 });
}
exports.parseDataURL = parseDataURL;
/**
 * Extracts file information from a data url.
 * @param  {String} dataURL The data url.
 * @return {Object}
 */
function extractFileInfo(dataURL) {
    var _a = parseDataURL(dataURL), name = _a.name, type = _a.type, base64 = _a.base64;
    var binary = atob(base64);
    var array = [];
    for (var i = 0; i < binary.length; i++) {
        array.push(binary.charCodeAt(i));
    }
    var blob;
    if (typeof Blob !== "undefined") {
        // Running in a browser environment.
        blob = new Blob([new Uint8Array(array)], { type: type });
    }
    else {
        // In NodeJS. Blob is not available.
        blob = Buffer.from(array);
    }
    return { blob: blob, name: name };
}
exports.extractFileInfo = extractFileInfo;
/**
 * Creates a FormData instance from a data url and an existing JSON response
 * body.
 * @param  {String} dataURL            The data url.
 * @param  {Object} body               The response body.
 * @param  {Object} [options={}]       The options object.
 * @param  {Object} [options.filename] Force attachment file name.
 * @return {FormData}
 */
function createFormData(dataURL, body, options) {
    if (options === void 0) { options = {}; }
    var _a = options.filename, filename = _a === void 0 ? "untitled" : _a;
    var _b = extractFileInfo(dataURL), blob = _b.blob, name = _b.name;
    var formData = new FormData();
    formData.append("attachment", blob, name || filename);
    for (var property in body) {
        if (typeof body[property] !== "undefined") {
            formData.append(property, JSON.stringify(body[property]));
        }
    }
    return formData;
}
exports.createFormData = createFormData;
/**
 * Clones an object with all its undefined keys removed.
 * @private
 */
function cleanUndefinedProperties(obj) {
    var result = {};
    for (var key in obj) {
        if (typeof obj[key] !== "undefined") {
            result[key] = obj[key];
        }
    }
    return result;
}
exports.cleanUndefinedProperties = cleanUndefinedProperties;
/**
 * Handle common query parameters for Kinto requests.
 *
 * @param  {String}  [path]  The endpoint base path.
 * @param  {Array}   [options.fields]    Fields to limit the
 *   request to.
 * @param  {Object}  [options.query={}]  Additional query arguments.
 */
function addEndpointOptions(path, options) {
    if (options === void 0) { options = {}; }
    var query = __assign({}, options.query);
    if (options.fields) {
        query._fields = options.fields;
    }
    var queryString = qsify(query);
    if (queryString) {
        return path + "?" + queryString;
    }
    return path;
}
exports.addEndpointOptions = addEndpointOptions;
/**
 * Replace authorization header with an obscured version
 */
function obscureAuthorizationHeader(headers) {
    var e_1, _a;
    var h = new Headers(headers);
    if (h.has("authorization")) {
        h.set("authorization", "**** (suppressed)");
    }
    var obscuredHeaders = {};
    try {
        for (var _b = __values(h.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), header = _d[0], value = _d[1];
            obscuredHeaders[header] = value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return obscuredHeaders;
}
exports.obscureAuthorizationHeader = obscureAuthorizationHeader;
